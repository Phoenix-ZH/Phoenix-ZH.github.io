<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>kuangbin专题14-数论基础 ~ Phoenix_ZH&#39;Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Phoenix_ZH'Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background"
         style="background: url('https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN@1.0/example.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期三, 七月 29日 2020, 5:41 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    3.1k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      15 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="1-题目名称："><a href="#1-题目名称：" class="headerlink" title="1.题目名称："></a>1.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1370" target="_blank" rel="noopener"><strong>LightOJ 1370</strong></a> Bi-shoe and Phi-shoe</p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给出n个数字的序列a[]，对于每个数字ai找到一个欧拉函数值大于等于ai的数bi，求找到的所有数bi的最小值之和sum </p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>已知a[]&lt;=1000000,要求得phi[]，则应当线性求phi。</p>
<p>1.phi(p) == p-1 因为素数p除了1以外的因子只有p，所以与 p 互素的个数是 p - 1个 </p>
<p>2.phi(p^k) == p^k - p^(k-1) == (p-1) * p^(k-1) </p>
<p>3.如果i mod p == 0, 那么 phi(i * p) == p * phi(i)  </p>
<p>4.如果i mod p != 0, 那么 phi(i * p) == phi(i) * (p-1)  </p>
<p>求得phi[]之后，就寻找大于等于a[i]的最小的phi[]的下标，求和。</p>
<p><strong>PS</strong>：WA了很多次：a[]&lt;=1000000,但是phi[]可能&gt;1000000</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1000000+100;
int vis_prime[maxn],prime[maxn],phi[maxn],T,n,a[maxn],tot;
void get_phi()
{
    phi[1]=0;
    for(long long i=2;i&lt;=1000020;i++)//WA了无数次，a[]&lt;=1000000,phi[]则可能&gt;1000000 
    {
        if(!vis_prime[i])
        {
            prime[++tot]=i;
            phi[i]=i-1;
        }
        for(long long j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=1000020;j++)
        {
            vis_prime[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                phi[i*prime[j]]=phi[i]*j;
                break;
            }
            else 
            {
                phi[i*prime[j]]=phi[i]*phi[prime[j]];
            }
        }
    }
}
int main()
{
    cin&gt;&gt;T;
    get_phi();
    long long cnt=0;
    while(T--)
    {
        cnt++;
        cin&gt;&gt;n;
        for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
        long long ans=0;
        sort(a+1,a+1+n);
        long long opt=1;
        for(long long i=1;i&lt;=n;i++)
        {
            while(phi[opt]&lt;a[i])opt++;
            ans+=opt;
        }
        printf(&quot;Case %lld: %lld Xukha\n&quot;,cnt,ans);
    }
    return 0;
}</code></pre>
<h1 id="2-题目名称："><a href="#2-题目名称：" class="headerlink" title="2.题目名称："></a>2.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1356" target="_blank" rel="noopener"><strong>LightOJ 1356</strong></a> Prime Independence</p>
<h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给出n个数，找出一个最大素数独立子集，如果a=b*一个素数，那么认为a是b的一个素数乘级，如果一个集合不存在一个数是另一个数的素数乘级，那么这就是素数独立子集。 </p>
<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>预处理出500000内的素数，对于a[i]可以得到a[i]*prime[j]对应的a[]的下标pos[]，这样i与pos[]就是存在关系：二者不可能在一个集合中。因此可以用二分图的做法，若两个数字之间存在素数倍数，则相连接，注意这里应该双向连接，因为两个互相有关系。最后n-最大匹配，求出最大独立集合。</p>
<p><strong>ps</strong>：匈牙利算法过不了，需要<strong>hopcroft-karp</strong>，但是我的板子好像错了QAQ</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=40000+50;
const int maxm=500000+50;
int a[maxn],T,n,dis;
vector&lt;int&gt;G[maxn];
int k=1,um[maxn],vm[maxn],dx[maxn],dy[maxn],prime_tot,prime[maxm],vis_prime[maxm],pos[maxm],vis[maxm];
void isprime()
{
    for(int i=2;i&lt;=500000;i++)
    {
        if(!vis_prime[i])
        {
            prime[++prime_tot]=i;
        }
        for(int j=1;j&lt;=prime_tot&amp;&amp;prime[j]*i&lt;=500000;j++)
        {
            vis_prime[prime[j]*i]=1;
            if(i%prime[j]==0)
            break;
        }
    }
}
bool searchP() {
    queue&lt;int&gt; q;
    dis=0x3f3f3f3f;
    memset(dx,-1,sizeof(dx));
    memset(dy,-1,sizeof(dy));
    unsigned short Head=0,Tail=0;
    for(int i=1; i&lt;=n; i++)
        if(um[i]==-1) {
            q.push(i);
            dx[i]=0;
        }
    while(!q.empty()) {
        int u=q.front();
        q.pop();
        if(dx[u]&gt;dis)  break;
        for(int i=0; i&lt;G[u].size(); i++) {
            int v = G[u][i];
            if(dy[v]==-1) {
                dy[v]=dx[u]+1;
                if(vm[v]==-1)  dis=dy[v];
                else {
                    dx[vm[v]]=dy[v]+1;
                    q.push(vm[v]);
                }
            }
        }
    }
    return dis!=0x3f3f3f3f;
}

bool dfs(int u) {
    for(int i=0; i&lt;G[u].size(); i++) {
        int v = G[u][i];
        if(!vis[v]&amp;&amp;dy[v]==dx[u]+1) {
            vis[v]=1;
            if(vm[v]!=-1&amp;&amp;dy[v]==dis) continue;
            if(vm[v]==-1||dfs(vm[v])) {
                vm[v]=u;
                um[u]=v;
                return 1;
            }
        }
    }
    return 0;
}

int maxMatch() {
    int res=0;
    memset(um,-1,sizeof(um));
    memset(vm,-1,sizeof(vm));
    while(searchP()) {
        memset(vis,0,sizeof(vis));
        for(int i=1; i&lt;=n; i++)
            if(um[i]==-1&amp;&amp;dfs(i))  res++;
    }
    return res;
}
int main()
{
    cin&gt;&gt;T;
    isprime();
    int opt=0;
    while(T--)
    {
        opt++;
        k=1;
        scanf(&quot;%d&quot;,&amp;n);
        memset(pos,0,sizeof(pos));
        for(int i=1;i&lt;=n;i++)
        {
            scanf(&quot;%d&quot;,&amp;a[i]);
            pos[a[i]]=i;
            G[i].clear();
        }
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=1;j&lt;=prime_tot&amp;&amp;(long long)prime[j]*a[i]&lt;=500000;j++)
            {
                if(pos[a[i]*prime[j]])
                {
                    G[i].push_back(pos[a[i]*prime[j]]);G[pos[a[i]*prime[j]]].push_back(i);
                }
            }
        }
        printf(&quot;Case %d: %d\n&quot;,opt,n-maxMatch()/2);
    }
    return 0;
}</code></pre>
<h1 id="3-题目名称："><a href="#3-题目名称：" class="headerlink" title="3.题目名称："></a>3.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1341" target="_blank" rel="noopener"><strong>LightOJ 1341</strong></a> Aladdin and the Flying Carpet</p>
<h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一对数字 a，b 。其中，a表示一个矩形的面积，想知道有多少种整数的边的组合可以组成面积为a的矩形，而且要求矩形的最短的边不得小于b </p>
<h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>一个大于1的正整数N，如果它的标准分解式为：   <img src="http://h.hiphotos.baidu.com/baike/s%3D124/sign=ae84eec8b4fd5266a32b38169f189799/f703738da97739129c546742fa198618367ae2a7.jpg" srcset="/img/loading.gif" alt="img"> ， 那么它的正因数个数为   <img src="http://b.hiphotos.baidu.com/baike/s%3D238/sign=d7c6a19a9c510fb37c197094e133c893/b151f8198618367aebbf90fe2c738bd4b31ce5db.jpg" srcset="/img/loading.gif" alt="img"> </p>
<p> 它的全体正因数之和为  <img src="http://h.hiphotos.baidu.com/baike/s%3D550/sign=86d9618aab014c081d3b28a03a7a025b/f7246b600c3387448405c35f530fd9f9d62aa0d5.jpg" srcset="/img/loading.gif" alt="img"> </p>
<p>而a&lt;=10^12,可以线性筛素数预处理10^6内的素数，则a可以做唯一分解定理，注意：可能最后a&gt;1，即不一定可以完全分解。所以在计算因数的时候a&gt;1时候，要ans*=2，记得最后求的是对数，所以ans/=2。由于b * b&gt;a，不可能有符合要求的答案，所以此时答案为0，因此b&lt;=10^6，所以只要找到[1,b）中的总对数sum，用ans-sum就是最后的答案。</p>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const long long maxn=1e6+50;
const long long N=1e6+47;
long long a,b;long long T;
long long prime[maxn],vis_prime[maxn],prime_tot;
void isprime()
{
    for(long long i=2;i&lt;=N;i++)
    {
        if(!vis_prime[i])
            prime[++prime_tot]=i;
        for(long long j=1;j&lt;=prime_tot&amp;prime[j]*i&lt;=N;j++)
        {
            vis_prime[i*prime[j]]=1;
            if(i%prime[j]==0)
                break;
        }
    }
}
int main()
{
    isprime();
    scanf(&quot;%lld&quot;,&amp;T);
    long long opt=0;
    while(T--)
    {
        opt++;
        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);
        long long p=a;
        if(b*b&gt;a)
        {
            printf(&quot;Case %lld: %lld\n&quot;,opt,0);
            continue;
        }
        long long ans=1;
        for(long long i=1;i&lt;=prime_tot;i++)
        {
            if(a%prime[i]==0)
            {
                long long tot=0;
                while(a%prime[i]==0)
                {
                    a/=prime[i];
                    tot++;
                }
                ans=ans*(tot+1);
            }
            if(a==1)break;
        }
        if(a&gt;1)ans*=2;
        ans/=2;
        for(long long i=1;i&lt;b;i++)
            if(p%i==0)
                ans--;
        printf(&quot;Case %lld: %lld\n&quot;,opt,ans);
    }
    return 0;    
} </code></pre>
<h1 id="4-题目名称："><a href="#4-题目名称：" class="headerlink" title="4.题目名称："></a>4.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1336" target="_blank" rel="noopener"><strong>LightOJ 1336</strong></a> Sigma Function</p>
<h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求和运算是一种有趣的操作，它来源于古希腊字母σ，现在我们来求一个数字的所有因子之和。例如σ(24)=1+2+3+4+6+8+12+24=60.对于小的数字求和是非常的简单，但是对于大数字求和就比较困难了。现在给你一个n，你需要求出有多少个[ 1 , n ]区间内的数字σ是偶数。<br>注：一个数字的σ指这个数的所有因子之和 </p>
<h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>显然给的公式， <img src="https://vj.z180.cn/1510021ce5adea20ba5ebd2baa22e212?v=1596100178" srcset="/img/loading.gif" alt="img"> </p>
<p>是没办法直接用的，对解题本身作用不大。</p>
<p>由唯一分解定律可以知道： <img src="http://h.hiphotos.baidu.com/baike/s%3D124/sign=ae84eec8b4fd5266a32b38169f189799/f703738da97739129c546742fa198618367ae2a7.jpg" srcset="/img/loading.gif" alt="img">)，则因数之和为<img src="http://h.hiphotos.baidu.com/baike/s%3D550/sign=86d9618aab014c081d3b28a03a7a025b/f7246b600c3387448405c35f530fd9f9d62aa0d5.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><strong>规律1：</strong>偶数 * 偶数=偶数；偶数 * 奇数=偶数；奇数 * 奇数=奇数。可以先求得因数之和为奇数的个数，然后总数减去它，就是偶数的个数。要让因数之和为奇数，必须让上面的各项均为奇数。</p>
<p><strong>规律2：</strong>所有的素数中只有2是偶数，其余的素数都是奇数。</p>
<p><strong>规律3：</strong>要让因数之和为奇数，就要让 (1+pi+pi^2+……+pi^ai)这个东西都是奇数 。根据<strong>规律2</strong>，需要分成两种情况来考虑：<br>1）pi=2，则 (1+pi+pi^2+……+pi^ai)一定是奇数。<br>2）pi是奇数，pi^ai一定也是奇数，则需要考虑ai的奇偶。<br>      如果ai是奇数，则1+pi+pi^2+……+pi^ai就是偶数个奇数相加为偶数；<br>      如果ai是偶数，则1+pi+pi^2+……+pi^ai就是奇数个奇数相加为奇数。<br>因此ai是偶数才能使得pi为奇数时，因数之和为奇数。</p>
<p>①当ai是偶数且pi为奇数时（不存在素数2），<img src="http://h.hiphotos.baidu.com/baike/s%3D124/sign=ae84eec8b4fd5266a32b38169f189799/f703738da97739129c546742fa198618367ae2a7.jpg" srcset="/img/loading.gif" alt="img">，则也可以表示成<br>$$<br>N=P_1^{a_1’^{2}}P_2^{a_2’^{2}}…P_n^{a_n’^{2}}即N=(P_1^{a_1’}P_2^{a_2’}…P_n^{a_n’})^{2}<br>$$<br>所以此时N一定是完全平方数。</p>
<p>②当ai是偶数且pi为奇数时（存在素数2），N就相当于一个完全平方数 * 2^x。<br>综上所述，N的因数和要为奇数，则N要么是完全平方数，要么是2*完全平方数。</p>
<h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
long long T,n;
int main()
{
    cin&gt;&gt;T;
    int opt=0;
    while(T--)
    {
        opt++;
        scanf(&quot;%lld&quot;,&amp;n);
        long long ans=0;
        for(long long i=1;i*i&lt;=n;i++)ans++;
        for(long long i=1;i*i*2&lt;=n;i++)ans++;
        printf(&quot;Case %d: %lld\n&quot;,opt,n-ans);
    }
    return 0;
 } </code></pre>
<h1 id="5-题目名称："><a href="#5-题目名称：" class="headerlink" title="5.题目名称："></a>5.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1282" target="_blank" rel="noopener"><strong>LightOJ 1282</strong></a> Leading and Trailing</p>
<h2 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定两个数n,k 求n^k的前三位和最后三位 </p>
<h2 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h2><p>对于后三位：直接快速幂取模，但是需要注意最后如果小于100，就需要补前缀0，小于10补2个，小于100补1个。</p>
<p>对于前三位：<br>$$<br>n^{k}=A==&gt;klog_{10}n=log_{10}A==&gt;A=10^{klog_{10}n}<br>$$</p>
<p>$$<br>假设A=10^{a+b},其中a是整数部分，b是小数部分，并且a+b=klog_{10}n<br>$$</p>
<p>所以可以得到整数a，和小数b，10^a控制A的位数，而10^b控制A的每一位的实际数字，即10^b就是X.xxxxxxx，要求A的前三位，那么就是10^(2+b)。</p>
<h2 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int T,n,k;
int fastpow(int x,int p)
{
    int ans=1;
    while(p)
    {
        if(p&amp;1)ans=(ans*x)%1000;
        p&gt;&gt;=1;
        x=(x*x)%1000;
    }
    return ans;
}
int main()
{
    cin&gt;&gt;T;
    int opt=0;
    while(T--)
    {
        opt++;
        cin&gt;&gt;n&gt;&gt;k;
        double y=k*log10(n);
        int y1=y;
        double b=y-y1;
        int ans=pow(10,2+b);
        printf(&quot;Case %d: %d &quot;,opt,ans);
        int x=n%1000;
        x=fastpow(x,k);
        if(x&lt;100)printf(&quot;0&quot;);
        if(x&lt;10)printf(&quot;0&quot;);
        printf(&quot;%d\n&quot;,x);
    }
    return 0;
}</code></pre>
<h1 id="6-题目名称："><a href="#6-题目名称：" class="headerlink" title="6.题目名称："></a>6.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1245" target="_blank" rel="noopener"><strong>LightOJ 1245</strong></a> Harmonic Number (II)</p>
<h2 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求解：F(n)的值 （<strong>1 ≤ n &lt; 2147483648</strong> ）</p>
<pre><code class="cpp">long long F(int n) {
    long long res = 0;
    for (int i = 1; i &lt;= n; i++) {
        res += n / i;
    }
    return res;
}</code></pre>
<h2 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h2><p>如果保证n&lt;=500000就可以避免超时。对于一个大于500000的数，可以将n/i=1，n/i=2…分别作为一组，这样再大的数，再10000次操作也可以减小到500000，时间复杂度也降低了。每一次操作res+=(i-1)*(pre-next+1).</p>
<h2 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
long long T,n;
int main()
{
    cin&gt;&gt;T;
    long long opt=0;
    while(T--)
    {
        opt++;
        cin&gt;&gt;n;
        long long res=0;
        if(n&gt;=500000)
        {
            long long pre=n;
            for(long long i=2;i&lt;=10000;i++)
            {
                long long next=n/i;next++;
                res+=(i-1)*(pre-next+1);
                pre=next-1;
            }
            for(long long i=1;i&lt;=pre;i++)
            res+=n/i;
        }
        else 
        {
            for(long long i=1;i&lt;=n;i++)
            res+=n/i;
        }
        printf(&quot;Case %lld: %lld\n&quot;,opt,res);
    }
    return 0;
}</code></pre>
<h1 id="7-题目名称："><a href="#7-题目名称：" class="headerlink" title="7.题目名称："></a>7.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1236" target="_blank" rel="noopener"><strong>LightOJ 1236</strong></a> Pairs Forming LCM</p>
<h2 id="题目大意：-6"><a href="#题目大意：-6" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求解res： <strong>n (1 ≤ n ≤ 10^14)</strong></p>
<pre><code class="cpp">long long pairsFormLCM( int n ) {
    long long res = 0;
    for( int i = 1; i &lt;= n; i++ )
        for( int j = i; j &lt;= n; j++ )
           if( lcm(i, j) == n ) res++; // lcm means least common multiple
    return res;
}</code></pre>
<h2 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h2><p>假设n是a，b的最小公倍数。<br>对a，b进行质因数分解：<br>$$<br>a=p_1^{a_1}<em>p_2^{a_2}</em>…*p_n^{a_n}<br>$$</p>
<p>$$<br>b=p_1^{b_1}<em>p_2^{b_2}</em>…*p_n^{b_n}<br>$$</p>
<p>因此：<br>$$<br>gcd(a,b)=p_1^{min(a_1,b_1)}<em>p_2^{min(a_2,b_2)}</em>…*p_n^{min(a_n,b_n)}<br>$$</p>
<p>$$<br>lcm(a,b)=p_1^{max(a_1,b_1)}<em>p_2^{max(a_2,b_2)}</em>…*p_n^{max(a_n,b_n)}<br>$$</p>
<p>根据题意得：lcm(a,b)=n.<br>                       假设max(ai,bi)=ei</p>
<p>所以：<br>$$<br>n=p_1^{e_1}<em>p_2^{e_2}</em>…<em>p_n^{e_n}<br>$$<br>*</em>接下来就是计算方案数：**</p>
<p>对于每一项质因数的幂pi^ei,需要a，b中至少有一个pi^ei，另一个随机。当ai=bi=ei时，方案只有一个。总数为2*(ei+1)-1</p>
<p><strong>计算总方案：</strong></p>
<p>将上述的结果叠乘，然后将总方案数/2+1， 加一是因为如果直接除以2，其中有一种方案ai=bi=ei是a等于b的，所以除多了，需要加上1 </p>
<h2 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e7+50;
const int N=1e7;
typedef long long ll;
ll T,n,prime_tot;bool vis_prime[maxn];int prime[1000010];
void isprime()
{
    for(ll i=2;i&lt;=N;i++)
    {
        if(!vis_prime[i])
            prime[++prime_tot]=i;
        for(ll j=1;j&lt;=prime_tot&amp;&amp;prime[j]*i&lt;=N;j++)
        {
            vis_prime[i*prime[j]]=1;
            if(i%prime[j]==0)
                break;
        }
    }
}
int main()
{
    cin&gt;&gt;T;
    isprime();
    int opt=0;
    while(T--)
    {
        opt++;
        cin&gt;&gt;n;
        ll ans=1;
        for(ll i=1;i&lt;=prime_tot&amp;&amp;prime[i]&lt;=n;i++)
        {
            if(n%prime[i]==0)
            {
                ll tot=0;
                while(n%prime[i]==0)
                {
                    tot++;
                    n/=prime[i];    
                }
                ans=ans*(2*(tot+1)-1);
            }
        }
        if(n&gt;1)ans=ans*(2*2-1);
        ans=ans/2+1;
        printf(&quot;Case %lld: %lld\n&quot;,opt,ans);
    }
    return 0;
}</code></pre>

        <div id="aplayer-ERANnIBJ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-ERANnIBJ"),
            narrow: false,
            autoplay: true,
            showlrc: false,
            music: {
              title: "那年",
              author: "枯木逢春",
              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0">线性筛素数</a>
                
                  <a class="hover-with-bg" href="/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</a>
                
                  <a class="hover-with-bg" href="/tags/hopcroft-karp">hopcroft-karp</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  
    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?MC7rf8QP3x";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "kuangbin专题14-数论基础&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  







</body>
</html>
