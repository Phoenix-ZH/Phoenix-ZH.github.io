<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>NOJ-test4 ~ Phoenix_ZH&#39;Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Phoenix_ZH'Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background"
         style="background: url('https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN@1.0/example.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期一, 十一月 2日 2020, 7:23 晚上
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    3.8k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      20 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <p>先补作业，再补题解。（有缘补题解QAQ）</p>
<h1 id="A-最长公共子序列"><a href="#A-最长公共子序列" class="headerlink" title="A-最长公共子序列"></a>A-最长公共子序列</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
char s[maxn],t[maxn];int lens,lent,dp[maxn][maxn];
int max(int x,int y){
    if(x&gt;=y)return x;
    return y;
}
int main(){
    cin&gt;&gt;s+1&gt;&gt;t+1;
    lens=strlen(s+1);lent=strlen(t+1);
    for(int i=1;i&lt;=lens;i++){
        for(int j=1;j&lt;=lent;j++){
            if(s[i]==t[j]){
                dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);
            }
            else{
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    cout&lt;&lt;dp[lens][lent]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h1 id="B-防卫导弹"><a href="#B-防卫导弹" class="headerlink" title="B-防卫导弹"></a>B-防卫导弹</h1><p>lower_bound(dp+1,dp+1+n,h[i])dp[]中第一个&gt;=h[i]的下标<br>upper_bound(dp+1,dp+1+n,h[i])dp[]中第一个&gt;h[i]的下标<br>lower_bound(dp+1,dp+1+n,h[i],greater&lt; int &gt;())dp[]中第一个&lt;=h[i]的下标 greater&lt; int &gt;() == cmp(int x,int y){return x&gt;y}<br>upper_bound(dp+1,dp+1+n,h[i],greater&lt; int &gt;())dp[]中第一个&lt;h[i]的下标 </p>
<p>greater&lt; int &gt;()表示内置类型从大到小排序，比如说原序列是1，2，4，7，15，34，在greater&lt; int &gt;()的表示下，<br>1&gt;2&gt;4&gt;7&gt;15&gt;34,lower_bound(num,num+6,7,greater&lt; int &gt;()) 返回greater&lt; int &gt;序列下第一个大于或等于被查数7的值，<br>即4；也就是返回的是原序列的中第一个小于或等于被查数7的值</p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
int n,h[maxn],dp[maxn];
int max(int x,int y){
    if(x&gt;=y)return x;
    return y;
}
int cmp(int x,int y){
    return x&gt;y;
}
int main(){
    int i;
    while(1){
        cin&gt;&gt;n;
        if(n==0)break;
        for(i=1;i&lt;=n;i++)cin&gt;&gt;h[i],dp[i]=0;
        int ans=0;
        for(i=1;i&lt;=n;i++){
            int t=upper_bound(dp+1,dp+1+n,h[i],cmp)-dp;
            dp[t]=h[i];
            ans=max(ans,t);
        }
        cout&lt;&lt;ans&lt;&lt;endl;        
    }
    return 0;
}
</code></pre>
<h1 id="C-田忌赛马-tian-ji-racing"><a href="#C-田忌赛马-tian-ji-racing" class="headerlink" title="C-田忌赛马(tian ji racing)"></a>C-田忌赛马(tian ji racing)</h1><p>如果田忌最快的马快于齐王最快的马，就PK<br>如果田忌最快的马慢于齐王最快的马：<br>    如果田忌最慢的马快于齐王的最慢的马，PK<br>    否则就田忌最慢的马PK齐王最快的马（反正都是输） </p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
int n,a[maxn],b[maxn];
int main(){
    int i;
    while(1){
        cin&gt;&gt;n;
        if(n==0)break;
        for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
        for(i=1;i&lt;=n;i++)cin&gt;&gt;b[i];
        sort(a+1,a+1+n);sort(b+1,b+1+n);
        int opt1=1,opt2=1,up1=n,up2=n,win=0,lose=0;
        while(up1&gt;=opt1){
            if(a[up1]&gt;b[up2])win++,up1--,up2--;
            else {
                if(a[opt1]&gt;b[opt2])win++,opt1++,opt2++;
                else if(a[opt1]&lt;b[up2])lose--,opt1++,up2--;
                else opt1++,up2--;
            }
        }
    //    cout&lt;&lt;win&lt;&lt;&#39; &#39;&lt;&lt;lose&lt;&lt;endl;
        cout&lt;&lt;win+lose&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h1 id="D-计算矩阵连乘积"><a href="#D-计算矩阵连乘积" class="headerlink" title="D-计算矩阵连乘积"></a>D-计算矩阵连乘积</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
int n,p[maxn],q[maxn],dp[maxn][maxn];
int min(int x,int y){
    if(x&lt;=y)return x;
    return y;
}
int main(){
    cin&gt;&gt;n;
    memset(dp,0x3f3f3f3f,sizeof(dp));
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;p[i]&gt;&gt;q[i];
        dp[i][i]=0;
    }
    for(int len=2;len&lt;=n;len++){
        for(int l=1;l&lt;=n;l++){
            int r=l+len-1;
            for(int m=l;m&lt;=r-1;m++){
                dp[l][r]=min(dp[l][r],dp[l][m]+dp[m+1][r]+p[l]*q[m]*q[r]);
            }
        }
    }
    cout&lt;&lt;dp[1][n]&lt;&lt;endl;
    return 0;
}
</code></pre>
<h1 id="E-石子合并"><a href="#E-石子合并" class="headerlink" title="E-石子合并"></a>E-石子合并</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=200+50;
int a[maxn],n,dp[maxn][maxn],sum[maxn];
int min(int x,int y){
    if(x&lt;=y)return x;
    return y;
}
int main(){
    while(1){
        int i;
        cin&gt;&gt;n;
        if(n==0)break;
        memset(dp,0x3f3f3f3f,sizeof(dp));
        for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i],dp[i][i]=dp[i+n][i+n]=0;
        for(i=1;i&lt;=n;i++)sum[i+n]=sum[i+n-1]+a[i]; 
        for(int len=2;len&lt;=n;len++){
            for(int l=1;l&lt;=2*n-len+1;l++){
                int r=l+len-1;
                for(int m=l;m&lt;=r-1;m++){
                    dp[l][r]=min(dp[l][r],dp[l][m]+dp[m+1][r]+sum[r]-sum[l-1]);
                }
            }
        }//len从2到n 更新 
        int ans=0x3f3f3f3f;
        for(i=1;i&lt;=n;i++){
            ans=min(ans,dp[i][i+n-1]);
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h1 id="F-旅游预算"><a href="#F-旅游预算" class="headerlink" title="F-旅游预算"></a>F-旅游预算</h1><p><strong>ps：</strong>注意油量超过一半并且可以到达下一个点不加油！ </p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
struct Node{
    double w,d;
}a[maxn]; 
double s,v,p,dp[maxn];int n,pre[maxn],t[maxn];
double min(double x,double y){
    if(x&lt;=y)return x;
    return y;
}
int main(){
    int i,j;
    cin&gt;&gt;s&gt;&gt;v&gt;&gt;p&gt;&gt;dp[0]&gt;&gt;n;
    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i].d&gt;&gt;a[i].w,dp[i]=1e9;
    double road=v*p;
    for(i=1;i&lt;=n;i++){
        for(j=0;j&lt;=i-1;j++){
            if(a[i].d-a[j].d&gt;road||(a[i].d-a[j].d)*2&lt;road)continue;//注意油量超过一半并且可以到达下一个点不加油！ 
            double ned=(a[i].d-a[j].d)/p;
            if(dp[i]&gt;dp[j]+ned*a[i].w+2){
                dp[i]=dp[j]+ned*a[i].w+2;
                pre[i]=j;
            }
        }
    }
    double ans=0x3f3f3f3f;int last=0,tot=0;
    for(i=0;i&lt;=n;i++){
        if(road&lt;s-a[i].d)continue;
        if(ans&gt;dp[i]){
            ans=dp[i];
            last=i;
        }
    }
    while(last!=0){
        t[++tot]=last;
        last=pre[last];
    }
    printf(&quot;%.2lf %d\n&quot;,ans,tot);
    for(i=tot;i&gt;=1;i--)cout&lt;&lt;t[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;
    return 0;
}
</code></pre>
<h1 id="G-花生米（二）"><a href="#G-花生米（二）" class="headerlink" title="G-花生米（二）"></a>G-花生米（二）</h1><p>博弈论：<br>定义： jerry后手胜利 为必胜态。<br>10以内的必胜状态：1,3,5,7,9.<br>由于可以一次拿10个，我们需要考虑10周围的情况:11为必胜 。<br>什么才是必败态？<br>当前面i-1,i-5,i-10这10个状态都是必胜态的时候， i一定是必败态。<br>否则 i就有机会成为必胜态。<br>dp[i]=1表示i是必胜态。 </p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
int n,dp[maxn];
int main(){
    dp[1]=1;dp[3]=1;dp[5]=1;dp[7]=1;dp[9]=1;dp[11]=1;
    for(int i=12;i&lt;=1000;i++){
        if(dp[i-1]&amp;&amp;dp[i-5]&amp;&amp;dp[i-10])dp[i]=0;
        else dp[i]=1;
    }
    while(1){
        cin&gt;&gt;n;
        if(n==0)break;
        if(dp[n])cout&lt;&lt;0&lt;&lt;endl;
        else cout&lt;&lt;1&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h1 id="H-花生米（三）"><a href="#H-花生米（三）" class="headerlink" title="H-花生米（三）"></a>H-花生米（三）</h1><p>dp[i][j]==0：Jerry后手且此时剩余i个当前可取j个并且是必胜态 </p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
int n,dp[maxn][maxn];
int min(int x,int y){
    if(x&lt;=y)return x;
    return y;
}
int dfs(int res,int c){
    int i;
    if(res==1){
        dp[res][c]=0;
        return 0;
    }
    else if(dp[res][c]!=-1)return dp[res][c];
    int sign=1;
    for(i=1;i&lt;=min(res,c);i++){
        sign=sign&amp;dfs(res-i,2*i);//下一个dfs就是Jerry先手的状态了，必须全部为1，才能使得当前dfs中的为后手必胜 
        if(sign==0)break;
    }
    dp[res][c]=0;
    if(sign==0)
    dp[res][c]=1;
    return dp[res][c];
}
int main(){
    int i,j;
    while(1){
        cin&gt;&gt;n;
        if(n==0)break;
        for(i=0;i&lt;=1000;i++){
            for(j=0;j&lt;=1000;j++){
                dp[i][j]=-1;
            }
        }
        cout&lt;&lt;dfs(n,1)&lt;&lt;endl;
    }
}
</code></pre>
<h1 id="I-花生米（四）"><a href="#I-花生米（四）" class="headerlink" title="I-花生米（四）"></a>I-花生米（四）</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
int n,a[maxn];
int main(){
    while(1){
        cin&gt;&gt;n;
        if(n==0)break;
        int sum=0,cnt=0,tot=0; 
        for(int i=1;i&lt;=n;i++){
            cin&gt;&gt;a[i],sum+=a[i];
            if(a[i]==1)cnt++;
        }
        if(n==1){
            cout&lt;&lt;0&lt;&lt;endl;
        }
        else if(cnt==n){
            if(n%2==0)cout&lt;&lt;0&lt;&lt;endl;
            else cout&lt;&lt;1&lt;&lt;endl;
        }
        else{
            if(n==2){
                if(a[1]==a[2])cout&lt;&lt;0&lt;&lt;endl;//对称取 
                else cout&lt;&lt;1&lt;&lt;endl;//Tom先手先让a[1]==a[2]，Tom对称取，Jerry必败，所以Jerry必须先手 
            }
            else{
                int sign1=0,sign2=0;    
                if(cnt&gt;0&amp;&amp;cnt%2==0)sign1=0;//只含1个花生米的堆数为偶数 
                else sign1=1;
                if((n-cnt)%2==0)sign2=0;//含&gt;1个花生米的堆数为偶数 
                else sign2=1; 
                if(sign1&amp;&amp;sign2)cout&lt;&lt;1&lt;&lt;endl;//全奇数堆先手必胜，所以Jerry必须先手：比如1 1 1 3 3 3--&gt;1 3 3 3先手必胜 （后手无法赢） 
                else cout&lt;&lt;0&lt;&lt;endl;//如果存在偶数堆，则让对手取成全奇，在此之前，Jerry保持非全奇 
                //如果1 1 1 1 3 3 3 3 .如果先手选3，后手跟着选3，直到3用完，先手选择1，后手到达必胜态
                //如果 先手选3中的2，--&gt;1 1 1 1 1 3 3 3 后手选 1--&gt;1 1 1 1 3 3 3,直到3用完，先手选择1，后手到达必胜态。
                //同理1 1 1 3 3 3 3类型和1 1 1 1 3 3 3类型。 
                //注意 7 3 3 3 3 3 3 3 这种类型即cnt==0，这个时候sign1=1，sign2=1，就是指只存在奇数堆，先手必胜。 
            }
        }
    }
    return 0;
} 
/*7
3 3 3 3 3 3 3
*/
//Jerry 后手必胜的条件：后手且吃掉最后的花生米，则Jerry无法后手胜利。
</code></pre>
<h1 id="J-花生米（五）"><a href="#J-花生米（五）" class="headerlink" title="J-花生米（五）"></a>J-花生米（五）</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10000+50;
int dp[maxn];
int dfs(int res,int c){
    int i;
    if(res&lt;c){
        dp[res]=0;
        return dp[res];
    }
    if(dp[res]!=-1)return dp[res];
    int sign=1;
    for(i=c;i&lt;=3*c;i++){
        if(res&lt;i)break;
        sign&amp;=dfs(res-i,c+i);
        if(sign==0)break;
    }
    dp[res]=0;
    if(!sign)dp[res]=1;
    return dp[res];
}
int main(){
    int tot=0;
    while(1){
        int i;
        double x;
        cin&gt;&gt;x;
        if(x&lt;0)break;
        for(i=0;i&lt;=x*10;i++){
            dp[i]=-1;
        }
        int w=x*10;
        cout&lt;&lt;1-dfs(w-10,10)&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h1 id="K-装盘子"><a href="#K-装盘子" class="headerlink" title="K-装盘子"></a>K-装盘子</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100+50;
int n,m,dp[maxn][maxn];
int dfs(int resn,int resm){
    if(resn==1||resm==1||resm==0)return 1;
    if(dp[resn][resm])return dp[resn][resm];
    int ans=0;
    if(resm&lt;resn)ans=dfs(resm,resm);
    else ans=dfs(resn-1,resm)+dfs(resn,resm-resn);
    dp[resn][resm]=ans;
    return ans;
}
int main(){
    cin&gt;&gt;m&gt;&gt;n;
    cout&lt;&lt;dfs(n,m)&lt;&lt;endl;
    return 0;
}
</code></pre>
<h1 id="L-滑雪"><a href="#L-滑雪" class="headerlink" title="L-滑雪"></a>L-滑雪</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=200+50;
int n,m,h[maxn][maxn],dp[maxn][maxn];
int max(int x,int y){
    if(x&gt;=y)return x;
    return y;
}
int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int dfs(int x,int y){
    if(dp[x][y])return dp[x][y];
    dp[x][y]=1;
    int sign=0,ans=0,i;
    for(i=0;i&lt;4;i++){
        int nexx=x+d[i][0],nexy=y+d[i][1];
        if(nexx&gt;=1&amp;&amp;nexx&lt;=n&amp;&amp;nexy&gt;=1&amp;&amp;nexy&lt;=m&amp;&amp;h[nexx][nexy]&gt;h[x][y])sign++,ans=max(ans,dfs(nexx,nexy)+1);
    }
    if(!sign)dp[x][y]=1;
    else dp[x][y]=ans;
    return dp[x][y];
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    int i,j,k,maxx=0;
    for(i=1;i&lt;=n;i++){
        for(j=1;j&lt;=m;j++){
            cin&gt;&gt;h[i][j];
        }
    }
    int ans=0;
    for(i=1;i&lt;=n;i++){
        for(j=1;j&lt;=m;j++){
            ans=max(ans,dfs(i,j));
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<h1 id="I’-最大连续子序列和问题"><a href="#I’-最大连续子序列和问题" class="headerlink" title="I’-最大连续子序列和问题"></a>I’-最大连续子序列和问题</h1><p><strong>描述</strong>：</p>
<p>给定一整数序列A0，A1， A2，… An-1 （可能有负数），求A0~An-1的一个连续子序列Ai~Aj，使得Ai到Aj的和最大。</p>
<p><strong>输入</strong>：</p>
<p>先输入一个正整数n(1&lt;n&lt;1000)，再输入n个整数。</p>
<p><strong>输出</strong>：</p>
<p>输出最大连续子序列的和。</p>
<p><strong>输入样例</strong>：</p>
<pre><code>102 -1 5 -7 2 -1 4 -2 4 -5
</code></pre><p><strong>输出样例</strong>：</p>
<pre><code>7
</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>代码还没有AC，NOJ评测机炸了，但是这个O(n)的思路大概是对的：sum[i]为前i个数字的连续子序列的最大和。如果sum[i-1]<0，那对于sum[i]就没必要加上前i-1的总和了，因为这样对答案的贡献还不如0.如果sum[i-1]>0,则sum[i]=sum[i-1]+a[i].ans=max(ans,sum[i]);</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10000+50;
int n,a[maxn],sum[maxn];
int max(int x,int y){
    if(x&gt;=y)return x;
    return y;
}
int main(){
    int i;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    int ans=0;
    for(i=1;i&lt;=n;i++){
        if(sum[i-1]&gt;0)sum[i]=sum[i-1]+a[i];
        else sum[i]=a[i];
        ans=max(ans,sum[i]);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<h1 id="J’-0-1背包问题"><a href="#J’-0-1背包问题" class="headerlink" title="J’-0-1背包问题"></a>J’-0-1背包问题</h1><p><strong>描述：</strong></p>
<p>一个背包容量为c ，现有n件物品，求能装入背包的最大重量是多少？</p>
<p><strong>输入：</strong></p>
<p>先输入两个正整数n、c（0&lt;n、c&lt;1000），表示物品的件数和背包容量，再输入n个正整数，分别是这n件物品的重量。</p>
<p><strong>输出：</strong></p>
<p>输出能装入背包的最大重量。</p>
<p><strong>输入样例：</strong></p>
<pre><code>5 5023 18 13 35 24
</code></pre><p><strong>输出样例：</strong></p>
<pre><code>48
</code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>0-1背包的裸题，那就可以直接写一个01背包的动态转移方程：dp[j]=max(dp[j],dp[j-w[i]]+p[i])。dp[j]的意思是：当背包已装j的重量的物品时的最大价值。那么它可以由背包已装j-w[i]时最大的价值进行转移，即由dp[j-w[i]]+p[i]得到。注意每一次要将dp[]设置为0，因为背包此时无价值。当状态方程枚举结束后，我们再从 dp[]数组中找一遍，求得答案maxx=max{dp[i]}(i from 0 to c)，输出答案maxx。这种动态规划的方法的时间复杂度为O(n^2).</p>
<p><strong>ps：</strong>0-1背包也可以写成二维dp[][]，只是这样写成滚动数组可以更加节省空间。</p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>除了直接写0-1背包的动态转移方程，还可以直接写dfs，每一个背包无非就是取和不取两个状态，如果要取则要求背包容量 res&gt;=w[now]。分别用ans1，ans2表示取当前物品，不取当前物品的最大价值，dfs返回max(ans1,ans2)，dfs的终止条件是now ==n+1。时间复杂度(2^n)。</p>
<p><strong>ps:</strong>方法二相较于方法一思维上更加简单，容易想到，但是代码就相对麻烦，并且时间复杂度不够优秀，当然如果加上记忆化搜索后时间复杂度和动态规划是相当的。我个人更喜欢方法一。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=    2000+50;
int n,c,w[maxn],dp[maxn],p[maxn];
int main(){
    int i,j;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;c);
    for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i],p[i]=w[i];
    for(i=1;i&lt;=n;i++){
        for(j=c;j&gt;=1;j--){
            if(j-w[i]&gt;=0&amp;&amp;dp[j]&lt;dp[j-w[i]]+p[i]){
                dp[j]=dp[j-w[i]]+p[i];
            }
        }
    }
    int maxx=0;
    for(i=0;i&lt;=c;i++)
        if(maxx&lt;dp[i])
            maxx=dp[i];
    cout&lt;&lt;maxx&lt;&lt;endl;
    return 0;
}
</code></pre>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=    2000+50;
int n,c,w[maxn],p[maxn];
int dfs(int now,int res){
    if(now==n+1)return 0;
    int ans1=0,ans2=0;
    if(res&gt;=w[now]){
        ans1=dfs(now+1,res-w[now])+p[now];
    }
    ans2=dfs(now+1,res);
    if(ans1&gt;=ans2)return ans1;
    return ans2;
}
int main(){
    int i,j;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;c);
    for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i],p[i]=w[i];
    cout&lt;&lt;dfs(1,c)&lt;&lt;endl;
    return 0;
}
</code></pre>

        <div id="aplayer-KqmCHyHz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-KqmCHyHz"),
            narrow: false,
            autoplay: true,
            showlrc: false,
            music: {
              title: "那年",
              author: "枯木逢春",
              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/NOJ">NOJ</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      

    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  
    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?MC7rf8QP3x";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "NOJ-test4&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  







</body>
</html>
