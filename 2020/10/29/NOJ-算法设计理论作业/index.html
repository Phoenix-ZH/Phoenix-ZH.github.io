<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>NOJ-算法设计理论作业 ~ Phoenix_ZH&#39;Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Phoenix_ZH'Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background"
         style="background: url('https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN@1.0/example.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期四, 十月 29日 2020, 12:01 凌晨
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    4.4k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      19 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h1><p>描述</p>
<p>给定一个单调递增的整数序列，问某个整数是否在序列中。</p>
<p>输入</p>
<p>第一行为一个整数n，表示序列中整数的个数；第二行为n（n不超过10000）个整数；第三行为一个整数m（m不超过50000），表示查询的个数；接下来m行每行一个整数k。</p>
<p>输出</p>
<p>每个查询的输出占一行，如果k在序列中，输出Yes，否则输出No。</p>
<p>输入样例</p>
<p>5<br>1 3 4 7 11<br>3<br>3<br>6<br>9</p>
<p>输出样例</p>
<p>Yes<br>No<br>No</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>按照题目要求进行二分查找，由于a[]是单增数列，所以对于每一个输入查询x，我们先设置左边界l=1，有边界r=n，ans储存可能的位置，进行二分查找，每一次二分查找时mid=(l+r)/2。如果a[mid]&gt;=x，说明如果存在x，那么x一定在左边界（包括mid），那么此时r=mid-1，ans=mid；如果a[mid]&lt;x，则说明x一定在有边界。二分查找完之后，要验证a[ans]是否等于x，因为二分只是由于它是有序序列进行二分，不断查找与x最接近的数字，但它不一定能够是x。</p>
<p>这个方法时间复杂度为O(nlogn).</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50000+50;
int n,a[maxn],m;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    cin&gt;&gt;m;
    while(m--){
        int x;
        cin&gt;&gt;x;
        int l=1,r=n,ans=0;
        while(l&lt;=r){
            int mid=(l+r)/2;
            if(a[mid]&gt;=x){
                r=mid-1;
                ans=mid;
            }
            else{
                l=mid+1;
            }
        }
        if(a[ans]==x){
            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
        }
        else{
            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
        }
    }
    return 0;
}</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603882322650.png" srcset="/img/loading.gif" alt="1603882322650"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603882299481.png" srcset="/img/loading.gif" alt="1603882299481"></p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>题目要求很明确，就是问x是否在a[]中存在，那就把a[]中出现过的数字进行标记就可以了，这里对 a[]中的每一个数字的范围解释不够清楚，所以我们可以用map进行映射处理。当然其实也可以vis[]数组进行标记，vis[]大小设置为5e5，这样让vis[a[i]]=1,然后查询vis[x]是否等于1就可以了，或者用map标记方法也一样。这种方法的时间复杂度O(n)(直接数组标记)或者O(nlogn)(map)。</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt; 
using namespace std;
const int maxn=50000+50;
map&lt;int,int&gt;mp;
int n,a[maxn],m;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],mp[a[i]]=1;
    cin&gt;&gt;m;
    while(m--){
        int x;
        cin&gt;&gt;x;
        if(mp[x]==1){
            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
        }
        else{
            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;d
        }
    }
}</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603882725484.png" srcset="/img/loading.gif" alt="1603882725484"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603882683549.png" srcset="/img/loading.gif" alt="1603882683549"></p>
<h1 id="2-求解投骰子游戏问题"><a href="#2-求解投骰子游戏问题" class="headerlink" title="2.求解投骰子游戏问题"></a>2.求解投骰子游戏问题</h1><p><strong>[问题描述]</strong>玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。求玩家走到第n步（n≤骰子最大点数且投骰子方法唯一）时总共有多少种投骰子的方法。</p>
<p>输入描述：输入包括一个整数n（1≤n≤6）。</p>
<p>输出描述：输出一个整数，表示投骰子的方法数。</p>
<p>输入样例：6</p>
<p>输出样例：32</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h4><p>看到这个题的第一个思路是用递推/动态规划。很容易看出来对于状态i（当前走到第i步）可以由状态0，1，……,i-1得到（即走i步，走i-1步，……,走1步），设dp[0]=1（即处于原始位置的方式只有一种），那么dp[i]=dp[i-1]+dp[i-2]+…+dp[0].所以n^2枚举即可，当然为了时候的优化，我们还可以进行<strong>前缀和优化</strong>（即每一次得到dp[i-1]都在pre之中，对于dp[i+1]我们就可以O(1)求得），当然这里n&lt;=6，就不必这么复杂了。所以写了一个时间复杂度为O(n^2)的代码。</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=20;
int n,dp[maxn];
int main(){
    cin&gt;&gt;n;
    dp[0]=1;
    for(int i=1;i&lt;=n;i++){
        for(int j=0;j&lt;=i-1;j++){
            dp[i]+=dp[j];
        }
    }
    cout&lt;&lt;dp[n]&lt;&lt;endl;
    return 0;
}</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603883072417.png" srcset="/img/loading.gif" alt="1603883072417"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603883059224.png" srcset="/img/loading.gif" alt="1603883059224"></p>
<h4 id="方法二：-1"><a href="#方法二：-1" class="headerlink" title="方法二："></a>方法二：</h4><p>老师出这个题应该是为了考察dfs，所以这样写一下dfs的方法：</p>
<p>对于x，与方法一的解释一样，它肯定是由0，1，…,x-1得到的，所以我们再dfs求走到第0,1,…,x-1步的方法，dfs的边界设置为 if(x==0)return 1;这样也是可以求得结果的，只是时间复杂度是指数级别。但是如果我们进行<strong>记忆化搜索</strong>，即用dp[]进行记录每一个状态的答案，一旦存在就不再dfs，这样的时间复杂度可以优化到O(n^2).</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
int dfs(int x){
    if(x==0)return 1;
    int res=0;
    for(int i=0;i&lt;=x-1;i++)res+=dfs(i);
    return res;
}
int main(){
    cin&gt;&gt;n;
    cout&lt;&lt;dfs(n)&lt;&lt;endl;
    return 0;
}</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603883468240.png" srcset="/img/loading.gif" alt="1603883468240"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603883460594.png" srcset="/img/loading.gif" alt="1603883460594"></p>
<h1 id="3-0-1背包"><a href="#3-0-1背包" class="headerlink" title="3.0-1背包"></a>3.0-1背包</h1><p>描述</p>
<p>需对容量为c 的背包进行装载。从n 个物品中选取装入背包的物品，每件物品i 的重量为wi ，价值为pi 。对于可行的背包装载，背包中物品的总重量不能超过背包的容量，最佳装载是指所装入的物品价值最高。 </p>
<p>输入</p>
<p>多个测例，每个测例的输入占三行。第一行两个整数：n（n&lt;=10）和c，第二行n个整数分别是w1到wn，第三行n个整数分别是p1到pn。n 和 c 都等于零标志输入结束。</p>
<p> 输出</p>
<p>每个测例的输出占一行，输出一个整数，即最佳装载的总价值。</p>
<p>输入样例</p>
<p>1 2<br>1<br>1<br>2 3<br>2 2<br>3 4<br>0 0</p>
<p> 输出样例</p>
<p>1<br>4</p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一：-2"><a href="#方法一：-2" class="headerlink" title="方法一："></a>方法一：</h4><p>0-1背包的裸题，那就可以直接写一个01背包的动态转移方程：dp[j]=max(dp[j],dp[j-w[i]]+p[i])。dp[j]的意思是：当背包已装j的重量的物品时的最大价值。那么它可以由背包已装j-w[i]时最大的价值进行转移，即由dp[j-w[i]]+p[i]得到。注意每一次要将dp[]设置为0，因为背包此时无价值。当状态方程枚举结束后，我们再从 dp[]数组中找一遍，求得答案maxx=max{dp[i]}(i from 0 to c)，输出答案maxx。这种动态规划的方法的时间复杂度为O(n^2).</p>
<p><strong>ps：</strong>0-1背包也可以写成二维dp[][]，只是这样写成滚动数组可以更加节省空间。</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=    2000+50;
int n,c,w[maxn],dp[maxn],p[maxn];
int main(){
    int i,j;
    while(1){
        scanf(&quot;%d%d&quot;,&amp;n,&amp;c);
        if(n==0&amp;&amp;c==0)break;
        for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i];
        for(i=1;i&lt;=n;i++)cin&gt;&gt;p[i];
        memset(dp,0,sizeof(dp));
        for(i=1;i&lt;=n;i++){
            for(j=c;j&gt;=1;j--){
                if(j-w[i]&gt;=0&amp;&amp;dp[j]&lt;dp[j-w[i]]+p[i]){
                    dp[j]=dp[j-w[i]]+p[i];
                }
            }
        }
        int maxx=0;
        for(i=0;i&lt;=c;i++)
            if(maxx&lt;dp[i])
                maxx=dp[i];
        cout&lt;&lt;maxx&lt;&lt;endl;
    }

    return 0;
}</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603884301074.png" srcset="/img/loading.gif" alt="1603884301074"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603884284377.png" srcset="/img/loading.gif" alt="1603884284377"></p>
<h4 id="方法二：-2"><a href="#方法二：-2" class="headerlink" title="方法二："></a>方法二：</h4><p>除了直接写0-1背包的动态转移方程，还可以直接写dfs，每一个背包无非就是取和不取两个状态，如果要取则要求背包容量 res&gt;=w[now]。分别用ans1，ans2表示取当前物品，不取当前物品的最大价值，dfs返回max(ans1,ans2)，dfs的终止条件是now ==n+1。时间复杂度(2^n)。</p>
<p><strong>ps:</strong>方法二相较于方法一思维上更加简单，容易想到，但是代码就相对麻烦，并且时间复杂度不够优秀，当然如果加上记忆化搜索后时间复杂度和动态规划是相当的。我个人更喜欢方法一。</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=    2000+50;
int n,c,w[maxn],p[maxn];
int dfs(int now,int res){
    if(now==n+1)return 0;
    int ans1=0,ans2=0;
    if(res&gt;=w[now]){
        ans1=dfs(now+1,res-w[now])+p[now];
    }
    ans2=dfs(now+1,res);
    if(ans1&gt;=ans2)return ans1;
    return ans2;
}
int main(){
    int i,j;
    while(1){
        scanf(&quot;%d%d&quot;,&amp;n,&amp;c);
        if(n==0&amp;&amp;c==0)break;
        for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i];
        for(i=1;i&lt;=n;i++)cin&gt;&gt;p[i];
        cout&lt;&lt;dfs(1,c)&lt;&lt;endl;
    }
    return 0;
}</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603885210798.png" srcset="/img/loading.gif" alt="1603885210798"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603885191198.png" srcset="/img/loading.gif" alt="1603885191198"></p>
<h1 id="4-求解组合问题"><a href="#4-求解组合问题" class="headerlink" title="4.求解组合问题"></a>4.求解组合问题</h1><p>编写一个实验程序,采用回溯法输出自然数1~n中任取r个数的所有组合。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>用回溯法求组合，n个数字选r个，每一个数字有两种选择，要么选，要么不选。dfs(int now)表示当前的决策数字是now，则dfs的边界条件是now==n+1。对于数字now，可以选择，也可以不选择。选择的话a[++a[0]]=now，a[0]记录当前选择的数的数量，回溯的时候记得a[0]–,再进行不选择now的dfs搜索。当now==n+1的时候表明当前已经选择完了，如果a[0]==r,则当前的选择组合刚好是满足条件的，输出即可。时间复杂度O(2^n)</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100+50;
int n,r,a[maxn];
void dfs(int now){
    if(now==n+1){
        if(a[0]==r){
            for(int i=1;i&lt;=a[0];i++)cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;
        }
        return ;
    }
    a[++a[0]]=now;
    dfs(now+1);
    a[0]--;
    dfs(now+1);
}
int main(){
    cin&gt;&gt;n&gt;&gt;r;
    dfs(1);
    return 0;
}</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603886599309.png" srcset="/img/loading.gif" alt="1603886599309"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603886613973.png" srcset="/img/loading.gif" alt="1603886613973"></p>
<h1 id="5-最小重量机"><a href="#5-最小重量机" class="headerlink" title="5.最小重量机"></a>5.最小重量机</h1><p>设某一机器由n个部件组成，每一种部件都可以从m个不同的供应商处购得。设 wij  是从供应商j处购得的部件 i 的重量， cij 是相应的价格。试设计一个算法，给出总价格不超过 c 的最小重量机器设计。</p>
<p>输入：第一行3个整数n,m,cost，接下来n行输入wij  （每行m个整数），最后n行输入cij  （每行m个整数），这里n&gt;=1, m&lt;=100.</p>
<p>输出：第一行包括n个整数，表示每个对应的供应商编号，第2行为对应的重量。</p>
<p>输入样例：</p>
<p>337</p>
<p>123</p>
<p>321</p>
<p>232</p>
<p>123</p>
<p>542</p>
<p>212</p>
<p>输出样例：</p>
<p>131</p>
<p>4</p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>这里用dfs进行搜索，每找到一个符合条件的情况，就更新bestw和x[]。bestw储存最小的重量，x[i]表示部件i所对应的供应商，nowx[i]表示dfs过程中部件i选择的供应商。w[i][j] 表示从供应商j处购得的部件i的重量 ，c[i][j]表示相应的价格。dfs(int now,int noww,int nowp)表示搜索第now个部件时的当前重量为noww，耗费nowp，对于第now个物品它有m个供应商可以选择，当nowp+c[now][i]&lt;=cost时则符合条件可以进行dfs(now+1,noww+w[now][i],nowp+c[now][i]);dfs的边界条件时now==n+1，此时如果bestw&gt;noww，则要更新bestw，以及x[]。最后输出bestw和x[].</p>
<p><strong>ps:</strong>如果PE的话，把最后的空格去掉（输出x[]的时候,x[n]后面不要跟空格），并且加上printf(“\n”).</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=200+50;
int n,m,cost,w[maxn][maxn],c[maxn][maxn],bestw=0x3f3f3f3f,nowx[maxn],x[maxn];
void dfs(int now,int noww,int nowp){
    int i,j;
    if(now==n+1){
        if(bestw&gt;noww){
            bestw=noww;
            for(i=1;i&lt;=n;i++)x[i]=nowx[i];
        }
        return ;
    }
    for(i=1;i&lt;=m;i++){
        if(nowp+c[now][i]&lt;=cost){
            nowx[now]=i;
            dfs(now+1,noww+w[now][i],nowp+c[now][i]);
        }
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;cost;
    int i,j;
    for(i=1;i&lt;=n;i++)
        for(j=1;j&lt;=m;j++)    
            cin&gt;&gt;w[i][j];
    for(i=1;i&lt;=n;i++)
        for(j=1;j&lt;=m;j++)
            cin&gt;&gt;c[i][j];
    dfs(1,0,0);
    for(i=1;i&lt;=n;i++){
        cout&lt;&lt;x[i];
        if(i!=n)cout&lt;&lt;&#39; &#39;;
    }
    cout&lt;&lt;endl;
    cout&lt;&lt;bestw&lt;&lt;endl;
    return 0;
}</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603888641972.png" srcset="/img/loading.gif" alt="1603888641972"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603888654371.png" srcset="/img/loading.gif" alt="1603888654371"></p>
<h1 id="6-最长公共子序列"><a href="#6-最长公共子序列" class="headerlink" title="6.最长公共子序列"></a>6.最长公共子序列</h1><p>描述</p>
<p>一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=&lt;x1, x2,…, xm&gt;，则另一序列Z=&lt;z1, z2,…, zk&gt;是X的子序列是指存在一个严格递增的下标序列 &lt;i1, i2,…, ik&gt;，使得对于所有j=1,2,…,k有：<br>Xij ＝ Zj<br>如果一个序列S即是A的子序列又是B的子序列，则称S是A、B的公共子序列。<br>求A、B所有公共子序列中最长的序列的长度。</p>
<p>输入</p>
<p>输入共两行，每行一个由字母和数字组成的字符串，代表序列A、B。A、B的长度不超过200个字符。</p>
<p>输出</p>
<p>一个整数，表示最长各个子序列的长度。</p>
<p>格式：printf(“%d\n”);</p>
<p>输入样例</p>
<p>programming<br>contest</p>
<p>输出样例</p>
<p>2</p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>像LCS这样的问题，它具有重叠子问题的性质，因此：用递归来求解就太不划算了。因为采用递归，它重复地求解了子问题。采用动态规划时，并不需要去一 一 计算那些重叠了的子问题 。对于<strong>dp[i][j]</strong>表示 <strong>(s1,s2….si) 和 (t1,t2…tj) 的最长公共子序列的长度</strong> 。</p>
<p>当i==0||j==0 时,dp[i][j]=0;</p>
<p>当i,j&gt;0,si==tj时,  dp[i][j]=dp[i-1][j-1]+1;</p>
<p>当i,j&gt;0,si!=tj时，dp[i][j]=max{dp[i][j-1],dp[i-1][j]};</p>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a><strong>时间复杂度：</strong></h3><p>由于只需要填一个m行n列的二维数组，其中m代表第一个字符串长度，n代表第二个字符串长度</p>
<p>所以时间复杂度为O（m*n）</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+50;
char s[maxn],t[maxn];int lens,lent,dp[maxn][maxn];
int max(int x,int y){
    if(x&gt;y)return x;
    return y;
}
int main(){
    scanf(&quot;%s%s&quot;,s+1,t+1);
    lens=strlen(s+1);
    lent=strlen(t+1);
    for(int i=1;i&lt;=lens;i++){
        for(int j=1;j&lt;=lent;j++){
            if(s[i]==t[j]){
                dp[i][j]=dp[i-1][j-1]+1;
            }
            else{
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    printf(&quot;%d\n&quot;,dp[lens][lent]);
    return 0;
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603899713319.png" srcset="/img/loading.gif" alt="1603899713319"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603899700760.png" srcset="/img/loading.gif" alt="1603899700760"></p>
<h1 id="7-活动安排问题"><a href="#7-活动安排问题" class="headerlink" title="7.活动安排问题"></a>7.活动安排问题</h1><p>问题：有n个活动的集合A={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。<br>求解：安排尽量多项活动在该场地进行，即求A的最大相容子集。<br>设待安排的11个活动的开始时间和结束时间按结束时间的升序排列如下：</p>
<p>将此表数据作为实现该算法的测试数据。</p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603896772164.png" srcset="/img/loading.gif" alt="1603896772164"></p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一：-3"><a href="#方法一：-3" class="headerlink" title="方法一："></a>方法一：</h4><p>题意很明显希望参加的活动数目尽量多。对于活动安排问题可以采取动态规划的策略：</p>
<p>首先将活动的结束时间按照第一关键字排序（由小到大），再将活动的开始时间作为第二关键字排序（由小到大）</p>
<p>定义<strong>dp[i]</strong>表示在前i场比赛中最多可以参加几场比赛，</p>
<p>由此得出方程：dp[i]=max(dp[i-1],dp[temp]+1);</p>
<p>temp指从dp[i-1]向前找到的第一个允许参加第i场活动的活动编号，由它推导出dp[i]=dp[temp]+1;</p>
<p>由于每次循环时都向前找一次temp会浪费太多时间，又因为活动开始或结束时间是单调递增的，</p>
<p>故可以令temp在循环时逐步递增，这样时间复杂度就降到了O(n).</p>
<p>这里只是讲解一下动态规划的想法。就不写代码了，动态规划的代码和下面的贪心方法相似。只是这种动态规划的思路是基于贪心的思想来实现的。</p>
<h4 id="方法二：-3"><a href="#方法二：-3" class="headerlink" title="方法二："></a>方法二：</h4><p>这个问题可以抽象为在一个数轴上有n条线段，现要选取其中k条线段使得这k条线段两两没有重合部分，问最大的k为多少。<br>最左边的线段放什么最好？<br>显然放右端点最靠左的线段最好，从左向右放，右端点越小妨碍越少。<br>其他线段放置按右端点排序，贪心放置线段，即能放就放。</p>
<p>以上两种方法的时间复杂度都是O(nlogn)，快速排序的时间复杂度是O(nlogn),而动态规划或者贪心执行更新策略的时间复杂度是O(n).</p>
<p><strong>代码：</strong></p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=2e3+50;
int n;
struct Node{
    int s,f;
}a[maxn];
bool cmp(Node x,Node y){
    if(x.f==y.f)return x.s&lt;y.s;
    return x.f&lt;y.f;
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].s&gt;&gt;a[i].f;
    sort(a+1,a+1+n,cmp);
    int ans=1,now=1,opt=2;
    while(opt&lt;=n){
        if(a[opt].s&gt;=a[now].f){
            ans++;
            now=opt;
        }
        opt++;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603897881797.png" srcset="/img/loading.gif" alt="1603897881797"></p>
<p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1603896695091.png" srcset="/img/loading.gif" alt="1603896695091"></p>

        <div id="aplayer-vHLHqgbq" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-vHLHqgbq"),
            narrow: false,
            autoplay: true,
            showlrc: false,
            music: {
              title: "那年",
              author: "枯木逢春",
              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",
              pic: "",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>


            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/NOJ">NOJ</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  
    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?MC7rf8QP3x";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "NOJ-算法设计理论作业&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  







</body>
</html>
