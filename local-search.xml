<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CodeForces-1326</title>
    <link href="/2020/03/21/CodeForces-1326/"/>
    <url>/2020/03/21/CodeForces-1326/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A 题目名称："></a>A 题目名称：</h1><p>A Bad Ugly Numbers</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 构造一个 n位十进制数，保证不被该数的任意一位整除。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>由于只需要求一组即可，那么就猜测一下一个数字一定要么是奇数要么是偶数，若为奇数则个位不为偶数，若为偶数则个位为偶数。这么不妨用2来替换。假如剩余全为3，那么3*x+2一定无法被3整除。所以就全用2，3表示。偶数不能被2整除。那么开头数字为2，其余全为3就可以了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int T,n;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        if(n==1)        {            printf(&quot;-1\n&quot;);        }        else         {            printf(&quot;2&quot;);            for(int i=1;i&lt;=n-1;i++)            printf(&quot;3&quot;);            cout&lt;&lt;endl;        }    }    return 0;} </code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B 题目名称："></a>B 题目名称：</h1><p>Maximums </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>对于一个序列 {an}，定义序列 {cn} ：ci=max{0,a1,⋯,ai−1} 。同时定义序列 {bn} :bi=ai−ci 。</p><p>给定 {bn}，求 {an} 。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>由题意可知：ci=max{0,a1,…,ai-1},bi=ai-ci.所以ai=bi+ci;那么维护max{0,a1,…ai-1}即可。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000 +5;long long n,b[maxn],a[maxn];int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;b[i]);    long long maxx=b[1];    a[1]=b[1];    for(long long i=2;i&lt;=n;i++)    {        a[i]=maxx+b[i];        maxx=max(maxx,a[i]);    }    for(long long i=1;i&lt;=n;i++)    printf(&quot;%lld &quot;,a[i]);    cout&lt;&lt;endl;    return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C 题目名称："></a>C 题目名称：</h1><p>Permutation Partitions</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定一个长度为 n的排列{an}。要求将这个序列分成互不相交的 k段。记第 p段的左端点和右端点分别为 lp,rp 。要求最大化 <img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584777570005.png" srcset="/img/loading.gif" alt="1584777570005"><br>输出<strong>最大化的值</strong>和<strong>可以最大化该值的方案数</strong>。方案数对 998,244,353取模。 </p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>将长度为n的排列分成互不相交的k段，并且取每段的最大值，问它们的和。这一问就直接找到前k大的数字，并求和就可以了。然后求有多少种方案数。这一问需要看一下规律，将前k大的数字进行标记，然后依次统计相邻标记的数字中间有几个未标记的位置，如果为0，这区域的方案数为，如果为1，这区域的方案数位2，如果为2，这区域的方案数为3，如果为k，这区域的方案数为k+1。最后全部一边成一边取模。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000 +5;const int Mod=998244353;int n,m,a[maxn],d[maxn],vis[maxn],tot,f[maxn];long long ans=1,sig=0;int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    f[0]=1;    for(int i=1;i&lt;=n;i++)    {        f[i]=i+1;    }    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);        if(a[i]&gt;=n-m+1&amp;&amp;a[i]&lt;=n)        {            sig+=a[i];            vis[i]=1;        }    }    int maxx=0;    for(int i=1;i&lt;=n;i++)    {        if(maxx==0&amp;&amp;vis[i]==1)        {            maxx=i;        }        else if(vis[i]==1)        {            d[++tot]=i-maxx-1;            maxx=i;        }    }    ans=f[d[1]];    for(int i=2;i&lt;=tot;i++)    {        ans=(ans*f[d[i]])%Mod;    }    printf(&quot;%lld %lld\n&quot;,sig,ans);    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D 题目名称："></a>D 题目名称：</h1><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定一个字符串。要求选取他的一个前缀(可以为空)和与该前缀不相交的一个后缀(可以为空)拼接成回文串，且该回文串长度最大。求该最大长度。 </p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><h5 id="Easy版本："><a href="#Easy版本：" class="headerlink" title="Easy版本："></a>Easy版本：</h5><p>这个数据范围更小，T&lt;=1000,n&lt;=5000；可以暴力。首先从两边往中间收，一一匹配，直到左右不等，记录opt1，opt2。然后看以opt1为起点最长的回文串，然后以opt2为起点最长的回文串，这里可以用暴力办法，比如以opt1为起点时，枚举终点，从opt2开始，一旦中间不符合了，就终点位置往前靠一位；同理以opt2为起点时，枚举终点，从opt1开始，一旦中间不符合了，终点位置就往后靠一位。最后选择一个最长的与开始的合并输出。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=50000+5;int n,l;char s[maxn],t[maxn];int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        memset(t,0,sizeof(t));l=0;        scanf(&quot;%s&quot;,s+1);        int opt1=1,opt2=strlen(s+1);        while(opt1&lt;=opt2)        {            if(s[opt1]==s[opt2])            {                t[++l]=s[opt1];                opt1++;                opt2--;            }            else             break;        }        if(l==(strlen(s+1)+1)/2)        {            int len=strlen(s+1);            for(int i=1;i&lt;=strlen(s+1);i++)            cout&lt;&lt;s[i];            cout&lt;&lt;endl;            continue;        }        int s1=opt1,s2=opt2,tot1=0,sign1=0,T1=0,c=1;        while(s1&lt;=s2)        {            if(s1==s2)sign1=1;            if(s[s1]==s[s2])            {                s1++;s2--;                tot1++;                T1+=2;            }            else             {                tot1=0;                s1=opt1;s2=opt2-c;//WA                c++;                T1=0;            }        }        if(sign1==1)T1--;        s1=opt1;s2=opt2;int tot2=0,sign2=0,T2=0;c=1;        while(s1&lt;=s2)        {            if(s1==s2)sign2=1;            if(s[s1]==s[s2])            {                s1++;s2--;                tot2++;                T2+=2;            }            else             {                s1=opt1+c;s2=opt2;c++;                tot2=0;                T2=0;            }        }        if(sign2==1)T2--;        if(T1&gt;T2)        {            for(int i=opt1;i&lt;=opt1+tot1-1;i++)            {                t[++l]=s[i];            }            if(sign1==1)            {                int len=l;                for(int i=len-1;i&gt;=1;i--)t[++l]=t[i];            }            else             {                int len=l;                for(int i=len;i&gt;=1;i--)t[++l]=t[i];            }        }        else         {            for(int i=opt2;i&gt;=opt2-tot2+1;i--)            t[++l]=s[i];            if(sign2==1)            {                int len=l;                for(int i=len-1;i&gt;=1;i--)t[++l]=t[i];            }            else             {                int len=l;                for(int i=len;i&gt;=1;i--)t[++l]=t[i];            }        }        cout&lt;&lt;t+1&lt;&lt;endl;    }    return 0;}</code></pre><h5 id="hard版本："><a href="#hard版本：" class="headerlink" title="hard版本："></a>hard版本：</h5><p>这里数据范围很大，T&lt;=100000,n&lt;=1000000.显然每次查询必须在O(n)内完成，所以必须用到Manacher的算法了。首先还是先从两端开始匹配出相同的总数，直到两端不等为止，记录opt1，opt2。然后以opt1为起点求最长的回文串，再以opt2为起点求最长的回文串。这里要注意Manacher求得的最长回文串可能不一定以opt1为起点。所以更新长度时候要注意让<strong>i-(p[i]-1)==1</strong>然后再更新长度。当以opt2为起点时候，将字符串s，从opt1到opt2之间翻转一下reverse(s+opt1,s+1+opt2)即可。然后选择最长的回文串与开始的合并输出。</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=3000000+5;int T,p[maxn],l;char s[maxn]; int Manacher(int S,int T){    int len=1;    string ss=&quot;$#&quot;;    for(int i=S;i&lt;=T;i++)    {        ss+=s[i];ss+=&#39;#&#39;;        len+=2;    }    int mx=0,id=0,ans=0;p[0]=p[1]=0;    for(int i=1;i&lt;=len;i++)    {        if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);        else p[i]=1;        while(ss[i+p[i]]==ss[i-p[i]])p[i]++;        if(i+p[i]&gt;mx)        {            mx=i+p[i];            id=i;        }        ans=max(ans,p[i]-1);        if(i-p[i]+1==1)        {            if(l&lt;p[i]-1)            {                l=p[i]-1;            }        }    }    return l;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%s&quot;,s+1);        int len=strlen(s+1);        int opt1=1,opt2=len;        l=0;        while(opt1&lt;=opt2)        {            if(s[opt1]==s[opt2])            {                opt1++;opt2--;            }            else break;        }        if(opt1&gt;opt2)        {            printf(&quot;%s\n&quot;,s+1);            continue;        }        int ans1=Manacher(opt1,opt2);        reverse(s+opt1,s+1+opt2);        l=0;        int ans2=Manacher(opt1,opt2);//        cout&lt;&lt;opt1&lt;&lt;&#39; &#39;&lt;&lt;opt2&lt;&lt;&#39; &#39;&lt;&lt;ans1&lt;&lt;&#39; &#39;&lt;&lt;ans2&lt;&lt;endl;        if(ans1&gt;ans2)        {            reverse(s+opt1,s+1+opt2);            for(int i=1;i&lt;=opt1-1;i++)cout&lt;&lt;s[i];            for(int i=opt1;i&lt;=opt1+ans1-1;i++)cout&lt;&lt;s[i];            for(int i=opt1-1;i&gt;=1;i--)cout&lt;&lt;s[i];            cout&lt;&lt;endl;        }        else         {            reverse(s+opt1,s+1+opt2);            for(int i=1;i&lt;=opt1-1;i++)cout&lt;&lt;s[i];            for(int i=opt2-ans2+1;i&lt;=len;i++)cout&lt;&lt;s[i];            cout&lt;&lt;endl;        }    }    return 0;}</code></pre><p><strong>ps</strong>：说明一下<strong>reverse</strong>函数的用法：reverse(s+opt1,s+opt2),s为进行翻转的字符串，opt1为s[opt1]中的opt1，从s[0]开始。如果读入为s+1，也依然是从s[0]开始。opt2为s[0]开始的第opt2个。如果读入为s+1，也依然是s[0]开始的第opt2个。</p>        <div id="aplayer-spbeJXUh" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-spbeJXUh"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>p]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1325</title>
    <link href="/2020/03/18/CodeForces-1325/"/>
    <url>/2020/03/18/CodeForces-1325/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A 题目名称："></a>A 题目名称：</h1><p>EhAb AnD gCd</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你一个数x，输出一组 (a,b)使得 a和 b的最大公约数和最小公倍数的和为 x，若有多种答案，输出任意一种即可。<br>第一行输入一个 t，有 t组数据，之后每组数据输入一个数 x。<br>对于每组数据，输出两个用一个空格隔开的数 a,b。若有多种答案，输出任意一种即可。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>1是任意一个数的公约数，任意数是它和1的倍数，那么x=1+y。1，y就是答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;int n;int T;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        if(n==2)        {            printf(&quot;1 1\n&quot;);        }        else         {            printf(&quot;1 %d\n&quot;,n-1);        }    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B 题目名称："></a>B 题目名称：</h1><p>CopyCopyCopyCopyCopy</p><h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p> 共有 <code>t</code> 组数据，每组数据给你一个长为 <code>n</code>(1≤<em>n</em>≤105) 的序列(1≤ai≤109)，将它复制 <code>n</code>遍，请在这个复制后的序列里找一个最长上升子序列，输出它的长度。 </p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>由于可以重复n遍，可以依次按序取每组中最小的那个，依次增大，那么一旦有重复的，数量就要-1，所以只需要求数组中有多少数字重复即可。去重求总数即可。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;int T,a[maxn],n,vis[maxn],b[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            b[i]=a[i];        }        sort(b+1,b+1+n);        int tot=unique(b+1,b+1+n)-b-1;        printf(&quot;%d\n&quot;,tot);    }    return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C 题目名称："></a>C 题目名称：</h1><p>Ehab and Path-etic MEXs</p><h4 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个 n个节点 n-1 条边的树<br>要求给边重新标注边权<br>分别为 0,1,2…n-2<br>然后使得树上任意两点u v的MEX(<em>u</em>,<em>v</em>) 的最大值最小。<br>MEX(<em>u</em>,<em>v</em>) 是 u到 v的简单路径没有出现的<strong>自然数</strong>中最小的数。</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>这道题具体到单点上进行分析，如果这是一条链，每一个点最多连两条边。如图：<br><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584544666135.png" srcset="/img/loading.gif" alt="1584544666135"></p><p>这样来看，1-n之间没有出现的最小数只能是n-1,所以边权怎么定义都无法影响MEX了。所以这种情况随便赋值即可。</p><p>如果一个点连接了三个点。如图：</p><p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584544831772.png" srcset="/img/loading.gif" alt="1584544831772"><br>三条边(分别是0，1，2)0恰好将图分成两个部分，u，v要么处于一个部分，要么处于两个不同部分。如处于相同部分就是0（但如果u、v之前存在0边权的边，则最小值是1）.如果处于两个不同部分，就是除了相邻的两条边之外的最小的值。这样MEX的最大值就是2，明显是最优的。</p><p>如果一个点连接超过三个点，方法如上图，实际上只需要定义三边就够了。<br><strong>ps</strong>:若总点数小于等于3，就特判一下。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;int n,ind[maxn],k=1,head[maxn],ans[maxn];struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int main(){    scanf(&quot;%d&quot;,&amp;n);    if(n==2)    {        printf(&quot;0\n&quot;);        return 0;    }    if(n==3)    {        printf(&quot;0\n1\n&quot;);        return 0;    }    int now=1;    for(int i=1;i&lt;=n-1;i++)    {        int u,v;        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        add(u,v);add(v,u);        ind[u]++;ind[v]++;         if(ind[u]==3)        {            for(int i=head[u];i;i=edge[i].next)            {                ans[i/2]=now;                now++;            }        }        else if(ind[v]==3)        {            for(int i=head[v];i;i=edge[i].next)            {                ans[i/2]=now;                now++;            }        }        if(ind[u]==3|ind[v]==3)        {            for(int i=1;i&lt;=n-1;i++)            {                if(!ans[i])                {                    ans[i]=now;                    now++;                }                else continue;            }                break;        }    }    if(now==1)    {        for(int i=1;i&lt;=n-1;i++)        {            ans[i]=now;            now++;        }    }    for(int i=1;i&lt;=n-1;i++)    printf(&quot;%d\n&quot;,ans[i]-1);    return 0;} </code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D 题目名称："></a>D 题目名称：</h1><p>Ehab the Xorcist</p><h4 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h4><p>给两个整数 u，v，求出长度最短的数组，使得数组内元素的按位异或为 u，元素之和为 v。输入一行，两个数 u，v(u,v≤10^18)。<br>如果有解，输出两行，第一行输出一个数n，第二行输出n个数，表示数组里的元素。如果有多个答案，输出任意一组。<br>如果无解，输出仅一行，输出”-1”。</p><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>先讨论一下特殊情况：<br>如果u和v都等于0，显然答案是0<br>如果u==v，只需要u自己就可以了。<br>如果u&gt;v,异或的值都大于总和了，显然不可能。<br>其余情况：<br>已知y^y==0,那么不妨让x+y+y=v。如果(v-x)%2==1，说明u,v不是同为奇数或者同为偶数，这种情况无法得到答案，直接输出-1.如果(v-x)%2==0,则y=(v-x)/2,那么x^y^y==x，那么答案就是三个数字：x y y。但是这种情况可能不是最好的。有些情况其实两个数字就够了。不妨设v=(x+y)+y.要满足(x+y)^y==u,由于x^y^y==u,所以<br>(x+y)^y==x^y^y,即x+y==x^y;两个数异或等于这两个数相加，显然x&amp;y==0.即当x&amp;y==0时，答案就是两个数字 x+y  y。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long n,m;int main(){    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    if(n==0&amp;&amp;m==0)    {        printf(&quot;0\n&quot;);        return 0;    }    if(n==m)    {        printf(&quot;1\n%lld\n&quot;,n);        return 0;    }    if(n&gt;m)    {        printf(&quot;-1\n&quot;);        return 0;    }    long long yu=m-n;    if(yu%2==0)    {        long long x=n,y=yu/2;        if((x&amp;y)==0)        {            printf(&quot;2\n%lld %lld\n&quot;,x+y,y);        }        else         {            printf(&quot;3\n%lld %lld %lld\n&quot;,x,y,y);        }    }    else     {        printf(&quot;-1\n&quot;);        return 0;    }}</code></pre>         <div id="aplayer-EPHBLpty" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EPHBLpty"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1324</title>
    <link href="/2020/03/13/CodeForces-1324/"/>
    <url>/2020/03/13/CodeForces-1324/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次参加Div3，结果就翻车了，本来前三题都很顺利，半个小时AC之后，进入T4，结果T4WA了4发，当场崩溃，结果就是minn，maxx的位置有歧义。导致T6只剩下10min，即使有思路也没办法调试出来。第二天花了15minAC了，WA了一发。果然还是细节很不到位。</p><h1 id="A：题目名称："><a href="#A：题目名称：" class="headerlink" title="A：题目名称："></a>A：题目名称：</h1><p>Yet Another Tetris Problem</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>第一行一个t，表示有t组数据。每组数据的第一行是一个数n，接下来一行是一个长度为n的数组a。 分别表示每一列的方块的高度。<br>现在有两个操作：<br>1.当至少一个ai&gt;0时，选择一些i(1&lt;=i&lt;=n)，将ai加2.<br>2.当所有的ai&gt;0时，将所有的ai减1。<br>问最后可不可以将所有的ai都变成0. 如果能，输出”YES”(没有引号)，不然输出”NO”(没有引号) </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>问题转化过来就是，可以在任意一列上+2，问最后可不可以等高。那就看highmax与其余各列的高度差是否都为偶数即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+5;int T,n,a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        int maxx=0;        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            maxx=max(maxx,a[i]);        }        int sign=0;        for(int i=1;i&lt;=n;i++)        {            int t=maxx-a[i];            if(t%2==1)            {                sign=1;                break;            }        }        if(sign==0)printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B: 题目名称："></a>B: 题目名称：</h1><p>Yet Another Palindrome Problem</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个长度为 n 的序列 a，问其中是否有长度至少为 3 的子序列 b 为「回文序列」，如果有，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p><p>注意：本题有多组数据，对每一组数据，都要给出相应答案。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>只要满足回文串的长度为3即可。那就找到任意相等的两个数字，看他们之间间隔是否大于1。对于每一个类型的数字，记录一下最先出现的位置，用vis[]表示。然后倒着枚举每一个数字，看它的位置与同样大小数字最先出现的位置相差是否大于1，一旦符合就YES；如果找不到就NO。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5000+5;int T,n,a[maxn],vis[maxn],b[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        memset(vis,0,sizeof(vis));        memset(b,0,sizeof(b));        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            if(vis[a[i]])                b[i]=vis[a[i]];            else vis[a[i]]=i;        }        int sign=0;        for(int i=n;i&gt;=1;i--)        {            if(i-b[i]&gt;=2&amp;&amp;b[i]!=0)            {                printf(&quot;YES\n&quot;);                sign=1;                break;            }        }        if(sign==0)printf(&quot;NO\n&quot;);    }        return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C: 题目名称："></a>C: 题目名称：</h1><p>Frog Jumps</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据。每组数据是一串由L与R组成的字符串。青蛙从0出发，到n+1停止。n就是字符串长度(n不会给出)。若青蛙停在ai上，ai==‘L’就只能向左跳，ai==’R’就只能向右跳。求出最小的d，使得每一次青蛙跳的距离不超过d并且可以到达n+1.</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>假如ai==‘L’，意味着青蛙要向左跳。由于最终要跳到n+1，就必须尽量落在ai==’R’上，假设ai–&gt;aj,ai==’R‘，aj==’L’，如果j-i==d，如果中间没有R了，那显然不能满足它跳到n+1去，若有R那肯定跳到最后一个ak==’R’ 上。如果j-i&lt;d,就看后面是否有ak==’R’(注意范围),或者i–j之间是否有ak==’R’.总之这样推断后，发现每一次都要落在ai==’R’上才能到达n+1处。现在就是如何求d了，对d进行二分即可。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+10;int T,len;char s[maxn];bool check(int mid){    int opt=0,now=0,sign=0;    while(opt&lt;=len+1)    {        if(s[opt]==&#39;R&#39;&amp;&amp;opt-now&lt;=mid)        {            now=opt;        }        else if(opt-now&gt;mid)        {            sign=1;break;        }        opt++;    }    if(sign==1)return 0;    else return 1;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%s&quot;,s+1);        len=strlen(s+1);        s[len+1]=&#39;R&#39;;        int l=0,r=200000+5,ans=0;        while(l&lt;=r)        {            int mid=(l+r)/2;            if(check(mid))            {                ans=mid;                r=mid-1;            }            else             {                l=mid+1;            }        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D: 题目名称："></a>D: 题目名称：</h1><p>Pair of Topics</p><h4 id="Ps：本场比赛WA了4次，把自己坑得人都没了QAQ"><a href="#Ps：本场比赛WA了4次，把自己坑得人都没了QAQ" class="headerlink" title="Ps：本场比赛WA了4次，把自己坑得人都没了QAQ"></a>Ps：本场比赛WA了4次，把自己坑得人都没了QAQ</h4><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定n组ai，bi。求有多少组满足ai+aj&gt;bi+bj(i&lt;j)</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>移项之后就是求 (ai-bi)+(aj-bj)&gt;0有多少组。设ci=ai-bi.就是求ci+cj&gt;0有多少组。将c数组从小到大排好。minn为最靠后的小于或等于0的数，maxx为最靠前的大于或等于0的数。这里特别要注意：如果存在0，那么minn=maxx=i(a[i]==0)，如果存在多个0，那么minn=maxx=i(<strong>i是最后一个0所在位置</strong>)，那么大于0的个数就是n-maxx+1.注意：如果maxx==n，可能a[maxx]=0或者a[maxx]&gt;0；也可能minn=maxx=1，意味着可能a[minn]=a[maxx]=0,也可能是全为负数。这里的特殊情况较多，很容易WA。(主要还是设计算法时候没有注意到），然后将minn倒着向前推，如果c[minn]+c[maxx]&gt;0,ans+=n-maxx+1(意味着maxx后面的也都满足)，如果c[minn]+c[maxx]&lt;=0，就maxx++，直到c[minn]+c[maxx]&gt;0(注意maxx不可以超过n),所以还要判断是否c[minn]+c[maxx]&gt;0。<br>ps：minn=maxx=1时候，也可能全正，直接输出答案即可。ans=(n-1)*n/2;</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=200000+10;long long n,a[maxn],b[maxn],c[maxn];long long cmp(long long x,long long y){    return x&lt;y;}int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;b[i]);    for(long long i=1;i&lt;=n;i++)c[i]=a[i]-b[i];    sort(c+1,c+1+n,cmp);    long long minn=1,maxx=1;    for(long long i=1;i&lt;=n;i++)    {        if(c[i]==0)        {            minn=maxx=i;        }        if(c[i]&gt;0&amp;&amp;c[i-1]&lt;0)        {            minn=i-1;            maxx=i;        }        if(c[i]&gt;0&amp;&amp;c[i-1]&gt;0)break;    }    long long ans=0;    if(minn==maxx)    {        while(c[maxx]&lt;=0&amp;&amp;maxx&lt;=n-1)maxx++;    }    ans=(n-maxx+1)*(n-maxx)/2;    if(maxx==1)    {        printf(&quot;%lld\n&quot;,ans);        return 0;    }    for(long long i=minn;i&gt;=1;i--)    {        if(c[i]+c[maxx]&gt;0)        {            ans+=n-maxx+1;        }        else         {            while(c[i]+c[maxx]&lt;=0&amp;&amp;maxx&lt;=n-1)maxx++;            if(c[i]+c[maxx]&gt;0)ans+=n-maxx+1;        }    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><h1 id="E-题目名称："><a href="#E-题目名称：" class="headerlink" title="E: 题目名称："></a>E: 题目名称：</h1><p>Sleeping Schedule</p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p> Vova  可以选择在ai小时或者ai-1小时后睡觉，每次睡h个小时，如果开始睡觉那一刻位于l和r之间就是符合要求的。问一共有多少个符合要求。</p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>每一次睡觉时有两个选择：ai个小时后睡或者ai-1个小时后睡觉，但是由于之前i-1次也会出现这样的选择。如果单纯直接递推，就无法判断枚举的上次睡觉时间是否可以到达。所以vis[i][j]记录第i次在j时刻睡觉。dp[i][j]表示第i次在j时刻睡觉所累积的符合要求的数量。显然dp[1][a[i]]=1,dp[1][a[i]-1]=1.vis[1][a[1]]=1,vis[1][a[1]-1]=1,然后开始枚举ai，和ai-1次睡觉的时刻。必须满足vis[i-1][j]=1，即上一次睡觉可以在j时刻睡觉才可以继续。那么第i次睡觉可以在(j+a[i])%h或者(j+a[i]-1)%h开始。对vis数组进行记录。然后更新dp数组(看睡觉时刻是否处于l和r之间).然后再dp[n][j]中求maxx(0&lt;=j&lt;=h-1).<br><strong>ps</strong>:l&lt;=a[1]&lt;=r时候，dp[1][a[1]]=1;l&lt;=a[1]-1&lt;=r时候，dp[1][a[i]-1]=1,而vis数组直接标记即可。</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=3000+5;int n,h,l,r,dp[maxn][maxn],a[maxn],vis[maxn][maxn];int main(){    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;h,&amp;l,&amp;r);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    if(a[1]&gt;=l&amp;&amp;a[1]&lt;=r)    {        dp[1][a[1]]=1;    }    vis[1][a[1]]=1;    if(a[1]-1&gt;=l&amp;&amp;a[1]-1&lt;=r)    {        dp[1][a[1]-1]=1;    }    vis[1][a[1]-1]=1;    for(int i=2;i&lt;=n;i++)    {        for(int j=0;j&lt;=h-1;j++)        {            if(!vis[i-1][j])continue;            int x=(j+a[i])%h;            vis[i][x]=1;            if(x&gt;=l&amp;&amp;x&lt;=r)dp[i][x]=max(dp[i][x],dp[i-1][j]+1);            else dp[i][x]=max(dp[i][x],dp[i-1][j]);            x=(j+a[i]-1)%h;            vis[i][x]=1;            if(x&gt;=l&amp;&amp;x&lt;=r)dp[i][x]=max(dp[i][x],dp[i-1][j]+1);            else dp[i][x]=max(dp[i][x],dp[i-1][j]);        }    }    int ans=0;    for(int j=0;j&lt;=h-1;j++)    ans=max(ans,dp[n][j]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><h1 id="F-题目名称："><a href="#F-题目名称：" class="headerlink" title="F: 题目名称："></a>F: 题目名称：</h1><p>Sleeping Schedule</p><h4 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一棵 n 个节点无根树，每个节点 u有一个颜色au，若 au 为 0 则 u 是黑点，若 au为 1 则 u是白点。<br>对于每个节点 u，选出一个包含 u的连通子图，设子图中白点个数为 cnt1，黑点个数为 cnt2，请最大化 cnt1 - cnt2。并输出这个值。 </p><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><p>默认1为根，从头到底进行一边dfs，每次进入dfs，先更新w1，w2数组，若为白色则w1[i]=1否则w2[i]=1,则sum[i]=w1[i]-w2<a href="sum数组表示cnt1-cnt2">i</a>.然后从底部进行回溯：若edge[i].to(即子树的头节点)它的sum[edge[i].to]&gt;0,那么sum[u]+=sum[edge[i].to].这样只是更新了头节点。而子树与其头节点的关系并没有更新。假如一个子树，它的父节点所在子树的sum[u]&gt;0,而该节点所在子树的sum[edge[i].to]&gt;0,那么显然父亲节点的子树一定包含了该子节点所在的子树，那么sum[edge[i].to]=sum[u].如果sum[edge[i].to]&lt;0，就说明该节点为黑色。sum[edge[i].to]=sum[edge[i].to]+sum[u];然后继续dfs。</p><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int n,v[maxn],k=1,w1[maxn],w2[maxn],sum[maxn],son[maxn],head[maxn];struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}void dfs(int u,int f){    if(v[u]==0)w2[u]=1;    if(v[u]==1)w1[u]=1;    sum[u]=w1[u]-w2[u];    for(int i=head[u];i;i=edge[i].next)    {        if(edge[i].to==f)continue;        dfs(edge[i].to,u);        if(sum[edge[i].to]&gt;0)        sum[u]+=sum[edge[i].to];    }}void dfs2(int u,int f){    for(int i=head[u];i;i=edge[i].next)    {        if(edge[i].to==f)continue;        if(sum[edge[i].to]&gt;=0&amp;&amp;sum[edge[i].to]&lt;sum[u])        sum[edge[i].to]=sum[u];        else if(sum[edge[i].to]&lt;0&amp;&amp;sum[u]&gt;=0)        sum[edge[i].to]+=sum[u];        dfs2(edge[i].to,u);    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;v[i]);    for(int i=1;i&lt;n;i++)    {        int u,v;        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        add(u,v);add(v,u);    }    dfs(1,1);    dfs2(1,1);    for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,sum[i]);cout&lt;&lt;endl;    return 0;}</code></pre>         <div id="aplayer-ufEoGpLl" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ufEoGpLl"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1321</title>
    <link href="/2020/03/07/CodeForces-1321/"/>
    <url>/2020/03/07/CodeForces-1321/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A:题目名称："></a>A:题目名称：</h1><p>Contest for Robots</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出长度为1≤<em>n</em>≤100 的两个序列 r,b，且满足 ri, bi∈{0,1}，你需要确定 pi（pi≥1）。</p><p>满足<br>$$<br>\sum_{i=1}^n r_ip_i &gt; \sum_{i=1}^n b_ip_i<br>$$<br>，并且最小化max pi（1&lt;=i&lt;=n）</p><p>如果不可能，输出 -1 。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>因为序列的数字要么为1，要么为0，那么如果r中没有数字比b中的大，那么显然不可能实现题目的要求。一旦求得r比b大的个数w1，和r比b小的个数w2，就可以求maxpi，但是注意要求是大于，所以ans=(w2+1)/w1;并且要判断是否整除，如果没有则ans++。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+5;int a[maxn],b[maxn],n;int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;b[i]);    int w1=0,w2=0;    for(int i=1;i&lt;=n;i++)    {        if(a[i]&gt;b[i])w1++;        if(a[i]&lt;b[i])w2++;    }    if(w1==0&amp;&amp;w2==0)printf(&quot;-1\n&quot;);    else if(w1==0&amp;&amp;w2&gt;0)printf(&quot;-1\n&quot;);    else    {        int s=(w2+1)/w1;        if(s*w1!=w2+1)s++;        printf(&quot;%d&quot;,s);    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p>Journey Planning</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出一个长度为 n的序列 b。</p><p>设 b的一个子序列 c 的长度为 m，它的第 i个元素在原序列的下标为ci，要求对于任意 1≤<em>i</em>&lt;<em>m</em>，ci+1−ci=bci+1−bci。</p><p>此时这个子序列的贡献为<br>$$<br>\sum_{i=1}^m{b_{c_i}}<br>​<br>$$<br>求出所有合法的子序列的贡献中最大的贡献。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>有题目大意可知，要求一个子序列，假设该数字在原数组第i位，则要满足bi-bj=i-j;即<br>bi-i=bj-j;所以只需要sort排序的条件设为x.v-x.id&lt;y.v-x.id；然后线性求和并取max，注意最后的小细节。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=200000+5;long long n;struct node{    long long v,id;}a[maxn];long long cmp(node x,node y){    return x.v-x.id&lt;y.v-y.id;}int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i].v);        a[i].id=i;    }    sort(a+1,a+1+n,cmp);    long long maxx=a[1].v,ans=a[1].v;    for(int i=2;i&lt;=n;i++)    {        if(a[i].v-a[i].id==a[i-1].v-a[i-1].id)        {            ans+=a[i].v;            maxx=max(maxx,ans);        }        else         {            maxx=max(maxx,ans);            ans=a[i].v;        }    }    maxx=max(maxx,ans);    printf(&quot;%lld\n&quot;,maxx);    return 0;} </code></pre>         <div id="aplayer-WlLdynQj" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-WlLdynQj"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1311</title>
    <link href="/2020/02/29/CodeForces-1311/"/>
    <url>/2020/02/29/CodeForces-1311/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A：题目名称："><a href="#A：题目名称：" class="headerlink" title="A：题目名称："></a>A：题目名称：</h1><p> Add Odd or Subtract Even</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><ul><li>给定两个正整数a,b。</li><li>每次操作你可以把 a加上某个正奇数，或者减去某个正偶数。</li><li>问至少多少次操作可以把 a变成 b。</li><li>多组数据 :T&lt;=10^4,1&lt;=a,b&lt;=10^9</li></ul><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>对于a，b关系可分为3种情况：a&gt;b;a==b;a&lt;b;<br>a==b:答案为0；<br>a &gt; b:若a-b为偶数，答案为1；否则为2，先减一个偶数让a=b-1，再加1。<br>a &lt; b:若b-a为奇数，答案为1；否则为2.</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T,a,b;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        if(b&gt;a)        {            if((b-a)%2==1)printf(&quot;1\n&quot;);            else printf(&quot;2\n&quot;);        }        else if(b==a)        {            printf(&quot;0\n&quot;);        }        else if(b&lt;a)        {            if((a-b)%2==0)printf(&quot;1\n&quot;);            else printf(&quot;2\n&quot;);        }    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p>WeirdSort</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582966700624.png" srcset="/img/loading.gif" alt="1582966700624"></p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>这题看起来和冒泡排序很像，将冒泡排序的判断条件改一下就可以，每一次必须是在限制的位置上时才可以swap。最后再判断是否变成有序数列即可。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int a[maxn],p[maxn],n,m,T,vis[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(vis,0,sizeof(vis));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%d&quot;,&amp;p[i]);            vis[p[i]]=1;        }        int sign=0;        for(int i=1;i&lt;=n;i++)        {            if(sign==1)break;            for(int j=1;j&lt;=n-i;j++)            {                if(a[j]&gt;a[j+1])                {                    if(!vis[j])                    {                        sign=1;                        break;                    }                    else                     {                        swap(a[j],a[j+1]);                    }                }            }        }        for(int i=1;i&lt;=n-1;i++)        {            if(sign==1)break;            if(a[i]&gt;a[i+1])            {                sign=1;                break;            }        }        if(sign==1)printf(&quot;NO\n&quot;);        else printf(&quot;YES\n&quot;);    }    return 0;}</code></pre><h1 id="C：题目名称："><a href="#C：题目名称：" class="headerlink" title="C：题目名称："></a>C：题目名称：</h1><p>Perform the Combo</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一台机器准备要打印一篇文章，有 m 个打印操作</p><p>给出操作序列 p1,p2, …,pm和 长度为 n的字符串 s<br>对于每个 1≤<em>i</em>≤m，pi表示该机器将位置1∼pi上的所有字母打印了出来<br>最后，在所有操作做完后，该机器又将整个字符串 s打印了出来</p><p>请求出字母表中每个字母在文章中出现了多少次</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>先统计位置i之前26个字母每个字母的总数，然后直接模拟求总和，注意最后要加上一次完整的计数。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int T,n,m,s[maxn][27],ans[27];char a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(ans,0,sizeof(ans));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        scanf(&quot;%s&quot;,a+1);        for(int i=1;i&lt;=n;i++)        {            int x=a[i]-&#39;a&#39;+1;            for(int j=1;j&lt;=26;j++)            {                if(j==x)s[i][j]=s[i-1][j]+1;                else s[i][j]=s[i-1][j];            }        }        for(int i=1;i&lt;=m;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            for(int j=1;j&lt;=26;j++)            {                ans[j]=ans[j]+s[x][j];            }        }        for(int i=1;i&lt;=26;i++)ans[i]=ans[i]+s[n][i];        for(int i=1;i&lt;=26;i++)printf(&quot;%d &quot;,ans[i]);        cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D:题目名称："></a>D:题目名称：</h1><p>Three Integers</p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>题目给出三个整数a<em>≤</em>b<em>≤</em>c。</p><p>在一次操作中，你可以给这三个数中任意一个数 +1 或 -1。你可以用同一个数字做这样的操作任意次。但你要保证，变换过后的数，是一个正数。</p><p>你想要用最小操作步数使得三个整数 A<em>≤</em>B<em>≤</em>C能够符合：B 能被 A 整除， C能被 B整除。</p><p>你需要回答 t 组询问。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>一开始想着找出a与b，a与c的关系，结果这样写有点麻烦。b作为中间数字，当然用它来做媒介最好。注意b可以减到a，也可以加到c，所以枚举的大小应该为max(b-a,c-b);找到b-i的所有因子，得到a改变成b-i的因子的最小变化值ned1，并且记录a变化后的值。再找b-i的所有倍数，得到c变成b-i的倍数的最小变化之ned2，并且记录c变化后的值。再更新总变化值，以及记录a，b，c的值。然后同理求b+i的情况。如果b-i&lt;=0直接去掉。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=10000+5;int T,A,B,C,a,b,c;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        int ans=0x3f3f3f3f;        scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);        for(int i=0;i&lt;=max(B-A,C-B);i++)//注意取max         {            int B1=B-i,ned1=0x3f3f3f3f,ned2=0x3f3f3f3f,nowa,nowc;            if(B1&gt;0)            {                for(int j=1;j&lt;=sqrt(B1);j++)                {                    if(B1%j==0)                    {                        if(ned1&gt;abs(A-j))                        {                            ned1=abs(A-j);                            nowa=j;                        }                        if(ned1&gt;abs(A-B1/j))                        {                            ned1=abs(A-B1/j);                            nowa=B1/j;                        }                    }                }                for(int j=1;j&lt;=C/B1+1;j++)                {                    if(ned2&gt;abs(C-B1*j))                    {                        ned2=abs(C-B1*j);                        nowc=B1*j;                    }                }                if(ans&gt;ned1+ned2+i)                {                    ans=ned1+ned2+i;                    b=B1;a=nowa;c=nowc;                }                }            B1=B+i,ned1=0x3f3f3f3f,ned2=0x3f3f3f3f;            for(int j=1;j&lt;=sqrt(B1);j++)            {                if(B1%j==0)                {                    if(ned1&gt;abs(A-j))                    {                        ned1=abs(A-j);                        nowa=j;                    }                    if(ned1&gt;abs(A-B1/j))                    {                        ned1=abs(A-B1/j);                        nowa=B1/j;                    }                }            }            for(int j=1;j&lt;=C/B1+1;j++)            {                if(ned2&gt;abs(C-B1*j))                {                    ned2=abs(C-B1*j);                    nowc=B1*j;                }            }            if(ans&gt;ned1+ned2+i)            {                ans=ned1+ned2+i;                b=B1;a=nowa;c=nowc;            }        }        printf(&quot;%d\n&quot;,ans);        printf(&quot;%d %d %d\n&quot;,a,b,c);    }    return 0;}</code></pre><h1 id="E-题目名称："><a href="#E-题目名称：" class="headerlink" title="E:题目名称："></a>E:题目名称：</h1><p>Construct the Binary Tree</p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 要求构造一个n个节点的二叉树（每个节点拥有不超过2个孩子），节点1为根，要使所有节点到根的距离之和为d。要求先判断可不可以构造，如果可以输出“YES”，下一行输出2到n号节点的父亲节点，否则输出“NO”。有多组询问。 </p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>要想构成树，那么必须保证Minn&lt;=d&lt;=Maxx,Minn就是满二叉树(最接近满二叉树)的情况，Maxx就是链。然后就是从Minn转换或者从Maxx转换成d。这里选择将链转换变成满足深度总和满足d的情况，预处理出Minn[i]，即n=i，对应的最小深度和，若d&lt;Minn||d&gt;Maxx那么就NO,(Maxx=i*(i-1)/2)，然后构成链，a[i][0]=i+1,f[i+1]=i,cnt[i]=1;(cnt[i]表示i这个深度点的总数)，从最底层向上移动，移动最多就是和根(1)相接，设最小深度为minn=1，每一次上升的高度为delt=min(i-minn,t)(i为当前移动点的深度，t为需要上升的总次数)。于是点(i+1)移动到深度为i-delt的层，该层最多有2^(i-delt-1)个点，点(i+1）就位于cnt[pos]的位置，f[i+1]对应的是上一层的第cnt[pos]/2的点。即f[i+1]=a[pot-1][cnt[pos]/2]，那么a[pos][cnt[pos]]=i+1;注意每次cnt[pos]++,一旦cnt[pos]&gt;=pow(2,minn)，那么就要往下一层走了。</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=5000+5;int T,n,d,sum[maxn],maxx[maxn],f[maxn],a[maxn][maxn],cnt[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=2;    sum[1]=0;maxx[1]=0;    for(int i=2;i&lt;=5000;i++)    {        maxx[i]=i*(i-1)/2;        if(i&lt;pow(2,opt))        {            sum[i]=sum[i-1]+(opt-1);        }        else        {            opt++;            sum[i]=sum[i-1]+(opt-1);        }    }    while(T--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;d);        if(d&lt;sum[n]||d&gt;maxx[n])        {            printf(&quot;NO\n&quot;);            continue;        }        int t=maxx[n]-d;        for(int i=0;i&lt;=n-1;i++)        {            a[i][0]=i+1;f[i+1]=i;cnt[i]=1;        }        int minn=1;        for(int i=n-1;i&gt;=1;i--)        {            int delt=min(i-minn,t);            t-=delt;            int pos=i-delt;            f[i+1]=a[pos-1][cnt[pos]/2];            a[pos][cnt[pos]++]=i+1;            if(cnt[pos]&gt;=pow(2,minn))minn++;            if(!t)break;        }        printf(&quot;YES\n&quot;);        for(int i=2;i&lt;=n;i++)        {            printf(&quot;%d &quot;,f[i]);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><h1 id="F-题目名称："><a href="#F-题目名称：" class="headerlink" title="F:题目名称："></a>F:题目名称：</h1><p>Moving Points</p><h4 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h4><p><img src="C:%5CUsers%5Cha'er%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582968080820.png" srcset="/img/loading.gif" alt="1582968080820"></p><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><p>假如xi&lt;xj，那么要让i与j的距离可以变成0，就必须vi&gt;vj。不妨让所有的点按xi从小到大的顺序排列。对于i，需要找到所有满足vj&lt;vi的点，这样的i与j的距离就是0，其余的就是abs(xi-xj)，这样就需要维护这种点的vj的总和。可以选择树状数组来维护:先将所有点的vi从d小到大编号，1为最小，n为最大，找到点i的vi的排名p，然后加入到树状数组。排名小于p的就是vj&lt;vp的，否则就是vp&lt;vj的。树状数组要维护点p之前(包括点p)的点的个数和点p之前(包括点p)的v的总和。然后开始枚举点i，首先确定它v的排名p，得到p之前点的个数f1(即v&lt;vi的点的个数)，得到p之前的点的x总和f2(即v&lt;vi的x总和),求得可以使自己和点i之间的距离为0的个数，其余就是不可为0的。ans=ans+abs((n-f1-i)*a[i].x-(sum-f2));注意要减去a[i].x本身，并且每一对点之间只能计算一次，所以树状数组要更新，将权值加上负值即可(add(p,-1,-a[i].x);)。所以剩余距离不能为0的点个数为n-f1-i，而这些点的x之和就是sum-f2(每次sum-a[i].x)。最后输出ans。</p><p><strong>开longlong保平安</strong></p><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=200000+5;long long n,b[maxn],w1[maxn],w2[maxn];struct node{    long long x,v;}a[maxn];long long cmp(node x1,node x2){    return x1.x&lt;x2.x;}long long lowbit(long long x){    return x&amp;(-x);}void add(long long x,long long v1,long long v2){    while(x&lt;=n)    {        w1[x]+=v1;w2[x]+=v2;x+=lowbit(x);    }}long long query1(long long x){    long long ans=0;    while(x)    {        ans+=w1[x];x-=lowbit(x);    }    return ans;}long long query2(long long x){    long long ans=0;    while(x)    {        ans+=w2[x];x-=lowbit(x);    }    return ans;}int main(){    scanf(&quot;%lld&quot;,&amp;n);    long long sum=0;    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i].x);    for(long long i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i].v);        b[i]=a[i].v;    }    sort(a+1,a+1+n,cmp);    sort(b+1,b+1+n);    long long tot=unique(b+1,b+1+n)-b-1;    for(long long i=1;i&lt;=n;i++)    {        long long p=lower_bound(b+1,b+1+tot,a[i].v)-b;        add(p,1,a[i].x);        sum+=a[i].x;    }     long long ans=0;    for(long long i=1;i&lt;=n;i++)    {        long long p=lower_bound(b+1,b+1+tot,a[i].v)-b;        sum-=a[i].x;        long long f1=query1(p-1),f2=query2(p-1);        ans=ans+abs((n-f1-i)*a[i].x-(sum-f2));        add(p,-1,-a[i].x);    }    printf(&quot;%lld\n&quot;,ans);    return 0;} </code></pre>         <div id="aplayer-QzGoKVkI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-QzGoKVkI"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1300</title>
    <link href="/2020/02/19/CodeForces-1300/"/>
    <url>/2020/02/19/CodeForces-1300/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A:题目名称："></a>A:题目名称：</h1><p> Non-zero</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个含有 n个整数的数列。每次可以将其中的一个数加一，记为一次操作。问使得数列<strong>所有数之和</strong>与数列<strong>所有数的乘积</strong>都不为0的操作次数。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>乘积不可以为0，要就让所有为0的数字变成1，那么统计一下有多少个0就可以了。然后所有数之和不为0，只需要将0变成1之后a[1]-a[n]全部加起来，若不等于0则输出结果，若为0就将次数+1再输出结果。(a1+…+an=0，且不存在ai=0，那么必然存在aj&gt;0，则将aj++即可)</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+5;int T,n,a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        int ans=0,end=0;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            if(a[i]==0)            {                a[i]=1;                ans++;            }            end+=a[i];        }        if(end==0)        ans++;        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p> Assigning to Classes</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个有n * 2 个数的数列。让你把它分成两组，使得每一组的数量均为奇数。请你求出两组中位数之差的绝对值的最小值。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>我的方法稍微复杂了点，先将a数组从小到大排序。若n为奇数，那么直接交错分组即可，即a[1],a[3]…a[n]为一组,a[2],a[4]…a[n-1]为一组，最小的中位数的差的绝对值=a[n+1]-a[n]；若n为偶数，那么也是交错分组，但是有两种分法：</p><p>1.a[1],a[3]…a[n-3]为一组，a[2],a[4]…a[n-4],a[n-2],a[n-1],a[n]为一组。答案为a[n+2]-a[n-1];</p><p>2.a[1],a[3]…a[n-1],a[n]为一组，a[2],a[4]…a[n-2]为一组。答案为a[n+1]-a[n];</p><p>取min(a[n+2]-a[n-1],a[n+1]-a[n]);</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int T,n;long long a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=2*n;i++)        {            scanf(&quot;%lld&quot;,&amp;a[i]);        }        sort(a+1,a+1+2*n);        if(n%2==1)        {            printf(&quot;%lld\n&quot;,a[n+1]-a[n]);        }        else         {            printf(&quot;%lld\n&quot;,min(a[n+2]-a[n-1],a[n+1]-a[n]));        }    }    return 0;}</code></pre><h1 id="C：题目名称"><a href="#C：题目名称" class="headerlink" title="C：题目名称:"></a>C：题目名称:</h1><p>Anu Has a Function</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>定义一个函数f(<em>x</em>,<em>y</em>)=f(<em>x</em>∣<em>y</em>)−<em>y</em>。给定一个长度为 n数列 a，定义f(f..f(f(a1,a2),a3),…an−1),an)为这个数列的值。现在，请你将数列改变一种顺序，使得最后的值最大。输出你改变后的数列。(n&lt;=100000).</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>看样例找规律，假如将数字x分解成二进制，从右到左依次为第1位，第2位…第n位，将数字y分解成二进制，从左到右依次位第1位，第2位…第m位。那么对于f(x,y)=f(x|y)-y，可以当作每一位进行操作，假如第i位，xi=1，yi=1，则结果为0；如果xi=0，yi=1，则结果为0；如果xi=1，yi=0，则结果为1；如果xi=0，yi=0，则结果为0；综上所述，无论xi是否为1，只要yi为1，最后结果一定为0，只要yi=0，那结果一定等于xi。推广到n个数字，假如x存在i(xi==1)，使得剩下的n-1个数字yi==0，那么最后结果一定包含xi。为了使最后结果最大，就要让那独有的xi越大的越排在前面，其余的自由输出即可。(实际上就是将最大xi对应的数字单独输出，其余的自由输出)</p><p><strong>ps</strong>:0&lt;=ai&lt;=10^9，二进制位数设为40位即可。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;int w[42][maxn],n,vis[maxn];long long a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i]);        long long x=a[i],opt=1;        while(x)        {            long long y=x%2;            x/=2;            if(y==1)w[opt][++w[opt][0]]=i;            opt++;        }    }    for(int i=40;i&gt;=1;i--)    {        if(w[i][0]==1&amp;&amp;!vis[w[i][1]])        {            printf(&quot;%d &quot;,a[w[i][1]]);            vis[w[i][1]]=1;        }    }    for(int i=1;i&lt;=n;i++)    {        if(!vis[i])        {            printf(&quot;%d &quot;,a[i]);        }    }    cout&lt;&lt;endl;    return 0;}</code></pre><h1 id="D：题目名称："><a href="#D：题目名称：" class="headerlink" title="D：题目名称："></a>D：题目名称：</h1><p>Aerodynamic</p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个由n个点组成的<strong>严格</strong>（不存在三点共线）凸多边形。你要将这个图形平移n次，每次将一个顶点与原点 (0,0)重合。请判断这 n 个平移后的多边形除了与原点重合的点之外的点组成的多边形是否与原图形相似。在读入中，保证输入的点按逆时针顺序排列，形成严格凸多边形。3≤<em>n</em>≤10^5.</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>根据题意找规律，先观察n=3的情况，n=3使三角形拼接出来的不是三角形，而是六边形。n=4(正方形)刚好是一个新的正方形，而矩形也可以，不规则的则不行。n=5的显然和n=3一样不行。n=6(正六边形)用画图工具一画刚好符合。这时候结论就出来了：若是奇数边一定不行，若位偶数边就看它是否是中对称图形，即枚举前n/2个点i与它的对顶点n/2+i的中心点是否都是同一个点 (这里尽量不要除法，直接用乘法，免得丢失精度)，如果是中对称就符合，否则就不符合。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;long long n;struct node{    long long x,y;}a[maxn];int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)    {        scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y);    }    if(n%2==1)    {        printf(&quot;nO\n&quot;);    }    else     {        int sign=0;        long long midx=a[1].x+a[n/2+1].x;        long long midy=a[1].y+a[n/2+1].y;//不要用除法，要错。。。         for(int i=1;i&lt;=n/2;i++)        {            long long ansx=a[i].x+a[n/2+i].x;            long long ansy=a[i].y+a[n/2+i].y;            if(ansx!=midx||ansy!=midy)            {                sign=1;                break;            }        }        if(sign==1)        {            printf(&quot;nO\n&quot;);        }        else         {            printf(&quot;YES\n&quot;);        }    }    return 0;}</code></pre><h1 id="E：题目名称："><a href="#E：题目名称：" class="headerlink" title="E：题目名称："></a>E：题目名称：</h1><p>Water Balance</p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个序列，每次可以将一个区间内的所有数都变成操作前这个区间的平均数，求最后能得到的字典序最小的结果。  </p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>一共有n个数字，要使得它越靠前的数字越小，变小的方法就是和后面的数字求平均值。让输出这个字典序最小的结果。看数据范围，显然线性是最好的，如何进行线性的操作呢？考虑从1开始，初始使n个数字每个占一个区域块，一旦枚举到的数字可以使前面区域块的平均值减小就合并。详细一点说明：比如枚举到第i个数字，当前有tot个区域块，改区域块的总值为w[tot],所含数字个数t[tot],如果数字a[i]可以使这个区域块的值减小，那么用g表示当前所含个数总数，ans表示当前所含总值，那么g=1+t[tot],ans=a[i]+w[tot],然后再往前判断能否让前面的区域块减小，一直往前推，直到不符合。然后进行区域块的合并。如果a[i]==w[tot]/t[tot]，可以直接合并。如果a[i]&gt;w[tot]/t[tot],则i单独为一个区域块。</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int n,tot,t[maxn];double a[maxn],w[maxn];int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;a[i]);    for(int i=1;i&lt;=n;i++)    {        if(a[i]&lt;w[tot]/(double)t[tot])        {            int opt=tot,g=1;double ans=a[i];            while(opt&gt;=1)            {                g+=t[opt];ans+=w[opt];                if(ans/(double)g&lt;w[opt]/t[opt])                {                    opt--;                }                else                 {                    g-=t[opt];ans-=w[opt];opt++;                    break;                }            }            if(opt==0)opt=1;            tot=opt;            w[tot]=ans;t[tot]=g;        }        else if(a[i]*t[tot]==w[tot]&amp;&amp;tot!=0)        {            t[tot]++;            w[tot]+=a[i];        }        else         {            tot++;t[tot]=1;            w[tot]=a[i];        }    }    for(int i=1;i&lt;=tot;i++)    {        for(int j=1;j&lt;=t[i];j++)        {            printf(&quot;%.9lf\n&quot;,w[i]/t[i]);        }    }    return 0;} </code></pre>         <div id="aplayer-dSrKQlim" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-dSrKQlim"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1307</title>
    <link href="/2020/02/18/CodeForces-1307/"/>
    <url>/2020/02/18/CodeForces-1307/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A:题目名称："></a>A:题目名称：</h1><p> Cow and Haybales </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>t组数据，每组数据n堆，有d天，每天可以相邻的堆直接移动物品，每次移动物品数质可以为1，或者不移动。问d天后，第一堆最多有多少个物品。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>每天只能再相邻堆移动1个物品。直接考虑模拟，从最近的地方往前移动，并且一直移动同一个物品，直到它移动到第一堆的地方。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200+5;int T,n,m,a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);        if(n==1)        {            printf(&quot;%d\n&quot;,a[1]);            continue;        }        while(m)        {            int t=2;            while(t&lt;=n-1&amp;&amp;a[t]==0)//WA1            {                t++;            }            if(t==n&amp;&amp;a[t]==0)            break;            else             {                a[t]--;                a[t-1]++;            }            m--;        }        printf(&quot;%d\n&quot;,a[1]);    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p> Cow and Friend</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有t只兔子，每只兔子有n个喜欢的数字，并且它想一共跳x的距离(即从 (0，0)跳到(x，0))。每次跳跃都跳的距离只能是自己喜欢的数字。问至少跳几次？</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>看了一下样例，感觉很像是贪心，于是模拟了一下，首先找到最大的喜欢的数字，假设maxx&lt;x，并且2 * maxx&gt;x，那么最多跳两次就够了，成等腰三角形，中间的倾角视情况而定，但是一定是可以的，原因：maxx+maxx&gt;x符合三角形的定义。假设maxx&lt;x，并且2 * maxx&lt;x(等于的情况必然是2)，如果x%maxx==0，那么直接沿着x轴跳x/maxx次就可以了，否则跳x/maxx+1次，(起点和终点相连接的边做调整，使得剩余长度是maxx的倍数就可以了)。如果maxx&gt;x，如果有喜欢的数字==x，就跳1次，否则就2次。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long T,n,t;int main(){    scanf(&quot;%lld&quot;,&amp;T);    while(T--)    {        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;t);        long long maxx=0;int sign=0;        for(int i=1;i&lt;=n;i++)        {            long long x;            scanf(&quot;%lld&quot;,&amp;x);            if(x==t)sign=1;            maxx=max(maxx,x);        }        if(maxx&gt;t)        {            if(sign==1)            printf(&quot;1\n&quot;);            else             printf(&quot;2\n&quot;);            continue;        }        if(t%maxx==0)        {            printf(&quot;%lld\n&quot;,t/maxx);        }        else         {            printf(&quot;%lld\n&quot;,t/maxx+1);        }    }    return 0;}</code></pre><h1 id="C：题目名称："><a href="#C：题目名称：" class="headerlink" title="C：题目名称："></a>C：题目名称：</h1><p>Cow and Message</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求串s中出现次数最多的子序列t的出现次数。其中子序列在s中所对应的下标必须构成等差数列。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>英语差的锅。一开始被题意神奇迷惑。以为只有某个子串的下标构成了等差数列那么这一类都可以了。这就是一开始觉得方法始终不对的原因。设想子串长度都为1或者2，那么它必然符合题意。如果子串长度为3呢？那么中间只有1个可以符合。这样数量就大大减少了。于是猜测子串长度都为1或者2。都为1即统计每种字母出现的次数然后取max。对于子串长度为2，枚举当前字母i，然后枚举匹配字母j(i!=j)，再枚举起点，并且预处理每个结点之后26个字母每个字母的个数，然后计算。最后还需要求同种字母的情况，即w[i]*(w[i]-1)/2,最后取max就是答案。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;long long a[maxn][30],w[30];char s[maxn];int main(){    scanf(&quot;%s&quot;,s+1);    int len=strlen(s+1);    for(int i=len;i&gt;=1;i--)    {        int x=s[i]-&#39;a&#39;+1;        a[i-1][x]=a[i][x]+1;        for(int j=1;j&lt;=26;j++)        {            if(j==x)continue;            a[i-1][j]=a[i][j];        }        w[x]++;    }    long long ans=0;    for(int i=1;i&lt;=26;i++)    {        for(int k=1;k&lt;=26;k++)        {            if(i==k)continue;            long long tot=0;            for(int j=1;j&lt;=len;j++)            {                if(s[j]==i-1+&#39;a&#39;)                {                    tot+=a[j][k];                }            }                ans=max(ans,tot);        }    }    for(int i=1;i&lt;=26;i++)    {        ans=max(ans,w[i]);        ans=max(ans,w[i]*(w[i]-1)/2);    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><h1 id="D：题目名称："><a href="#D：题目名称：" class="headerlink" title="D：题目名称："></a>D：题目名称：</h1><p>Cow and Fields</p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个点，m条道路(双向)，k个特殊点，给定m条边，每条边长度为1，在k个特殊点种选取两个点连接，使得从1到n最短路径要尽量长。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>首先要得到每个点到起点1的距离和到终点n的距离，直接以1为起点跑一次dijksta+堆优化，再以n为起点跑依次dijkstra+堆优化。设最短路径长度为minn，则要求min(minn,min(dist1[i]+dist2[j]+1,dist1[j]+dist2[i]+1)),假设再i和j之间连边，可能是i更靠近1，也可能是j更靠近1，所以求1-n的最短路径长度时取min(dist1[a[i]]+dist2[a[j]]+1,dist1[a[j]]+dist2[a[i]]+1);但是这样的时间复杂度是k * k显然不符合，需要优化，优化的切入点就是a[i]和a[j]之间的关系。假如a[i]始终比a[j]更靠近起点1，那么答案就是min(minn,dist1[a[i]]+dist2[a[j]]+1);并且假设i是最靠近j的并且比j更靠近起点1的特殊点。那么答案就是min(minn,dist1[a[i]]+dist2[a[i]+1]+1);那要如何让a数组种的元素按照到起点的距离进行递增呢？按照前面的假设可得dist1[a[i]]+dist2[a[j]]+1&lt;dist1[a[j]]+dist2[a[i]]+1(i比j更靠近起点1)，即dist1[a[i]]-dist2[a[i]]&lt;dist1[a[j]]-dist2[a[j]];所以直接sort(要求dist1[a[i]]-dist2[a[i]]&lt;dist1[a[j]]-dist2[a[j]])，排序之后就是按照距离起点的距离递增排列了。那么就可以线性找到答案了。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;int n,m,q,head[maxn],dist1[maxn],dist2[maxn],a[maxn],k=1,s,t,vis[maxn];struct node{    int to,next,w,u;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].u=u;}struct N{    int now,w;    bool operator &lt; (N x)const{return x.w&lt;w;}};void dijkstra1(){    priority_queue&lt;N&gt;q;    memset(dist1,0x3f3f3f3f,sizeof(dist1));    memset(vis,0,sizeof(vis));    dist1[s]=0;    N x;x.now=s;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist1[edge[i].to]&gt;dist1[x.now]+edge[i].w)            {                dist1[edge[i].to]=dist1[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist1[edge[i].to];                q.push(now);            }        }    }}void dijkstra2(){    priority_queue&lt;N&gt;q;    memset(dist2,0x3f3f3f3f,sizeof(dist1));    memset(vis,0,sizeof(vis));    dist2[s]=0;    N x;x.now=s;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist2[edge[i].to]&gt;dist2[x.now]+edge[i].w)            {                dist2[edge[i].to]=dist2[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist2[edge[i].to];                q.push(now);            }        }    }}int cmp(int x,int y){    return dist1[x]-dist2[x]&lt;dist1[y]-dist2[y];}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);    for(int i=1;i&lt;=q;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i=1;i&lt;=m;i++)    {        int a,b;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b,1);add(b,a,1);    }    s=1;t=n;    dijkstra1();    s=n;t=1;    dijkstra2();    int ans=0;    int minn=dist1[n];    sort(a+1,a+1+q,cmp);    for(int i=2;i&lt;=q;i++)    {        ans=max(ans,dist1[a[i-1]]+dist2[a[i]]+1);    }    ans=min(ans,minn);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-wZqVREWC" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-wZqVREWC"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1304</title>
    <link href="/2020/02/16/CodeForces-1304/"/>
    <url>/2020/02/16/CodeForces-1304/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A: 题目名称："></a>A: 题目名称：</h1><p> Two Rabbits </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，给定x，y，a，b。其中x，y分别为两兔子的坐标(x&lt;y),a，b分别为对应兔子的速度，左边的兔子向右跳，右边的兔子向左跳，问能否相遇，若能请输出时间t，否则输出-1.</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>设delt=y-x，若delt%(a+b)则t=delt/(a+b),否则输出-1.</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long t,x,y,a,b;int main(){    scanf(&quot;%lld&quot;,&amp;t);    while(t--)    {        scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;a,&amp;b);        long long delt=abs(y-x);        if(delt%(a+b)==0)        {            long long t=delt/(a+b);            printf(&quot;%d\n&quot;,t);            continue;        }        else         {            printf(&quot;-1\n&quot;);            continue;        }    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p> Longest Palindrome </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定n个字符串，每个字符串的长度为m，可以任意选择若干个字符串随机组合构成最长的回文串，如果有多个这样的回文串，任意输出一个即可，如果没有则输出0.</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>枚举所有的字符串，找到两个字符串中：字符串i从头到尾等于字符串j的丛尾到头。这样i和j可以配对，并且标记一下。最后还要考虑一种情况：一个字符串本身就是回文，它可以放在中间，并且它没有被标记过，找到一个即可。最后判断是否存在，若无则输出0，否则先输出长度ans * 2 * m+Ans * m，然后先输出前面部分的字符串，并储存方便后面逆序输出，然后输出中间部分，若不存在则不管。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int n,m,vis[maxn],stack[maxn],V[maxn];char s[maxn][maxn],t[maxn*maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)scanf(&quot;%s&quot;,s[i]);    int ans=0,Ans=0;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(i==j||vis[i]||vis[j])continue;            int sign=0;            for(int k=0;k&lt;m;k++)            {                if(s[i][k]!=s[j][m-k-1])                {                    sign=1;                    break;                }            }            if(sign==0)            {                vis[i]=j;vis[j]=i;                ans++;                stack[ans]=i;            }        }    }    for(int i=1;i&lt;=n;i++)    {        if(vis[i])continue;        int sign=0;        for(int j=0;j&lt;m;j++)        {            if(s[i][j]!=s[i][m-j-1])            {                sign=1;                break;            }        }        if(sign==0)        {            Ans++;            V[Ans]=i;            break;        }    }    if(ans==0&amp;&amp;Ans==0)    {        printf(&quot;0\n&quot;);    }    else     {        printf(&quot;%d\n&quot;,ans*2*m+Ans*m);        int now=0;        for(int i=1;i&lt;=ans;i++)        {            printf(&quot;%s&quot;,s[stack[i]]);            for(int j=0;j&lt;m;j++)            {                t[++now]=s[stack[i]][j];            }        }        if(Ans)        {            printf(&quot;%s&quot;,s[V[Ans]]);        }        for(int i=now;i&gt;=1;i--)        printf(&quot;%c&quot;,t[i]);        cout&lt;&lt;endl;    }    return  0;}</code></pre><h1 id="C：题目名称："><a href="#C：题目名称：" class="headerlink" title="C：题目名称："></a>C：题目名称：</h1><p> Air Conditioner </p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有q组数据，每组数据给定顾客数n，和初始温度m，然后再给定每个顾客到达的时间，和适应的最低温度和最高温度， 每一分钟可以选择升高温度1，降低温度1，或者不变。问能否满足所有的顾客，能则YES，否则NO。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>一开始我以为是贪心，结果准备统计所有的空闲时间并且与调整时间来比大小，结果不对，完全错误，于是又想DP，但是数据10^9，没办法写出DP方程，然后突然想到了区间，既然给定了左右端点，那不就可以得到每个顾客到达那一刻温度可调整的区间吗？只要这个区间和顾客适应的区间存在交点那就符合。并且保证判断之后这个区间要修改到顾客适应的区间的范围内(一开始以为既然符合情况了就不会存在超出范围的情况了，其实完全可能某一端点无法在限定时间内缩回去，所以超出的必须除去)，因为当前温度超出顾客的适应范围就不符合要求了。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=500+5;long long T,n,t,x,y;struct node{    long long t,x,y;}a[maxn];int main(){    scanf(&quot;%lld&quot;,&amp;T);    while(T--)    {        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;t);        x=y=t;        for(int i=1;i&lt;=n;i++)        scanf(&quot;%lld%lld%lld&quot;,&amp;a[i].t,&amp;a[i].x,&amp;a[i].y);        long long now=1;        long long sign=0;        while(now&lt;=n)        {            long long delt=a[now].t-a[now-1].t;            if(x&lt;a[now].x)            {                x+=delt;                if(x&gt;a[now].x)                x=a[now].x;            }            else if(x&gt;a[now].x)            {                x-=delt;                if(x&lt;a[now].x)                x=a[now].x;            }            if(y&lt;a[now].y)            {                y+=delt;                if(y&gt;a[now].y)                y=a[now].y;            }            else if(y&gt;a[now].y)            {                y-=delt;                if(y&lt;a[now].y)                y=a[now].y;            }            if((x&lt;a[now].x&amp;&amp;y&lt;a[now].x)||(x&gt;a[now].y&amp;&amp;y&gt;a[now].y))            {                sign=1;                printf(&quot;NO\n&quot;);                break;            }            if(x&lt;a[now].x)x=a[now].x;            if(y&gt;a[now].y)y=a[now].y;            now++;        }        if(sign==0)        {            printf(&quot;YES\n&quot;);        }    }    return 0;}</code></pre><hr><h1 id="补题："><a href="#补题：" class="headerlink" title="补题："></a>补题：</h1><h1 id="D：题目名称："><a href="#D：题目名称：" class="headerlink" title="D：题目名称："></a>D：题目名称：</h1><p> Shortest and Longest LIS </p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有t组数据，每组数据给定一个n，说明数字1-n，然后给定n-1个&gt;/&lt;，让排出符合要求的数字排列，第一个要求最长上升序列是最短的，第二个要求最长上升序列是最短的。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>贪心+模拟。首先考虑第一问，观察一下答案，发现凡是小于(不连续)的都是从左到右依次减小，而大于的都是左边的尽量大，右边的尽量小。可以设想：要让最长上升序列最短，那么&lt;对应的数字就要比它左边的&lt;对应的数字更小，这样就可以进行隔断，来缩小长度；而左边&gt;对应的数字就是比右边&gt;对应的数字更小，这样的话越右边的数字就越小，这样也可以缩小长度。于是对于问题一的做法就很简单了：设minn=1,maxx=n，因为越右边的&lt;对应的数字越小，所有我们从右向左枚举，一旦枚举到s[i]==’&lt;’就让a[i]=minn并且minn++，但是现在问题来了：如果&lt;重复了呢？(如&lt;&lt;,&lt;&lt;&lt;等等)再如此做的话就与’&lt;’的定义矛盾了，于是这时候就需要找到这一串连续的 ‘&lt;’的左端点，然后从左端点到右端点依次让a[j]=minn并且minn++。枚举结束后让i=now+1，这样就实现了跳转，依旧是线性的。然后对于’&gt;’，要让左边的尽量大，所以我们从左向右枚举，如果s[i]==’&gt;’,那么a[i]=maxx，maxx–；最后a[n]=maxx;这样再输出a数组，问题1就解决了。</p><p>那问题2呢？</p><p>问题2要求的是最长上升序列最长，就与问题1相反，对于’&lt;’就从左往右依次增大，对于’&gt;’就从右往左依次减小，方法与问题基本一样，但是要注意连续的’&gt;’的情况，处理方式与连续的’&lt;’类似，如果s[n-1]即最后一个符号是 &lt;，那么就让a[n]=n,这里特判一下即可。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int T,n;char s[maxn];int a[maxn],maxx,minn;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%s&quot;,s+1);        maxx=n;minn=1;        for(int i=n-1;i&gt;=1;i--)        {            if(s[i]==&#39;&lt;&#39;&amp;&amp;s[i-1]!=&#39;&lt;&#39;)            {                a[i]=minn;                minn++;            }            else if(s[i]==&#39;&lt;&#39;&amp;&amp;s[i-1]==&#39;&lt;&#39;)            {                int now=i;                while(s[now]==&#39;&lt;&#39;&amp;&amp;now&gt;=1)now--;                for(int j=now+1;j&lt;=i;j++)                {                    a[j]=minn;                    minn++;                }                i=now+1;            }        }        for(int i=1;i&lt;=n-1;i++)        {            if(s[i]==&#39;&gt;&#39;)            {                a[i]=maxx;                maxx--;                }        }        a[n]=maxx;        for(int i=1;i&lt;=n;i++)        printf(&quot;%d &quot;,a[i]);        cout&lt;&lt;endl;        maxx=n,minn=1;        for(int i=1;i&lt;=n-1;i++)        {            if(s[i]==&#39;&lt;&#39;)            {                a[i]=minn;                minn++;            }        }        if(s[n-1]==&#39;&lt;&#39;)        {            a[n]=n;maxx--;        }        for(int i=n-1;i&gt;=1;i--)        {            if(s[i]==&#39;&gt;&#39;&amp;&amp;s[i-1]!=&#39;&gt;&#39;)            {                a[i]=maxx;                maxx--;            }            else if(s[i]==&#39;&gt;&#39;&amp;&amp;s[i-1]==&#39;&gt;&#39;)            {                int now=i;                while(s[now]==&#39;&gt;&#39;&amp;&amp;now&gt;=1)now--;                for(int j=now+1;j&lt;=i;j++)                {                    a[j]=maxx;                    maxx--;                }                i=now+1;            }        }        if(s[n-1]!=&#39;&lt;&#39;)        {            a[n]=maxx;        }        for(int i=1;i&lt;=n;i++)        {            printf(&quot;%d &quot;,a[i]);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="E：题目名称："><a href="#E：题目名称：" class="headerlink" title="E：题目名称："></a>E：题目名称：</h1><p> 1-Trees and Queries </p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个n个点的树,相邻点的距离为1 。</p><p>q个询问，每个询问包含无个整数： x,y,a,b,k。</p><p>含义是：在原树上新连上一条边 (x,y) ，要求判断一下从a点是否有距离为k的到b的路径。</p><p>注意：</p><ul><li>每个询问是独立的，即上次询问加上的边，不能为这一次的询问所用。</li><li>这一条路径也许会重复经过某一条边或某一点。</li></ul><p>(q&lt;=10^5,n&lt;=10^5)</p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>由题知此图是树，任意两点之间的最短距离是确定唯一的。有q个操作，每次操作会加入两种新边，一共就有三种边(对于在无关路径上来回移动的不考虑)，很显然每次新加入边之后，受到直接影响的是端点x，y。它将改变a–&gt;b的路径方式。考虑新的路径必然是将端点a，b作为切入点。(必须要走新加入的边，因为这个边是改变路径方式的唯一方式！)</p><p>路径1：a–&gt;b；</p><p>路径2：a–&gt;x x–&gt;y(即新加的边) y–&gt;b</p><p>路径3：a–&gt;y y–&gt;x(即新加的边) x–&gt;b</p><p>那么就开始求路径1，2，3的长度。如何求呢？肯定需要用到LCA了。为了方便，设点1为起点，并且deep[1]=0,假如要求点a，b的距离，那么就要分两种情况：</p><p>情况1：a，b其中一点是另一个点的祖先，那么s=abs(deep[a]-deep[b]);</p><p>情况2：f1是点a，b的最近公共祖先，那么s=deep[a]+deep[b]-deep[f1]*2(第一次交就因为没×2 WA了)</p><p>对于路径1的s：</p><pre><code class="cpp">        f1=lca(x,y);        if(f1==x||f1==y)        s1=abs(deep[x]-deep[y]);        else        s1=deep[x]+deep[y]-deep[f1]*2;</code></pre><p>对于路径2的s：</p><pre><code class="cpp">        f1=lca(x,a);f2=lca(b,y);//因为是两条边，自然两边的LCA都要求        if(f1==x||f1==a)        s1=abs(deep[x]-deep[a]);        else         s1=deep[x]+deep[a]-deep[f1]*2;        if(f2==b||f2==y)        s1=s1+abs(deep[b]-deep[y]);        else         s1=s1+deep[b]+deep[y]-deep[f2]*2;        s1+=1;//必须要走新加入的边，因为这个边是改变路径方式的唯一方式！</code></pre><p>对于路径3的s：(同路径2类似)</p><pre><code class="cpp">        f1=lca(x,b);f2=lca(a,y);        if(f1==x||f1==b)        s1=abs(deep[x]-deep[b]);        else         s1=deep[x]+deep[b]-deep[f1]*2;        if(f2==a||f2==y)        s1=s1+abs(deep[a]-deep[y]);        else         s1=s1+deep[a]+deep[y]-deep[f2]*2;        s1+=1;</code></pre><p>最后如何判定s是否符合要求呢？</p><p>首先明确一下，如果如果剩余了偶数的长度，其实就可以在终点和它相邻的点之间来回走，直到走完为止。当然要确保k足够提前到达终点。</p><p>所以判定条件就是(k-s1)&gt;=0&amp;&amp;(k-s1)%2==0。三条路径任意一条满足即可，否则就NO。</p><p><strong>ps</strong>:我人傻了，为什么要分情况啊，直接s1=deep[a]+deep[b]-deep[f1]*2就可以了啊;</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=100000+5;long long K=1,n,q,head[maxn],father[maxn][22],vis[maxn],deep[maxn];struct node{    long long to,next;}edge[maxn*2];void add(long long u,long long v){    edge[++K].to=v;edge[K].next=head[u];head[u]=K;}long long dfs(long long x,long long depth){    deep[x]=depth;vis[x]=1;    for(long long i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            father[edge[i].to][0]=x;            dfs(edge[i].to,depth+1);        }    }}long long lca(long long x,long long y){    if(deep[x]&lt;deep[y])swap(x,y);    long long depth=deep[x]-deep[y];    for(long long i=20;i&gt;=0;i--)    {        if(depth&amp;(1&lt;&lt;i))        {            x=father[x][i];        }    }    if(x==y)return x;    for(long long i=20;i&gt;=0;i--)    {        if(father[x][i]!=father[y][i])        {            x=father[x][i];y=father[y][i];        }    }    return father[x][0];}int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;n;i++)    {        long long a,b;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        add(a,b);add(b,a);    }    dfs(1,0);    for(long long i=1;i&lt;=20;i++)    {        for(long long j=1;j&lt;=n;j++)        {            father[j][i]=father[father[j][i-1]][i-1];        }    }    scanf(&quot;%lld&quot;,&amp;q);    for(long long i=1;i&lt;=q;i++)    {        long long a,b,x,y,k,f1,f2,s1;//新加a--b         long long sign=0;        scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;x,&amp;y,&amp;k);        f1=lca(x,y);        if(f1==x||f1==y)        s1=abs(deep[x]-deep[y]);        else        s1=deep[x]+deep[y]-deep[f1]*2;        if((k-s1)&gt;=0&amp;&amp;(k-s1)%2==0)        {            sign=1;            printf(&quot;YES\n&quot;);            continue;        }        f1=lca(x,a);f2=lca(b,y);        if(f1==x||f1==a)        s1=abs(deep[x]-deep[a]);        else         s1=deep[x]+deep[a]-deep[f1]*2;        if(f2==b||f2==y)        s1=s1+abs(deep[b]-deep[y]);        else         s1=s1+deep[b]+deep[y]-deep[f2]*2;        s1+=1;        if((k-s1)&gt;=0&amp;&amp;(k-s1)%2==0)        {            sign=1;            printf(&quot;YES\n&quot;);            continue;        }        f1=lca(x,b);f2=lca(a,y);        if(f1==x||f1==b)        s1=abs(deep[x]-deep[b]);        else         s1=deep[x]+deep[b]-deep[f1]*2;        if(f2==a||f2==y)        s1=s1+abs(deep[a]-deep[y]);        else         s1=s1+deep[a]+deep[y]-deep[f2]*2;        s1+=1;        if((k-s1)&gt;=0&amp;&amp;(k-s1)%2==0)        {            sign=1;            printf(&quot;YES\n&quot;);            continue;        }        if(sign==0)        {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-DdMGXPvJ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DdMGXPvJ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1303</title>
    <link href="/2020/02/15/CodeForces-1303/"/>
    <url>/2020/02/15/CodeForces-1303/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A：题目名称："><a href="#A：题目名称：" class="headerlink" title="A：题目名称："></a>A：题目名称：</h1><p>  Erasing Zeroes </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>删除最少的0，使所有的1连续，问删除多少个0？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>找到最后一个1的位置，和开头1的位置，枚举中间0的个数</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T;char s[105];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%s&quot;,s);        int sign=0,ans=0,t=0;        for(int i=strlen(s);i&gt;=0;i--)        {            if(s[i]==&#39;1&#39;)            {                t=i;                break;            }        }        for(int i=0;i&lt;=t;i++)        {            if(!sign)            {                if(s[i]==&#39;1&#39;)                {                    sign=1;                }            }            else if(sign==1)             {                if(s[i]==&#39;0&#39;)                {                    ans++;                }            }        }        if(sign==0)ans=0;        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p>National Project </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>修一条长n的路，连续g天修的好路，连续b天修的坏路，好路至少占一半，问要修完这条路至少几天？(一天只修长度1的路)</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>先特判：n如果&lt;=g||(n/2&lt;=g&amp;&amp;n&gt;=g)直接修n天</p><p>分n为奇数和偶数判断，先找到修g天好路需要t个轮回。如果好路没修够，就需要延长1个轮回，这个轮回不一定完整。如果好路修够了，那么只需要看剩下多长没修，注意期间可以修坏路，最后求个总和。对于延长一个轮回的情况，要加上继续修好路的天数。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long T,n,g,b;int main(){    scanf(&quot;%lld&quot;,&amp;T);    while(T--)    {        scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;g,&amp;b);        long long p;        if(n%2==0)p=n/2;        else p=n/2+1;        if(n&lt;=g)        {            printf(&quot;%lld\n&quot;,n);            continue;        }        if(p&lt;=g&amp;&amp;n&gt;=g)        {            printf(&quot;%lld\n&quot;,n);            continue;        }        long long ans=0;        long long t=p/g;        long long yu=p-t*g;        if(yu==0)        {            long long t2=min(n-p,(t-1)*b);            long long yu2=n-p-t2;            ans=yu2+t*g+(t-1)*b;        }        else         {            long long t2=min(n-p,t*b);            long long yu2=n-p-t2;            ans=yu2+t*(b+g)+yu;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-SxupVYbY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-SxupVYbY"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-620</title>
    <link href="/2020/02/14/CodeForces-620/"/>
    <url>/2020/02/14/CodeForces-620/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A：题目名称："><a href="#A：题目名称：" class="headerlink" title="A：题目名称："></a>A：题目名称：</h1><p>Professor GukiZ’s Robot </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>机器人很好玩</p><p>一开始在(x1,y1)</p><p>最后在(x2,y2)</p><p>每秒钟内横坐标最多变化1（也可以不变化）纵坐标也是</p><p>问最少几秒钟到 x1 和 x2 绝对值在10^9以内 。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>取两者坐标x，y相差的最大值，开longlong保平安。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){    long long x1,x2,y1,y2;    scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);    long long maxx=max(abs(x1-x2),abs(y1-y2));    printf(&quot;%lld\n&quot;,maxx);    return 0;} </code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B:题目名称："></a>B:题目名称：</h1><p> Grandfather Dovlet’s calculator </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>从0-9每一个数字由若干个小木棍组成，给定a，b，问搭出a-b的每一个数字需要多少个小木棍。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>t[i]表示数字i需要的木棍(i∈[0,9]),然后枚举。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long a,b,t[10]={6,2,5,5,4,5,6,3,7,6};int main(){    long long ans=0;    scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);    for(long long i=a;i&lt;=b;i++)    {        long long now=i;        while(now)        {            long long x=now%10;            now/=10;            ans+=t[x];        }    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><h1 id="C：题目名称："><a href="#C：题目名称：" class="headerlink" title="C：题目名称："></a>C：题目名称：</h1><p> Pearls in a Row </p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>现在有N个数，你的任务是将这N个数尽可能切割成多段。每一段必须包括两个相同的数。 </p><p>输出的第一行为尽可能切割的最大段数K。</p><p>接下来K行，每行为两个整数lj, rj (1 ≤lj ≤ rj ≤ <em>n</em>) ，表示切割的区间范围</p><p>如果存在多个合法的切割方法，输出任意一个即可。</p><p>如果不能切割成合法的情况，输出”-1”.</p><p>数据第一行为N(1 ≤ <em>N</em> ≤ 3·105) 。</p><p>数据的第二行包括N个数ai(1 ≤ a[i] ≤ 109) 。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>看到N&lt;=300000，然后再看到a[i]的数据，由于答案只与二者是否相等有关，那么它的值就无关紧要了，所以直接离散化。离散化之后就是如何分割了，首先就想到了贪心，一旦又符合条件的就直接分割，如何考虑这个分案的合理性呢？假设区间 [x,y]为一段，a[x]==a[y],如果w∈(x,y),z&gt;y,那么我们也必须选择[x,y] ,否则区间(x,w)不符合题意。如果我们遇到有两个相等了而不分割，这样并不能使数量增加，所以每遇到两个相等就立即分割，这样受到影响的只有最后一段，因为最后一段可能无法成立，那它直接与前一段合并，即前一段的l[opt]=n就可以了。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=300000+5;long long n,a[maxn],b[maxn],vis[maxn],opt,l[maxn],r[maxn];int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i]);         b[i]=a[i];    }    sort(b+1,b+1+n);    long long tot=unique(b+1,b+1+n)-b-1;        for(long long i=1;i&lt;=n;i++)    {        a[i]=lower_bound(b+1,b+1+tot,a[i])-b;    }    for(long long i=1;i&lt;=n;i++)    {        if(vis[a[i]]==opt+1)        {            vis[a[i]]=0;            opt++;            l[opt]=r[opt-1]+1;            r[opt]=i;        }        else        {            vis[a[i]]=opt+1;        }    }    if(opt==0)    {        printf(&quot;-1\n&quot;);        return 0;    }    if(r[opt]!=n)    r[opt]=n;    printf(&quot;%lld\n&quot;,opt);    for(long long i=1;i&lt;=opt;i++)    {        printf(&quot;%lld %lld\n&quot;,l[i],r[i]);    }    return 0;}</code></pre><p><strong>ps</strong>：一开始一直WA，原因使if，else那段写反了，注意每一个vis[a[i]]都需要修改！</p>        <div id="aplayer-DSilyLsI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DSilyLsI"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu-1640</title>
    <link href="/2020/02/13/luogu-1640/"/>
    <url>/2020/02/13/luogu-1640/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>luogu1640-[SCOI2010]连续攻击游戏</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://www.luogu.com.cn/problem/P1640" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1640</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个装备，每个装备有两个攻击值，每个装备只能用1次，问从1开始可以连续攻击几次？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>虽然有很多并查集的方法，但是最近一直在练习二分图匹配，发现这个题可以用二分图来做，主要是因为每个装备只有两个攻击值这样的话可以大大减少时间复杂度，很显然这个地方就是突破点，设想每个攻击值x，y对装备i建单向边，然后从1开始跑匈牙利算法，一旦找不到匹配说明攻击中断，当前的最大匹配ans就是最多能连续攻击的次数，但是注意一下不可以memset(vis,0,sizeof(vis))，处理方法很简单，vis只是防止当前dfs不能重复点，于是vis[edge[i].to]=x，相当于一个时间戳，就可以完美避免初始化了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int k=1,head[maxn],vis[maxn],cy[maxn],n;struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(vis[edge[i].to]==x)continue;        vis[edge[i].to]=x;        if(cy[edge[i].to]==-1||dfs(cy[edge[i].to]))        {            cy[edge[i].to]=x;            return 1;        }    }    return 0;}int main(){    int maxx=0;    scanf(&quot;%d&quot;,&amp;n);    memset(cy,-1,sizeof(cy));    for(int i=1;i&lt;=n;i++)    {        int x,y;        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        maxx=max(maxx,y);        add(x,i);add(y,i);    }    int ans=0;    for(int i=1;i&lt;=maxx;i++)    {    //    memset(vis,0,sizeof(vis));        if(dfs(i))        {            ans++;        }        else break;    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>         <div id="aplayer-gWaUiYmW" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-gWaUiYmW"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3488</title>
    <link href="/2020/02/13/HDU-3488/"/>
    <url>/2020/02/13/HDU-3488/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-3488 Tour</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3488" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3488</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，n个点，m条有向边边(可能有重边)， 现在问将图中的每一个点都划分到一个环中的最少代价是多少？每条边都有一个代价 。即选择边，使得图是若干个有向环，除出发点(即终点)外每个点都只可以经过一次，如何选择花费最小？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这里需要提到一下<strong>有向环覆盖问题</strong>： 给一个N个顶点M条边的带权有向图，要你把该图分成一个或多个不相交的有向环。且所有定点都被有向环覆盖。问你该有向环所有权值的总和最小是多少? </p><p>答案就是：有向环最大权值覆盖=最佳匹配。 </p><p>如果，改为无向图，问你无向环最大权值覆盖？答案也是一样的。只是在建图的时候把有向改为无向即可。 </p><p><strong>分析</strong>：把任意一个顶点i分成连个点，即i和i‘，如果原图存在边i–&gt;j，那么二分图就存在i–&gt;j’</p><p><strong>引理</strong>： </p><p>①  如果原图能由多个不相交的有向环覆盖，那么二分图必然存在完备匹配。 二者互为充要条件 。即： 二分图存在完备匹配,那么原图必定能由几个不相交的有向环覆盖。</p><p>②  如果 即权值最大的有向环覆盖在数值上等于改图的最佳匹配值。原图存在权值最大的有向环覆盖，那么二分图的<strong>最佳匹配</strong>一定就是这个值。</p><p>因为该有向环覆盖对应了一个二分图的完备匹配,而该完备匹配的权值就等于该有向环覆盖的权值,所以最佳匹配不可能丢失该最大权值的匹配。 </p><p>(假设原图的有向环为(1-&gt;2-&gt;3-&gt;1) and(6-&gt;5-&gt;4-&gt;6),那么二分图的完备匹配就是1-&gt;2’ 2-&gt;3’ 3-&gt;1’ 6-&gt;5’ 5-&gt;4’ 4-&gt;6’)</p><p>(假设二分图的完备匹配是1-&gt;2’ 2-&gt;3’ 3-&gt;1’ 6-&gt;5’ 5-&gt;4’ 4-&gt;6’那么原图的有向环为(1-&gt;2-&gt;3-&gt;1) and (6-&gt;5-&gt;4-&gt;6))</p><p>由此，知道了如果一个二分图存在<strong>完备匹配</strong>，那么这个<strong>完备匹配</strong>一定是可以在原图构成有向环，题目既然给出了路径，并且一定可以组成有向环，那么二分图一定存在<strong>完备匹配</strong>，而且是求最小的代价，此时想到了KM是求<strong>最佳匹配</strong>，即边权最大的完备匹配，所以需要转换一下， 将边权转换为负值，初始化为-0x3f3f3f3f，然后wx也初始化为-0x3f3f3f3f，然后其余正常地跑KM，求得ans为最佳匹配，输出-ans即可</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=30000+5;const int maxm=200+5;int Map[maxm][maxm],visx[maxm],visy[maxm],wx[maxm],wy[maxm],cx[maxm],cy[maxm],T,n,m,minn;int dfs(int x){    visx[x]=1;    for(int i=1;i&lt;=n;i++)    {        if(!visy[i]&amp;&amp;Map[x][i]!=-0x3f3f3f3f)        {            int t=wx[x]+wy[i]-Map[x][i];            if(t==0)            {                visy[i]=1;                if(!cy[i]||dfs(cy[i]))                {                    cy[i]=x;                    cx[x]=i;                    return 1;                }            }            else             {                minn=min(minn,t);            }        }    }    return 0;}int KM(){    memset(cy,0,sizeof(cy));    memset(cx,0,sizeof(cx));    memset(visx,0,sizeof(visx));    memset(visy,0,sizeof(visy));    for(int i=1;i&lt;=n;i++)wx[i]=-0x3f3f3f3f;    memset(wy,0,sizeof(wy));    minn=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            wx[i]=max(wx[i],Map[i][j]);        }    }    for(int i=1;i&lt;=n;i++)    {        while(1)        {            memset(visx,0,sizeof(visx));            memset(visy,0,sizeof(visy));            minn=0x3f3f3f3f;            if(dfs(i))break;            for(int i=1;i&lt;=n;i++)            {                if(visx[i])                {                    wx[i]-=minn;                }            }            for(int i=1;i&lt;=n;i++)            {                if(visy[i])                {                    wy[i]+=minn;                }            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        if(cx[i]!=0)        {            ans+=Map[i][cx[i]];        }    }    return ans;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                Map[i][j]=-0x3f3f3f3f;        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            Map[a][b]=max(Map[a][b],-c);        }        int ans=KM();        printf(&quot;%d\n&quot;,-ans);    }    return 0;}</code></pre>        <div id="aplayer-HavhaRaR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-HavhaRaR"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>KM</tag>
      
      <tag>有向环覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3189</title>
    <link href="/2020/02/13/POJ-3189/"/>
    <url>/2020/02/13/POJ-3189/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-3189 Steady Cow Assignment</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3189" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3189</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>这道题的题意是真的很坑人啊，首先答案是求所有牛对居住的牛棚最大喜欢度-最小喜欢度+1，就是求区间长度，不是让求最大值-最小值。然后矩阵i，j不是表示第i头牛对第j个牛棚的喜欢度，而是表示第i头牛心中排名第j的牛棚是map[i][j]，喜欢度就是指牛棚在牛心中的排名。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>每个牛棚是有容纳量的，所以会用到多重匹配，而如何找到最小的区间长度呢？区间长度=所有牛对居住的牛棚最大喜欢度-最小喜欢度+1，那么求出最大值-最小值就可以了，求最值问题，很容易就想到二分了，但是光二分又不够，这时候枚举最小值就可以了，二分<strong>最大值-最小值的值</strong>，然后跑匈牙利算法的多重匹配，对每一条边的边权要判断：edge[i].w&gt;=minn&amp;&amp;edge[i].w&lt;-=maxx，并且注意容纳量。跑出的最大匹配如果==n，就说明所有的牛都又牛棚，就符合题意，于是右边界就可以缩小，否则左边界增大，直到找到ans，注意在枚举最小值的时候要更新答案minn，最后minn+1就是区间长度。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1500+5;int k=1,head[maxn],vis[maxn],cy[25][maxn],n,m,v[maxn];struct node{    int to,next,w;}edge[maxn*maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int dfs(int x,int minn,int maxx){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to]&amp;&amp;edge[i].w&gt;=minn&amp;&amp;edge[i].w&lt;=maxx)        {            vis[edge[i].to]=1;            if(cy[edge[i].to][0]&lt;v[edge[i].to])            {                cy[edge[i].to][0]++;                cy[edge[i].to][cy[edge[i].to][0]]=x;                return 1;            }            else             {                for(int j=1;j&lt;=cy[edge[i].to][0];j++)                {                    if(dfs(cy[edge[i].to][j],minn,maxx))                    {                        cy[edge[i].to][j]=x;                        return 1;                    }                }            }        }    }    return 0;}bool check(int minn,int maxx){    int ans=0;    for(int i=1;i&lt;=n;i++)    {        memset(vis,0,sizeof(vis));        ans+=dfs(i,minn,maxx);    }    return ans==n;}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=m;j++)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            add(i,x,j);        }    }    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d&quot;,&amp;v[i]);    }    int minn=0x3f3f3f3f;    for(int i=1;i&lt;=m;i++)    {        int l=0,r=m,ans=0x3f3f3f3f;        while(l&lt;=r)        {            memset(cy,0,sizeof(cy));            int mid=(l+r)/2;            if(check(i,i+mid))            {                ans=mid;                r=mid-1;            }            else             {                l=mid+1;            }        }        if(ans==0x3f3f3f3f)break;        minn=min(minn,ans);    }    printf(&quot;%d\n&quot;,minn+1);    return 0;}</code></pre>        <div id="aplayer-SFbvNIFt" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-SFbvNIFt"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>二分图(匈牙利算法-多重匹配)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2112</title>
    <link href="/2020/02/12/POJ-2112/"/>
    <url>/2020/02/12/POJ-2112/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-2112 Optimal Milking</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2112#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2112#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>FJ有K台挤奶机和C只奶牛。机器编号1<del>K，奶牛编号K+1</del>K+C。<br>机器一天工作M只奶牛。如何把奶牛分配给机器，使得奶牛到机器的最远距离最小。<br>奶牛可以进过某些机器，但不在那台机器上挤奶。奶牛也可以经过其他奶牛所在的位置。                     输出一个整数，表示走最远的奶牛的需要行走的最小距离。  </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>“最远的行走的最小距离”确认是二分，每一个机器一天可以工作M只奶牛显然是多重匹配。首先用Floyd跑出任意两点之间的最小距离，然后建图，奶牛–&gt;机器，边权为dist[奶牛][机器],当然建单向边，二分距离，跑匈牙利算法的时候，一旦edge[i].w&gt;Max(Max就是二分的距离)那么奶牛就不可以去edge[i].to机器，注意这是多重匹配。</p><p><strong>ps</strong>：WA了一次，比较奇怪r=200这样是错的，所以r=0x3f3f3f3f靠谱点。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=500+5;int k=1,head[maxn],vis[maxn],cy[maxn][maxn],n,c,m,dist[maxn][maxn];struct node{    int to,next,w;}edge[maxn*maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int dfs(int x,int Max){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to]&amp;&amp;edge[i].w&lt;=Max)        {            vis[edge[i].to]=1;            if(cy[edge[i].to][0]&lt;m)            {                cy[edge[i].to][0]++;                cy[edge[i].to][cy[edge[i].to][0]]=x;                return 1;            }            else             {                for(int j=1;j&lt;=cy[edge[i].to][0];j++)                {                    if(dfs(cy[edge[i].to][j],Max))                    {                        cy[edge[i].to][j]=x;                        return 1;                    }                }            }        }    }    return 0;}bool check(int mid){    int ans=0;    for(int i=n+1;i&lt;=n+c;i++)    {        memset(vis,0,sizeof(vis));        ans+=dfs(i,mid);    }    return ans==c;}int main(){    int l=0,r=0x3f3f3f3f,ans=0;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;c,&amp;m);    memset(dist,0x3f3f3f3f,sizeof(dist));    for(int i=1;i&lt;=n+c;i++)    {        for(int j=1;j&lt;=n+c;j++)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            if(i==j||x==0)continue;            dist[i][j]=x;        }    }    for(int k=1;k&lt;=n+c;k++)    {        for(int i=1;i&lt;=n+c;i++)        {            for(int j=1;j&lt;=n+c;j++)            {                if(i==j||i==k||k==j)continue;                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);            }        }    }    for(int i=1;i&lt;=n;i++)    {        for(int j=n+1;j&lt;=n+c;j++)        {            add(j,i,dist[j][i]);        }    }    while(l&lt;=r)    {        memset(cy,0,sizeof(cy));        int mid=(l+r)/2;        if(check(mid))        {            r=mid-1;            ans=mid;        }        else         {            l=mid+1;        }    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-RlTgpLau" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-RlTgpLau"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>最短路</tag>
      
      <tag>二分图(匈牙利算法-多重匹配)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2289</title>
    <link href="/2020/02/12/POJ-2289/"/>
    <url>/2020/02/12/POJ-2289/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-2289  Jamie’s Contact Groups </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2289" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2289</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> n个人，m个社交团体，一个人可能对应多个社交团体，但只能参加一个社交团体，问所有社交团体中人数最多的团体最少有多少人。 (N&lt;=1000,M&lt;=500)</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>“<strong>最多的最少</strong>“这是典型的二分的套路，由题可知：一个人可能对于多个社交团体。可以二分最多的团体的人数，每一个人向自己可参加的团体连一条<strong>有向边</strong>。</p><p>然后在跑匈牙利算法的时候，需要注意：</p><p>要记录这个团体对应了多少的成员了，以cy[edge[i].to][0]记录团体edge[i].to的人数，Max表示本次团队最多容纳人数，如果cy[edge[i].to][0]&lt;Max，直接加入这个团队即可，否则就从第一个成员到最后一个成员都找一次增广路。</p><p>每一次二分时，如果跑完匈牙利算法后，最大匹配==n，就缩小r，否则增大l。</p><p><strong>ps</strong>：题目给的团队从0开始，我自己对它+1了，所以从1开始。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;const int maxn=1000+5;const int maxm=15000+5;int k=1,head[maxn],vis[maxn],cy[maxn][505],n,m;struct node{    int to,next;    }edge[maxn*maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x,int Max){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(cy[edge[i].to][0]&lt;Max)            {                cy[edge[i].to][0]++;                cy[edge[i].to][cy[edge[i].to][0]]=x;                return 1;            }            else             {                for(int j=1;j&lt;=cy[edge[i].to][0];j++)                {                    if(dfs(cy[edge[i].to][j],Max))                    {                        cy[edge[i].to][j]=x;                        return 1;                    }                }            }        }    }    return 0;}bool check(int mid){    int ans=0;    for(int i=1;i&lt;=n;i++)    {        memset(vis,0,sizeof(vis));        ans+=dfs(i,mid);    }    if(ans==n)    return 1;    return 0;}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;m+n!=0)    {        k=1;        memset(head,0,sizeof(head));        memset(cy,0,sizeof(cy));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=n;i++)        {            char a[20];            scanf(&quot;%s&quot;,a);            while(1)            {                int x;char c;                scanf(&quot;%d%c&quot;,&amp;x,&amp;c);                x++;                add(i,x);                if(c==&#39;\n&#39;)                break;            }        }        int l=0,r=n,ans=0;        while(l&lt;=r)        {            memset(cy,0,sizeof(cy));            int mid=(l+r)/2;            if(check(mid))            {                r=mid-1;                ans=mid;            }            else             {                l=mid+1;            }        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-ncOxRXSI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ncOxRXSI"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>二分图(匈牙利算法-多重匹配)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3829</title>
    <link href="/2020/02/12/HDU-3829/"/>
    <url>/2020/02/12/HDU-3829/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-3829 Cat VS Dog</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3829" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3829</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一群小朋友去动物园，如果每个小朋友喜欢的动物是猫，那么不喜欢的动物一定是狗，反之也是。现在动物园的管理者要拿走一些动物，如果拿走的是某个小朋友不喜欢的动物，那这个小朋友就非常开心，反之，如果是某个小朋友喜欢的动物，这个小朋友就非常的不开心，问那完后最多有几个小朋友会非常开心。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是<strong>最大独立集</strong>的问题。这里需要讲解一样<strong>最大独立集</strong>。</p><p><strong>最小顶点覆盖</strong>：</p><p><strong>定义</strong>:假如选了一个点就相当于覆盖了以它为端点的所有边 。最小顶点覆盖就是选择最少的点来覆盖所有的边。 <strong>结论</strong>： <strong>最小顶点覆盖</strong>等于<strong>最大匹配</strong>。 </p><p> <img src="https://img2018.cnblogs.com/blog/1502540/201810/1502540-20181003114327352-650542909.png" srcset="/img/loading.gif" alt="img"> </p><p><strong>最大独立集：</strong> </p><p><strong>定义</strong>: 选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。  找出一个包含顶点数最多的独立集称为最大独立集。 <strong>结论</strong>： <strong>最大独立集 = 顶点个数 - 最小覆盖</strong> 。</p><p> <img src="https://img2018.cnblogs.com/blog/1502540/201810/1502540-20181003114344925-207551823.png" srcset="/img/loading.gif" alt="img"> </p><p>红点的选择：显然每一条非匹配边一定和匹配边有公共点，所以这样的公共点一定会被选出来，不可能作为最大独立集的元素。</p><p>这样就了解了<strong>最大独立集</strong>，将每一个人喜欢的动物和不喜欢的动物保存下来，1-C为猫，1+N-D+N为狗，如果一个人i喜欢的动物是人j讨厌的动物，那么i与j连双向边。显然如果甲喜欢的动物是乙讨厌的动物，那么甲、乙最多能有一个人高兴。最后求出最大匹配ans，注意ans/=2，这样ans代表的是有多少个人不可以高兴，n-ans就是高兴的人数。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=500+5;const int N=100;int C,D,n,k=1,head[maxn],cy[maxn],vis[maxn],l[maxn],h[maxn];struct node{    int to,next;}edge[maxn*maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;C,&amp;D,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        int tot=0;        for(int i=1;i&lt;=n;i++)        {            char x1,x2;int y1,y2;            cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;            l[i]=y1;h[i]=y2;            if(x1==&#39;D&#39;)l[i]+=N;            if(x2==&#39;D&#39;)h[i]+=N;        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(i==j)continue;                if(l[i]==h[j])                {                    add(i,j);                    add(j,i);                }            }        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        ans/=2;        printf(&quot;%d\n&quot;,n-ans);    }    return 0;}</code></pre>        <div id="aplayer-JrTVtdSi" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-JrTVtdSi"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最大独立集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2594</title>
    <link href="/2020/02/12/POJ-2594/"/>
    <url>/2020/02/12/POJ-2594/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-2594  Treasure Exploration </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2594" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2594</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在外星上有n个点需要机器人去探险，有m条单向路径。问至少需要几个机器人才能遍历完所有的点，一个点可以被多个机器人经过（这就是和单纯的最小路径覆盖的区别）。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这也是最小路径覆盖问题，但是这与最小不相交路径覆盖问题不同，这是最小相交路径覆盖问题，每个顶点可以经过多次。算法和最小不相交路径覆盖问题基本相同，但是需要用闭包传递预处理一下再建图。</p><p>闭包传递的原因：</p><p> <img src="https://pic002.cnblogs.com/images/2011/239942/2011073111520332.jpg" srcset="/img/loading.gif" alt="img"> </p><p>如图，如果不进行闭包传递，最终需要三条路径，但实际上3可以经过多次，只需要两条路径，如果1-&gt;2-&gt;3这条路径走了，4-&gt;2-&gt;5也是可以走的，于是就需要（1，3）合并，（4，5）合并，这就要用到闭包传递。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2500+5;const int maxm=500+5;int k=1,head[maxn],vis[maxn],dist[maxn][maxn],cy[maxn],n,m;struct node{    int to,next;}edge[maxm*maxm];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;} int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(1)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        k=1;        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        memset(dist,0,sizeof(dist));        memset(head,0,sizeof(head));        for(int i=1;i&lt;=m;i++)        {            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b]=1;        }        for(int w=1;w&lt;=n;w++)        {            for(int i=1;i&lt;=n;i++)            {                for(int j=1;j&lt;=n;j++)                {                    if(dist[i][w]&amp;&amp;dist[w][j])                    {                        dist[i][j]=1;                    }                }            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(dist[i][j]==1)                {                    add(i,j);                }            }        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;%d\n&quot;,n-ans);    }    return 0;}</code></pre><p><strong>ps</strong>：一开始一直WA，才发现自己的匈牙利算法的模板错了，我竟然一开始就vis[x]=1，关键这份模板还AC了10个题，我人都傻了。</p>        <div id="aplayer-wbbzTYpU" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-wbbzTYpU"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最小路径覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1151</title>
    <link href="/2020/02/11/HDU-1151/"/>
    <url>/2020/02/11/HDU-1151/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1151 Air Raid</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1151#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1151#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一个城镇有n个路口，由一些单向马路连接。现在要安排一些伞兵降落在某些路口上，清查所有的路口。一个伞兵可以沿着马路一路清查过去。清查过程中不能有两个伞兵同时清查一个路口（应该是为了防止暴露）。给定城镇的线路，求最少需要几个人伞兵就能清查所有的路口。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始看到这题，猜想入度为0则ans++，实则不对，出度大于1时就不对了。然后又猜想：建单向边，跑匈牙利算法求出最大匹配，n-ans就是最后的答案。事实证明这个思路是正确的。AC之后即去找了一份题解，这题就是最小路径覆盖问题。</p><p><strong>DAG的最小路径覆盖的定义</strong>： 在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。 </p><p>最小路径覆盖分为最小不相交路径覆盖和最小可相交路径覆盖。 </p><p>最小不相交路径覆盖：每一条路径经过的顶点各不相同。</p><p>最小可相交路径覆盖：每一条路径经过的顶点可以相同。</p><p><strong>DAG的最小不相交路径覆盖的算法</strong>： 把原图的每个点V拆成两个点Vx和Vy，如果有一条有向边A-&gt;B，那么就加边：Ax–&gt;By。这样就得到了一个二分图。那么最小路径覆盖=原图的结点数-新图的最大匹配数。 </p><p><strong>证明</strong>： 一开始每个点都是独立的为一条路径，总共有n条不相交路径。  每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了1。  所以找到了几条匹配边，路径数就减少了多少。 所以 <strong>最小路径覆盖=原图的结点数-新图的最大匹配数。</strong> </p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1200+5;int k=1,head[maxn],vis[maxn],cy[maxn],T,n,m;struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a,b);        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;%d\n&quot;,n-ans);    }    return 0;}</code></pre>        <div id="aplayer-GdMsTRmf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-GdMsTRmf"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最小路径覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1054</title>
    <link href="/2020/02/11/HDU-1054/"/>
    <url>/2020/02/11/HDU-1054/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1054 Strategic Game</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1054#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1054#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>Bob非常享受玩电脑游戏的过程，尤其是策略游戏，但是在有些时候，他因为不能在第一时间找到最佳的策略而十分伤心。 现在，他遇到了一个问题。他必须保卫一个中世纪的城市，有很多道路将整个城市连起来，整体上看上去像一棵树。Bob需要放置尽可能少的士兵，保卫树上所有的边。士兵只能放在节点上，但是却可以保卫所有与这个节点相邻的边。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题目要求很明确，就是要最少的点覆盖所有的边，即最小定点覆盖问题。 <strong>最小顶点覆盖要求用最少的点，让每条边都至少和其中一个点关联。即</strong>点集里面的点能覆盖所有的边 。</p><p><strong>knoig定理</strong>： <strong>二分图的最小顶点覆盖数=二分图的最大匹配数。</strong> </p><p><strong>证明</strong>：</p><p>要证明<strong>最小顶点覆盖数==最大匹配数</strong>，即证明<strong>最小顶点覆盖数&gt;=最大匹配数</strong>，并且<strong>最大匹配数&gt;=最小顶点覆盖数</strong>。设<strong>最小顶点覆盖数</strong>为S，<strong>最大匹配数</strong>为M。</p><p> <strong>①</strong> <strong>最小顶点覆盖数&gt;=最大匹配数</strong>：</p><p>假设最大匹配数为n，那么我们就得到了n条互不相邻的边，光覆盖这些边就至少需要n个顶点。由于最大匹配数为n，那么就可能存在一些边不在最大匹配的集合中，这样的话要覆盖这些边就还需要顶点，因此<strong>最小顶点覆盖数&gt;=最大匹配数</strong>。</p><p> <strong>②</strong> <strong>最大匹配数&gt;=最小顶点覆盖数</strong>：</p><p>假设匹配边a–&gt;b在最大匹配的集合中，如果a相连的边有未匹配点x，b相连的边有未匹配点y，那么x-a<strong>-</strong>b-y是一条增广路，而这就与M是<strong>最大匹配数</strong>矛盾了。所以a,b不可能同时相连为匹配点。</p><p>因此a，b中有非匹配边相连的点假设是a，那么选择a就可以覆盖a-b以及a-？(非匹配边)。并且M中没有孤立的非匹配边，每一条边一定会跟一个匹配点相连。这就意味着，每一个非匹配边的出发点一定同时连接了一条匹配边，这样非匹配边不可能单独存在。那么，从最大匹配边中选择M个点一定可以覆盖所有的边。所以<strong>最大匹配数&gt;=最小顶点覆盖数</strong>。</p><p>综上所述：<strong>最大匹配数==最小顶点覆盖数</strong>。</p><p>而此题就是要求最少的点将所有的边覆盖，就是<strong>最小点覆盖</strong>的模板题了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1500+5;int k=1,n,head[maxn],cy[maxn],vis[maxn];struct node{    int to,next;}edge[maxn*maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=n;i++)        {            int u,tot;            scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;tot);            for(int j=1;j&lt;=tot;j++)            {                int v;                scanf(&quot;%d&quot;,&amp;v);                add(u+1,v+1);add(v+1,u+1);            }        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        ans/=2;        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-XIvIDTdg" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-XIvIDTdg"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最小顶点覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3020</title>
    <link href="/2020/02/11/POJ-3020/"/>
    <url>/2020/02/11/POJ-3020/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-3020  Antenna Placement </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3020" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3020</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，每一组数据是hxw的矩阵，矩阵中的每一个方格有o或者*组成,问用1x2的矩阵 (横着或竖着都可以)来覆盖所有的 * ，问至少需要多少个这样的矩阵？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题和HDU4185 Oil Skimming 很相似。观察之后发现，将所有的 * 先预处理出它的编号，然后对于 * 的上下左右若为 * 就可以建边，然后跑匈牙利算法，求出最大匹配，对于这样求出来的最大匹配ans应该要÷2，即ans/=2，因为我们建的双向边。ans * 2表示的是已经覆盖了的点，temp-ans * 2就是剩余的美誉覆盖的点，这些点只能单独覆盖了，所以最终答案是 temp-ans * 2+ans。</p><p><strong>ps</strong>：WA了几次，注意 * 的数量&lt;=40 * 10=400，边就是400 * 400 * 4，数组要够，不然就是TLE或者WA。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=400+5;const int maxm=400*400+5;int T,n,m,k=1,head[maxn],s[maxn][maxn],cy[maxn],vis[maxn];char a[maxn][maxn];struct node{    int to,next;}edge[maxm*4];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        int temp=0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,a[i]);            for(int j=0;j&lt;=m-1;j++)            {                if(a[i][j]==&#39;*&#39;)                {                    s[i][j]=++temp;                }            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=0;j&lt;=m-1;j++)            {                if(a[i][j]==&#39;*&#39;)                {                    if(j&lt;=m-2&amp;&amp;a[i][j+1]==&#39;*&#39;)                    {                        add(s[i][j],s[i][j+1]);                    }                    if(j&gt;=1&amp;&amp;a[i][j-1]==&#39;*&#39;)                    {                        add(s[i][j],s[i][j-1]);                    }                    if(i&lt;=n-1&amp;&amp;a[i+1][j]==&#39;*&#39;)                    {                        add(s[i][j],s[i+1][j]);                    }                    if(i&gt;=2&amp;&amp;a[i-1][j]==&#39;*&#39;)                    {                        add(s[i][j],s[i-1][j]);                    }                }            }        }        int ans=0;        for(int i=1;i&lt;=temp;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        ans/=2;        int yu=temp-ans*2;        printf(&quot;%d\n&quot;,ans+yu);    }    return 0;}</code></pre>        <div id="aplayer-rARIcRuY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-rARIcRuY"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4185</title>
    <link href="/2020/02/11/HDU-4185/"/>
    <url>/2020/02/11/HDU-4185/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 4185  Oil Skimming </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4185" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4185</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有K组数据，每组数据是N*N的方阵，每个方格由.或者#组成，问有多少个互相不重叠的##(横着或竖着)。</p><p>  (1 &lt;= K &lt;= 100)  (1 &lt;= N &lt;= 600) </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最开始的思路是每个点只判断它下方或者右方是不是#，如果是就连边，但是这个方法存在一个问题：横着的##和竖着的##如果重叠会导致计数重复，又没有一个比较好的办法来规范。于是换了一个想法，一个点若为#就像它上下左右为#的点都连边，最后答案/2就可以避免重复。枚举所有的点，预处理#点的编号temp记录，然后开始跑匈牙利算法，最后ans/2.</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1200+5;const int maxm=360000+5;const int N=360000;int k=1,T,n,head[maxm],vis[maxm],cy[maxm],s[605][605];char a[605][605];struct node{    int to,next;}edge[maxm*4];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){     for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        opt++;        k=1;        memset(cy,0,sizeof(cy));        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(s,0,sizeof(s));        int temp=0;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,a[i]);            for(int j=0;j&lt;n;j++)            {                if(a[i][j]==&#39;#&#39;)                {                    s[i][j]=++temp;                }            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=0;j&lt;n;j++)            {                if(a[i][j]==&#39;#&#39;)                {                    if(j&lt;=n-2&amp;&amp;a[i][j+1]==&#39;#&#39;)                    {                        add(s[i][j],s[i][j+1]);                    }                    if(j&gt;=1&amp;&amp;a[i][j-1]==&#39;#&#39;)                    {                        add(s[i][j],s[i][j-1]);                    }                    if(i&lt;=n-1&amp;&amp;a[i+1][j]==&#39;#&#39;)                    {                        add(s[i][j],s[i+1][j]);                    }                    if(i&gt;=2&amp;&amp;a[i-1][j]==&#39;#&#39;)                    {                        add(s[i][j],s[i-1][j]);                    }                }            }        }        int ans=0;        for(int i=1;i&lt;=temp;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;Case %d: %d\n&quot;,opt,ans/2);    }    return 0;}</code></pre>        <div id="aplayer-dhNOucJz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-dhNOucJz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2389</title>
    <link href="/2020/02/10/HDU-2389/"/>
    <url>/2020/02/10/HDU-2389/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2389  Rain on your Parade </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2389" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2389</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，每组数据第一行是t，表示到t时下雨，第二行是m，表示有m个客人，接下来m行，每行3个数字，依次为x,y,v(速度)，然后是n，表示有n把伞，接下来n行，每行2个数字，依次为x，y，每一把伞只能由一个人使用，从开始每个客人出发拿伞，到t时间结束，问最多有几个人拿到了伞。   (1 &lt;= m，n &lt;= 3000) </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>1-m客人，N+1-N+n伞</p><p>依次枚举客人和伞，在规定时间内t*v&gt;=距离就可能拿到这把伞，就可以建边客人–&gt;伞。</p><p>一开始跑匈牙利算法，但是匈牙利算法时间复杂度较大，要TLE。</p><p>这时候需要用<strong>hopcroft-karp</strong>来优化，这里介绍一下<strong>hopcroft-karp</strong>：</p><p><strong>hopcroft-karp</strong>的时间复杂度为 <strong>O（n^0.5*m）</strong>。</p><p>思路：</p><p> HK算法分为三步 ：假设我们将集合分为两个，一个是左边的x集合，右面的y集合； </p><p> 1） ：首先x集合中没有匹配的元素入队列； </p><p> 2） ：以队列中的每一个元素作为起始点然后向他们相邻的点进行BFS就是在寻找增广路或者说是将其他的点根据我们的起始点来分层，如果与队列中的元素（x集合）相连的元素（y集合）没有匹配的话我们就找到了一条增广路（就是一个可能的匹配） </p><p> 3）如果这个元素与x集合中的元素匹配了那么我么就要将x集合中的元素入队列； </p><p> 假设我们有 1–2  1–3 1–4  2–5  2–6 3–5这六条边那么我们的HK算法过程是这样</p><p>集合   x ： 1    2     3</p><p>集合   y ：  2   3    4    5   6  </p><p> 1）在入队了的时候是 1  2  3  </p><p> 2）　　u=1　　 to:　　２　　３　　４　　因为ｙ集合中的２，３，４在ｘ集中没有匹配的元素所以找到了一条增广路 </p><p>​                              dy :　　１　　１　　１　 </p><p>​                u=2     to :     5     6         同上；</p><p>​                              dy:    1     1  </p><p>​                 u=3    to :     5 </p><p>​                             dy:     1 //             这里的深度是在2的时候就更新好了 </p><p>3）</p><p>最后就是朴素的匈牙利匹配算法了：首先1-2成功，2匹配5成功，3匹配5的时候不成功，但是我们我们可以将集合y中5的x集合中 的匹配元素2在找一个匹配正好找到y集合中的6，所以问题中的最大匹配是3 </p><h4 id="匈牙利算法代码："><a href="#匈牙利算法代码：" class="headerlink" title="匈牙利算法代码："></a>匈牙利算法代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=3000*3000+5;const int maxm=6000+5;const int N=3000;struct node{    int to,next;}edge[maxn];struct node1{    double v,x,y;}a[maxm];struct node2{    double x,y;}b[maxm];int k=1,head[maxn],t,T,n,m,cy[maxm],vis[maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        scanf(&quot;%d&quot;,&amp;t);        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%lf%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].v);        }        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%lf%lf&quot;,&amp;b[i].x,&amp;b[i].y);        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=n;j++)            {                if((sqrt((a[i].x-b[i].x)*(a[i].x-b[i].x)+(a[i].y-b[i].y)*(a[i].y-b[i].y)))&lt;=a[i].v*t)                {                    add(i,j+N);                }            }        }        int ans=0;        for(int i=1;i&lt;=m;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,ans);    }    return</code></pre><h4 id="hopcroft-karp算法的代码："><a href="#hopcroft-karp算法的代码：" class="headerlink" title="hopcroft-karp算法的代码："></a>hopcroft-karp算法的代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;const int maxn=3000*3000+5;const int maxm=6000+5;const int N=3000;struct node{    int to,next;}edge[maxn];struct node1{    int v,x,y;}a[maxm];struct node2{    int x,y;}b[maxm];int k=1,head[maxn],t,T,n,m,cy[maxm],dx[maxm],dy[maxm],cx[maxm];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(dy[edge[i].to]==dx[x]+1)        {            dy[edge[i].to]=0;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                cx[x]=edge[i].to;                return 1;            }        }    }    return 0;}int bfs(){    queue&lt;int&gt;q;    memset(dx,0,sizeof(dx));    memset(dy,0,sizeof(dy));    for(int i=1;i&lt;=m;i++)    {        if(!cx[i])            {            q.push(i);        }    }    int ans=0;    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!dy[edge[i].to])            {                dy[edge[i].to]=dx[x]+1;                if(!cy[edge[i].to])ans=1;                else                 {                    dx[cy[edge[i].to]]=dy[edge[i].to]+1;q.push(cy[edge[i].to]);                }            }        }    }    return ans;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        memset(cx,0,sizeof(cx));        scanf(&quot;%d&quot;,&amp;t);        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].v);        }        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d%d&quot;,&amp;b[i].x,&amp;b[i].y);        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(((a[i].x-b[j].x)*(a[i].x-b[j].x)+(a[i].y-b[j].y)*(a[i].y-b[j].y))&lt;=a[i].v*t*a[i].v*t)                {                    add(i,j+N);                }            }        }        int ans=0;        while(bfs())        {            for(int i=1;i&lt;=m;i++)            {                ans+=dfs(i);            }            }        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-PnUPSxoV" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-PnUPSxoV"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(hopcroft-karp)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2819</title>
    <link href="/2020/02/10/HDU-2819/"/>
    <url>/2020/02/10/HDU-2819/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2819 Swap</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2819" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2819</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个n*n的方阵，每一个格子(i,j)由0/1组成，问能否使得斜对角线即i==j,（i∈[1,n]），如果不能就输出-1，否则请输出方案。R表示交换行，C表示交换列。</p><hr><p><strong>这里有一点需要说明，就是说题目的交换，其实是将原来图的某一行移到最后图的某一行，而不是指先交换两行，得到一个新图，再交换新图的两行。</strong> </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>首先是关于能否得到斜对角线全为1的方阵，假如一个方阵的斜对角线全为1，那么这个方阵的秩为n，那么如果一个方阵的秩小于n那一定就不可以。那么如何得到方阵的秩呢？受到前面几个二分图的题的影响，凡是方格类的题目都可以将行和列分开，将数字为1的方格就行连边，即行i–&gt;列j，最后求最大匹配，一旦最大匹配为n那就可以，否则输出-1。由矩阵的运算性质可以知道，所有的列变换都可以用行变换来替代，所有的行变换都可以用列变换来替代，于是我们不妨全部都用列变换来替换，已知cy[i]表示第i列和cy[i]行来配对，从1-n列开始枚举，然后枚举得到第一个cy[j]==i的列，说明i列与j列应该替换，然后这一层循环就应该终止！必须终止！否则答案会变多。储存交换的列。最后一个个输出。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+5;const int maxm=100+5;const int N=100+5;int n,a[maxm][maxm],k=1,head[maxn],cy[maxn],l1[maxn],l2[maxn],vis[maxn]; struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;a[i][j]);            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(a[i][j])                {                    add(i,j+N);                }            }        }            int ans=0;            for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        if(ans==n)        {            int tot=0;            for(int i=1;i&lt;=n;i++)            {                for(int j=1;j&lt;=n;j++)                {                    if(cy[j+N]!=i)continue;                    if(i!=j)//交换i，j列                     {                        tot++;                        l1[tot]=i;l2[tot]=j;                        swap(cy[j+N],cy[i+N]);                        break;                    }                }            }            printf(&quot;%d\n&quot;,tot);            for(int i=1;i&lt;=tot;i++)            {                printf(&quot;C %d %d\n&quot;,l1[i],l2[i]);            }        }        else         {            printf(&quot;-1\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-neEFdoZU" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-neEFdoZU"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1281</title>
    <link href="/2020/02/10/HDU-1281/"/>
    <url>/2020/02/10/HDU-1281/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1281 棋盘游戏</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1281" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1281</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在N*M的棋盘上，在p个位置上允许放车，每一行每一列最多放一个车，并且在不允许放车的位置并不会影响车的攻击。重要点：要使车的数量最大，该点必须放车。问最多有多少个重要点、最多允许放多少个车？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题和Fire Net的区别在于，Fire Net不允许放置的点是一堵墙，会隔离攻击，而这道题不会影响攻击。所以Fire Net那道题需要进行分区域块，这样就可以分离开。但是这道题不会影响攻击，因此直接按点分，X集合为行，Y集合为列，只要当a[i][j]==1才可以让i行与j列连边，相当于点(i,j)可以放车。这样跑匈牙利算法可以得到最大匹配即最大的车的放置量。对于重要点的求解需要暴力求解，对于每一个可放置车的点需要去除它，然后跑匈牙利算法，如果最大匹配变小了，说明这是重要点，当然对于前向星链表，要记录出发点u，这样就可以进行标记了，vis数组不可以开大了，容易TLE。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int maxm=300+5;const int N=100+5;int head[maxn],k=1,n,m,p,a[maxm][maxm],cy[maxn],vis[maxm];struct node{    int to,next,u;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].u=u;}int dfs(int x,int sign1,int sign2){    for(int i=head[x];i;i=edge[i].next)    {        if(edge[i].to==sign2&amp;&amp;edge[i].u==sign1)continue;        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to],sign1,sign2))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p)!=EOF)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(a,0,sizeof(a));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=p;i++)        {            int X,Y;            scanf(&quot;%d%d&quot;,&amp;X,&amp;Y);            a[X][Y]=1;        }        int ans1=0,ans2=0,tot=0;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=m;j++)            {                if(a[i][j])                {                    add(i,j+N);                }            }        }        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans2+=dfs(i,0,0);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=m;j++)            {                ans1=0;                memset(cy,0,sizeof(cy));                for(int w=1;w&lt;=n;w++)                {                    memset(vis,0,sizeof(vis));                    ans1+=dfs(w,i,j+N);                }                if(ans1!=ans2)                    tot++;            }        }        printf(&quot;Board %d have %d important blanks for %d chessmen.\n&quot;,opt,tot,ans2);    }    return 0;}</code></pre>        <div id="aplayer-DdKRMeXt" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DdKRMeXt"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1083</title>
    <link href="/2020/02/09/HDU-1083/"/>
    <url>/2020/02/09/HDU-1083/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 1083Courses</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1083#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1083#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 一共有N个学生跟P门课程,一个学生可以任意选一 门或多门课,问是否达成:</p><p>1.每个学生选的都是不同的课(即不能有两个学生选同一门课)</p><p>2.每门课都有一个代表(即P门课都被成功选过)</p><p> 若能满足上面两个要求这输出”YES”,否则为”NO”  注意：是课程匹配的学生，学生没课上没事….. </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最终问题就是问能否所有的课程都被人选，并且没有两个及以上的人选同一门课。换言之，二分图的最大匹配数是否==p。建图时课程–&gt;学生，课程(1-P)，学生(N+1-N+n)，跑匈牙利算法。</p><p><strong>ps</strong>：数组开小了不会RE，它会TLE！因为一开始只开了10000的边，实际上时100*300，然后TLE了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=30000+5;const int N=300+5;struct node{    int to,next;}edge[maxn*2];int k=1,T,p,n,head[maxn],vis[maxn],cy[maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        scanf(&quot;%d%d&quot;,&amp;p,&amp;n);        for(int i=1;i&lt;=p;i++)        {            int num;            scanf(&quot;%d&quot;,&amp;num);            for(int j=1;j&lt;=num;j++)            {                int x;                scanf(&quot;%d&quot;,&amp;x);                add(i,x+N);            }        }        int ans=0;        for(int i=1;i&lt;=p;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        if(ans==p)        {            printf(&quot;YES\n&quot;);        }        else         {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-aZHjORXe" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-aZHjORXe"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2444</title>
    <link href="/2020/02/09/HDU-2444/"/>
    <url>/2020/02/09/HDU-2444/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 2444 The Accomodation of Students</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2444#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2444#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个关系，他们之间某些人相互认识。这样的人有m对。<br>你需要把人分成2组，使得每组人内部之间是相互不认识的。<br>如果可以，就可以安排他们住宿了。安排住宿时，住在一个房间的两个人应该相互认识。<br>最多的能有多少个房间住宿的两个相互认识。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题分为两个问题，第一个问题就是问是否可以分成两组，每一组内部任意两人都互相不认识；第二个问题是最多有几组两人之间相互认识，注意一人只能选择一次。第一个问题很显然就是判断这个图是否可以形成一个二分图，第二个问题是在该图是二分图的条件下的最大匹配数。二分图的判断方法就染色法，用bfs，将相邻的点全部染成相反的颜色，一旦该点与相邻点颜色相同就说明不能形成二分图，最后如果无矛盾就说明可以形成二分图。注意我们建图全部小–&gt;大，而条件给的数据也是如此，这样一定是从小的点出发，bfs起点就为1。求最大匹配时候，我们注意这图是单向的所以直接跑匈牙利。当然保险的是建双向边，求出最大匹配后，注意ans/2就可以了，因为对称，1认识2 与 2认识1 属同一情况。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;struct node{    int to,next;}edge[maxn*2];int k=1,head[maxn],vis[maxn],cy[maxn],n,m;void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}bool bfs(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(vis[edge[i].to]==vis[x])return 0;            if(vis[x]==1)vis[edge[i].to]=2;            else vis[edge[i].to]=1;            q.push(edge[i].to);        }    }    return 1;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        k=1;        memset(edge,0,sizeof(edge));        memset(head,0,sizeof(head));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=m;i++)        {            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a,b);        }        int pd=bfs();        if(pd==0)        {            printf(&quot;No\n&quot;);            continue;        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-kLJOXWFg" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-kLJOXWFg"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1045</title>
    <link href="/2020/02/09/HDU-1045/"/>
    <url>/2020/02/09/HDU-1045/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 1045 Fire Net</p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://vjudge.net/problem/HDU-1045#author=Codeblocksm" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1045#author=Codeblocksm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 现在有一个N*N的地图，地图上有一些围墙。你的任务是在没有围墙的空白地方建尽可能多的炮台。 假设炮台可以向“上下左右”四个方向发射子弹，子弹可以穿越任何距离并可在途中摧毁一个另一个炮台。而墙壁结构坚固，可以阻止子弹。 问最多可以建设多少个炮台？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>刚开始做二分图的最大匹配问题，没有什么思路啊，没想到如何将一块区域弄来建图，后来看了一下别人的思路，将同一列的联通区域求出来，当然同一联通区域有且只有一个炮台，否则不合题意；将同一行的联通区域求出来，也只能存在一个炮台。如何将列和行结合起来呢？然后列中第i个连通块与行中第j个连通块有交点，说明交点处可以建炮台，判断方法：y[j].h&gt;=x[i].s&amp;&amp;y[j].h&lt;=x[i].t&amp;&amp;x[i].l&gt;=y[j].s&amp;&amp;x[i].l&lt;=y[j].t。那么可以add(i,j+N)。这样建了图后用匈牙利算法来求最大匹配就可以了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;const int N=500;char a[maxn][maxn];int vis[maxn],cy[maxn],n,k=1,head[maxn];struct node1{    int l,s,t;}x[maxn];//表示列块 struct node2{    int h,s,t;}y[maxn];//表示行块 struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int check(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||check(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=0)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        memset(a,0,sizeof(a));        memset(x,0,sizeof(x));        memset(y,0,sizeof(y));        int tot1=0,tot2=0;        for(int i=1;i&lt;=n;i++)            scanf(&quot;%s&quot;,a[i]+1);        for(int i=1;i&lt;=n;i++)        {            int s=1;            while(s&lt;=n)            {                if((s&gt;1&amp;&amp;a[s-1][i]==&#39;X&#39;&amp;&amp;a[s][i]==&#39;.&#39;)||(s==1&amp;&amp;a[s][i]==&#39;.&#39;))                {                    tot1++;                    x[tot1].l=i;x[tot1].s=s;x[tot1].t=s;                }                if(a[s][i]==&#39;.&#39;)x[tot1].t=s;                s++;            }        }        for(int i=1;i&lt;=n;i++)        {            int s=1;            while(s&lt;=n)            {                if((s&gt;1&amp;&amp;a[i][s-1]==&#39;X&#39;&amp;&amp;a[i][s]==&#39;.&#39;)||(s==1&amp;&amp;a[i][s]==&#39;.&#39;))                {                    tot2++;                    y[tot2].h=i;y[tot2].s=s;y[tot2].t=s;                }                if(a[i][s]==&#39;.&#39;)y[tot2].t=s;                s++;            }        }        for(int i=1;i&lt;=tot1;i++)        {            for(int j=1;j&lt;=tot2;j++)            {                if(y[j].h&gt;=x[i].s&amp;&amp;y[j].h&lt;=x[i].t&amp;&amp;x[i].l&gt;=y[j].s&amp;&amp;x[i].l&lt;=y[j].t)                {                    add(i,j+N);                }            }        }        int ans=0;        for(int i=1;i&lt;=tot1;i++)        {            memset(vis,0,sizeof(vis));            ans+=check(i);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-pQUZebtM" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-pQUZebtM"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2255</title>
    <link href="/2020/02/09/HDU-2255/"/>
    <url>/2020/02/09/HDU-2255/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2255  奔小康赚大钱 </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2255#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2255#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>n个居民n个房子，每个居民会给不同的房子不同的钱，问如何分配使得钱最多？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>KM的模板题，KM的具体介绍由blog的KM讲解中提供</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300+5;int Map[maxn][maxn],visx[maxn],visy[maxn],cx[maxn],cy[maxn],n,wx[maxn],wy[maxn],minn;int dfs(int x){    visx[x]=1;    for(int i=1;i&lt;=n;i++)    {        if(!visy[i]&amp;&amp;Map[x][i]!=0x3f3f3f3f)        {            int t=wx[x]+wy[i]-Map[x][i];            if(t==0)            {                visy[i]=1;                if(!cy[i]||dfs(cy[i]))                {                    cy[i]=x;                    cx[x]=i;                    return 1;                }                    }            else             {                minn=min(minn,t);            }        }    }    return 0;}int KM(){    memset(visx,0,sizeof(visx));    memset(visy,0,sizeof(visy));    memset(cx,0,sizeof(cx));    memset(cy,0,sizeof(cy));    memset(wx,0,sizeof(wx));    memset(wy,0,sizeof(wy));    minn=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(Map[i][j]!=0x3f3f3f3f)            {                wx[i]=max(wx[i],Map[i][j]);            }        }    }    for(int i=1;i&lt;=n;i++)    {        while(1)        {            memset(visx,0,sizeof(visx));            memset(visy,0,sizeof(visy));            minn=0x3f3f3f3f;            if(dfs(i))break;            for(int i=1;i&lt;=n;i++)            {                if(visx[i])                {                    wx[i]-=minn;                }            }            for(int i=1;i&lt;=n;i++)            {                if(visy[i])                {                    wy[i]+=minn;                }            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        if(cx[i]!=0)ans+=Map[i][cx[i]];    }    return ans;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(Map,0x3f3f3f3f,sizeof(Map));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;Map[i][j]);            }        }        int ans=KM();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-tGjlAsiQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-tGjlAsiQ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>KM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KM算法详解</title>
    <link href="/2020/02/09/KM%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/02/09/KM%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h1><p>以<strong><em>匈牙利算法</em></strong>为基础，改善后用于求解带权二分图的<strong><em>最佳匹配</em></strong>问题</p><h2 id="完备匹配："><a href="#完备匹配：" class="headerlink" title="完备匹配："></a>完备匹配：</h2><p>如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，<strong>或者</strong>Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。 </p><h2 id="完美匹配："><a href="#完美匹配：" class="headerlink" title="完美匹配："></a>完美匹配：</h2><p>若二分图X部的每一个顶点都与Y中的一个顶点匹配，<strong>并且</strong>Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完美匹配。 </p><p>即： 一个二分图，X部和Y部的顶点数相等，存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。  </p><h2 id="最大权匹配："><a href="#最大权匹配：" class="headerlink" title="最大权匹配："></a>最大权匹配：</h2><p>带权二分图的边权重和最大的匹配，如图，最大和为102</p><p> <img src="https://img-blog.csdnimg.cn/20181105155320651.png" srcset="/img/loading.gif" alt="img"> </p><h2 id="最佳匹配："><a href="#最佳匹配：" class="headerlink" title="最佳匹配："></a>最佳匹配：</h2><p>带权二分图的边权重和最大的完备匹配，如图</p><p> <img src="https://img-blog.csdnimg.cn/2018110515570130.png" srcset="/img/loading.gif" alt="img"> </p><p>显然最大权匹配和最佳匹配不完全相同，最大权匹配由于不一定是最大匹配，所以无法等同于最佳匹配。</p><p>但是如果把剩余的边补上，并且设置边权为0，那么二者可以统一起来。如图</p><p> <img src="https://img-blog.csdnimg.cn/20181105160925184.png" srcset="/img/loading.gif" alt="img"> </p><h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><p>km算法用于求最佳匹配，而不是最大权匹配。换言之，km算法用来求完备匹配下的最大权匹配。</p><p><u>如果不存在完备匹配，km算法会求最大匹配，如果最大匹配存在多种，那么结果就是最大匹配中权重和最大的。</u></p><hr><p>在一个二分图中，左顶点为X，右顶点为Y，现在对于每组左右连接XiYi有权Wij，求最大匹配，并且使得该匹配中所有Wij的和最大。</p><p>该算法通过给每一个顶点一个标号(称为顶标)来把求最大权匹配的问题转换为求完备匹配的问题。</p><p>设顶点Xi的顶标为A[i]，顶点Yi的顶标为B[i]，顶点Xi和Yi之间的边权为W[i][j]，在整个过程中任意一条边&lt;i,j&gt;，始终满足A[i]+B[j]&gt;=W[i][j].</p><h2 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h2><p>图G中每一条边有左右两个顶标，<strong><em>相等子图</em></strong>就是那些顶标和等于边权重的边构成的子图，如图例</p><p> <img src="https://img-blog.csdnimg.cn/20181105162845589.png" srcset="/img/loading.gif" alt="img"> </p><h2 id="KM算法的正确性"><a href="#KM算法的正确性" class="headerlink" title="KM算法的正确性"></a>KM算法的正确性</h2><p><strong>定理</strong>：若二分图中，A[i]+B[j]&gt;=W[i][j],并且存在某个相等子图有完备匹配，那么这个完备匹配就是二分图的最大权匹配</p><p><strong>证明</strong>：因为这个完备匹配存在于相等子图中，因此，这个匹配所有边满足于：A[i]+B[j]==W[i][j],同时由于完备匹配包含所有的顶点，因此这个属于相等子图的完备匹配的总权重等于所有顶标的和。</p><p>如果这个二分图存在另外一个完备匹配，如果它不完全属于相等子图，即存在某条边：A[i]+B[j]&gt;W[i][j],那么该匹配的权重和就小于所有顶标的和，即小于上述属于相等子图的完备匹配的权重和。</p><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ul><li><p>首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。</p><p><img src="https://img-blog.csdnimg.cn/20181105161921533.png" srcset="/img/loading.gif" alt="img"> </p></li><li><p>对于X部中的每个顶点，在<strong><em>相等子图</em></strong>中利用<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">匈牙利算法</a>找一条<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">增广路径</a>，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配是最大权重的完备匹配，即为二分图的最佳匹配。</p><p><strong>匈牙利算法</strong>对左边第一个顶点，在<strong><em>相等子图</em></strong>中进行增广路径搜索，找到路径1-C后进行<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">匹配增广操作</a>，如下图所示 </p><p><img src="https://img-blog.csdnimg.cn/20181105163243917.png" srcset="/img/loading.gif" alt="img"> </p></li></ul><p>接着<strong>匈牙利算法</strong>对左边第二个顶点，在<strong><em>相等子图</em></strong>中进行增广路径搜索，结果是没有找到增广路径！这时需要修改顶标值，<strong>扩大</strong>相等子图，左边的顶标减少d，右边的顶标增加d，这里产生两个问题： </p><ul><li>哪些顶标需要修改</li><li>d是多少</li></ul><p><strong>question1：</strong> 注意在保持相等子图原来的边符合相等子图要求的同时，让新加的边也满足相等子图的要求。 </p><p>那么在增广路径搜索时，我们知道，如果下面这些紫色边任意一条加入相等子图后，都可以在相等子图中使用<strong>匈牙利算法</strong>找到一条增广路径2-A（or 2-B or 2-C-1-A）： </p><p> <img src="https://img-blog.csdnimg.cn/20181105165825707.png" srcset="/img/loading.gif" alt="img"> </p><p><strong>question2</strong>： <strong>KM算法</strong>选择上述三条紫色边中，顶标和与边权重差值最小的边1-A或者2-A，以该最小差值为d </p><p><strong>ps</strong>： 为什么选最小那个 ？</p><p><strong>回答</strong>：如果比这个还小就不能扩大相等子图了，如果大了，就不能保证A[i]+B[j]&gt;=W[i][j]总是成立了。 比如上图选择了2-B边 ，则差值d就为2，1-A就有A[i]+B[j]=2+0&lt;3=W[i][j].</p><p><strong>KM算法</strong>中需要修改的顶标是<strong>匈牙利算法</strong>增广路径搜索时，产生一棵交错树，为了保证A[i]+B[j]&gt;=W[i][j]总是成立，交错树上所有的顶标都需要进行修改。</p><p>比如在第二个顶点搜索增广路时，产生如图所示的橙色顶标集合{1,2,C}</p><p> <img src="https://img-blog.csdnimg.cn/20181105165032976.png" srcset="/img/loading.gif" alt="img"> </p><p> <strong>修改顶标</strong>后产生如下图所示的结果： </p><p> <img src="https://img-blog.csdnimg.cn/20181105183106680.png" srcset="/img/loading.gif" alt="img"> </p><p> 在该相等子图上以顶点2为开始点，<strong>搜索增广路径</strong>2-A（or 2-C-1-A），<strong>进行增广</strong>操作: </p><p> <img src="https://img-blog.csdnimg.cn/20181105183544455.png" srcset="/img/loading.gif" alt="img"> </p><p> 同样对左边第三个点： </p><p> <img src="https://img-blog.csdnimg.cn/20181105185155651.png" srcset="/img/loading.gif" alt="img"> </p><p><strong>ps</strong>:为什么修改橙色顶标而不去修改顶标A(找到最小差对应的边的右边顶标)？修改顶标A的值为-1， 那么边1-A也可以加入<strong>相等子图</strong>了。但是这样就无法保证A[i]+B[j]&gt;=W[i][j]恒成立了。如下图所示结果，修改顶标A，边3-A就不满足该条件了。除非在修改顶标A的同时，增加顶标3的值，但是需要修改的顶标集合需要额外的搜索算法，而修改橙色顶标所需要的<strong>交错树</strong>在增广路径搜索时可以一并产生。 </p><p> <img src="https://img-blog.csdnimg.cn/20181106152548762.png" srcset="/img/loading.gif" alt="img"> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300+5;int Map[maxn][maxn],visx[maxn],visy[maxn],cx[maxn],cy[maxn],n,wx[maxn],wy[maxn],minn;int dfs(int x){    visx[x]=1;    for(int i=1;i&lt;=n;i++)    {        if(!visy[i]&amp;&amp;Map[x][i]!=0x3f3f3f3f)        {            int t=wx[x]+wy[i]-Map[x][i];            if(t==0)            {                visy[i]=1;                if(!cy[i]||dfs(cy[i]))                {                    cy[i]=x;                    cx[x]=i;                    return 1;                }                    }            else             {                minn=min(minn,t);            }        }    }    return 0;}int KM(){    memset(visx,0,sizeof(visx));    memset(visy,0,sizeof(visy));    memset(cx,0,sizeof(cx));    memset(cy,0,sizeof(cy));    memset(wx,0,sizeof(wx));    memset(wy,0,sizeof(wy));    minn=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(Map[i][j]!=0x3f3f3f3f)            {                wx[i]=max(wx[i],Map[i][j]);            }        }    }    for(int i=1;i&lt;=n;i++)    {        while(1)        {            memset(visx,0,sizeof(visx));            memset(visy,0,sizeof(visy));            minn=0x3f3f3f3f;            if(dfs(i))break;            for(int i=1;i&lt;=n;i++)            {                if(visx[i])                {                    wx[i]-=minn;                }            }            for(int i=1;i&lt;=n;i++)            {                if(visy[i])                {                    wy[i]+=minn;                }            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        if(cx[i]!=0)ans+=Map[i][cx[i]];    }    return ans;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(Map,0x3f3f3f3f,sizeof(Map));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;Map[i][j]);            }        }        int ans=KM();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-PcMRKUlG" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-PcMRKUlG"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>KM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu-3386</title>
    <link href="/2020/02/08/luogu-3386/"/>
    <url>/2020/02/08/luogu-3386/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>luogu-P3386 二分图匹配模板</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://www.luogu.com.cn/problem/P3386" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3386</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定一个二分图，结点个数分别为n,m，边数为e，求二分图最大匹配数 </p><p> 因为数据有坑，可能会遇到 v&gt;m 或者 u&gt;n的情况。请把 v&gt;m 或者 u&gt;n的数据自觉过滤掉。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是二分图最大匹配匹配的模板题。</p><p>这里简述一下二分图的匈牙利算法：</p><p>给出下图，要求最大匹配数</p><p> <img src="https://img-blog.csdn.net/20130503155150538" srcset="/img/loading.gif" alt="img"> </p><p> 匈牙利算法的工作模式 如下：</p><p> <strong>一：</strong> 先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，got it，连上一条蓝线 </p><p> <img src="https://img-blog.csdn.net/20130503155256629" srcset="/img/loading.gif" alt="img"> </p><p> <strong>二</strong>：接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主，got it  <img src="https://img-blog.csdn.net/20130503155344972" srcset="/img/loading.gif" alt="img"> </p><p> <strong>三</strong>：接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？ </p><p> 我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。 </p><p> (黄色表示这条边被临时拆掉) </p><p> <img src="https://img-blog.csdn.net/20130503155428908" srcset="/img/loading.gif" alt="img"> </p><p> 与1号男生相连的第二个女生是2号女生，但是2号女生也有主了，怎么办呢？我们再试着给2号女生的原配  重新找个妹子 </p><p> <img src="https://img-blog.csdn.net/20130503155441032" srcset="/img/loading.gif" alt="img"> </p><p> 此时发现2号男生还能找到3号女生，那么之前的问题迎刃而解了，回溯回去 ：</p><p> 2号男生可以找3号妹子     </p><p> <img src="https://img-blog.csdn.net/20130503155453501" srcset="/img/loading.gif" alt="img"> </p><p>  1号男生可以找2号妹子了 </p><p> <img src="https://img-blog.csdn.net/20130503155626560" srcset="/img/loading.gif" alt="img"> </p><p> 3号男生可以找1号妹子 </p><p> <img src="https://img-blog.csdn.net/20130503162147840" srcset="/img/loading.gif" alt="img"> </p><p> 所以第三步最后的结果就是： </p><p> <img src="https://img-blog.csdn.net/20130503160156253" srcset="/img/loading.gif" alt="img"> </p><p> <strong>四</strong>： 接下来是4号男生，很遗憾，按照第三步的节奏我们没法给4号男生腾出来一个妹子 。</p><p>综上所诉：</p><p>我们对于左边(即X集合)每一个点都进行一次dfs，寻找可匹配的点(Y集合)，注意每一轮的dfs每一个点只可遍历一次，对于vis数组每轮开始要清空，然后遍历时，注意!girl[edge[i].to]||check(girl[edge[i].to])意味着有增广路，也就是说匹配数可以增加1.此时Y集合对应的X集合的点就变了。、</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000000+5;struct node{    int to,next;}edge[maxn];int n,m,e,vis[maxn],girl[maxn],head[maxn],k=1;void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int check(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!girl[edge[i].to]||check(girl[edge[i].to]))            {                girl[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;e);    for(int i=1;i&lt;=e;i++)    {        int u,v;        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        if(u&gt;n||v&gt;m)continue;        add(u,v+n);    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        memset(vis,0,sizeof(vis));        ans+=check(i);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-rvzMRrPN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-rvzMRrPN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3416</title>
    <link href="/2020/02/07/HDU-3416/"/>
    <url>/2020/02/07/HDU-3416/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-3416 Marriage Match IV</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3416" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3416</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> n 个点 m 条边带权有向图，问每条边最多只能走一次时从 A 到 B 的最短路径数量。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>问题是问从s–&gt;t有多少种完全不同的最短路径。首先要想办法找到哪些边属于最短路径里面的边，于是先正向跑一遍spfa，再反向跑一遍spfa，设smin为s–&gt;t的最短路的长度，那如果一条边属于最短路，那它一定满足dist1[x[i]]+dist2[y[i]]+w[i]==smin&amp;&amp;x[i]!=y[i]。这样就可以找到最短路径的所有边，然后建边时注意，x[i]–&gt;y[i],边权为1，跑dinic，得到的最大流ans就是答案。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200010+5;int T,n,m,s,t,head[maxn],dist2[maxn],dist1[maxn],vis[maxn],k=1,k2=1,head2[maxn],deep[maxn],x[maxn],y[maxn],w[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa1(int s)//dist1[i]表示从A--i的距离,spfa1跑正边 {    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist1,0x3f3f3f3f,sizeof(dist1));    dist1[s]=0;vis[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)            {                dist1[edge[i].to]=dist1[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void spfa2(int s)//dist2[i]表示从i--B的距离,spfa2跑反边 {    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist2,0x3f3f3f3f,sizeof(dist2));    dist2[s]=0;vis[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)            {                dist2[edge[i].to]=dist2[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    q.push(s);deep[s]=1;    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}int dinic(){    int ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }    return ans;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(x,0,sizeof(x));        memset(y,0,sizeof(y));        memset(w,0,sizeof(w));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;x[i],&amp;y[i],&amp;w[i]);        }        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);        for(int i=1;i&lt;=m;i++)        {            add(x[i],y[i],w[i]);        }        spfa1(s);        int smin=dist1[t];        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=m;i++)        {            add(y[i],x[i],w[i]);        }        spfa2(t);        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=m;i++)        {        //    cout&lt;&lt;dist1[x[i]]&lt;&lt;&#39; &#39;&lt;&lt;dist2[y[i]]&lt;&lt;&#39; &#39;&lt;&lt;w[i]&lt;&lt;&#39; &#39;&lt;&lt;smin&lt;&lt;endl;            if(dist1[x[i]]+dist2[y[i]]+w[i]==smin&amp;&amp;x[i]!=y[i])            {                add(x[i],y[i],1);add(y[i],x[i],0);            }        }        int ans=dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-kNwjGNLu" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-kNwjGNLu"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu-2764</title>
    <link href="/2020/02/07/luogu-2764/"/>
    <url>/2020/02/07/luogu-2764/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>luogu2764-最小路径覆盖问题</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定有向图 G=(V,E)<em>G</em>=(<em>V</em>,<em>E</em>) 。设 P是 G 的一个简单路(顶点不相交)的集合。如果 V 中每个定点恰好在P<em>P</em>的一条路上，则称 P 是 G的一个路径覆盖。P<em>P</em>中路径可以从 V 的任何一个定点开始，长度也是任意的，特别地，可以为 0 。G 的最小路径覆盖是 G所含路径条数最少的路径覆盖。设计一个有效算法求一个 GAP (有向无环图) G的最小路径覆盖 </p><p> 从第1 行开始，每行输出一条路径。文件的最后一行是最少路径数。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>要求的是最少路径数将所有的点都覆盖掉。</p><p>由konig定理知：最小点覆盖=最大匹配数；<br>而该题抽出模型就成了：最小路径覆盖；<br>最小路径覆盖=点数-最大匹配数；</p><p>如何理解这个结论呢？(这个解释并不严谨，只是为了帮助理解，请勿喷)<br>    加入1–&gt;2–&gt;3;<br>    可以转化为1–&gt;2’;2–&gt;3’;<br>    1,2,3在X中，1’,2’,3’在Y中；路径数=3-2；符合结论；<br>    再举例1–&gt;2,1–&gt;3,2–&gt;4,3–&gt;4;<br>    可以转化为1–&gt;2’,1–&gt;3’,2–&gt;4’,3–&gt;4’;最大匹配数为2；最少路径数为2.符合结论<br>由上面的例子可以分析一下：<br>    x与x’都处于匹配边中时，说明点x处于一条路径中；而一条路径中的开头点与结尾点的x和x’只能选择其中一个。此时(该路径中的)点个数-边数=1;<br>那么有多少个“1”就说明有多少条路径。就可以说明最小路径覆盖=点数-最大匹配数；</p><p>证明了以上的结论后，就可以考虑建模了：<br>    把一个点拆成x，x’，s向所有的x连边，所有的x’ 向t连边， 如果x1–&gt;y1，就将x1向y1’连边，所有的边容量为1(反边容量为0)；<br>    然后开始跑最大流，实际上跑出来的最大流就是最大匹配数，那么最小边覆盖=n-ans；<br>接着要开始说明每一条路径：<br>    从1-n都枚举一边，每一个点连向的是x’,并且如果最大流流向了x’(流向了x’就说明该边流量为0），然后输出该值，继续dfs。<br>    注意要排除s，t的点；</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt; using namespace std;const int maxn=600000+5;int n,m,k=1,head[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int s,t,ans,deep[maxn];bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(edge[i].w&amp;&amp;!deep[edge[i].to])            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    if(deep[t])return 1;    return 0;}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;            }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int vis[maxn];void work(int x){    for(int i=head[x];i;i=edge[i].next)    {        int TO=edge[i].to;        if(TO&gt;2*n)continue;        if(TO&gt;n)TO-=n;        if(edge[i].w==0&amp;&amp;!vis[TO])        {            int x=edge[i].to;            if(x&gt;n)x-=n;            cout&lt;&lt;x&lt;&lt;&#39; &#39;;            vis[x]=1;            work(x);        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    s=2*n+1;t=s+1;    for(int i=1;i&lt;=n;i++)add(s,i,1),add(i,s,0);    for(int i=1;i&lt;=m;i++)    {        int a,b;        cin&gt;&gt;a&gt;&gt;b;        add(a,b+n,1);add(b+n,a,0);    }    for(int i=1;i&lt;=n;i++)add(i+n,t,1),add(t,i+n,0);    dinic();    for(int i=1;i&lt;=n;i++)    {        if(!vis[i])        {            vis[i]=1;            cout&lt;&lt;i&lt;&lt;&#39; &#39;;            work(i);            cout&lt;&lt;endl;        }    }    cout&lt;&lt;n-ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-kWJUfQNA" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-kWJUfQNA"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3336</title>
    <link href="/2020/02/07/HDU-3336/"/>
    <url>/2020/02/07/HDU-3336/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3336 Count the string</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3336#author=cust_acm" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3336#author=cust_acm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个字符串，求它所有子串(包括自身)出现的总次数之</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>该题目需要比较完善地理解Next数组地含义与作用。当匹配到i失败时，就会返回到Next[i]。则匹配到i时，应该记录了子串s[0…i]，以及与子串s[0…Next[i]]。于是就可以得到动态转移方程dp[i]=dp[Next[i]]+1.然后求和dp数组，同时取模。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;const int Mod=10007;int T,len1,len2,Next[maxn],dp[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        int ans=0;        memset(s2,0,sizeof(s2));        memset(Next,0,sizeof(Next));        memset(dp,0,sizeof(dp));        scanf(&quot;%d&quot;,&amp;len2);        scanf(&quot;%s&quot;,s2);        next_pre();        for(int i=1;i&lt;=len2;i++)        {            if(Next[i]!=-1)                dp[i]=dp[Next[i]]+1;        }        for(int i=1;i&lt;=len2;i++)            ans=(ans+dp[i])%Mod;        printf(&quot;%d\n&quot;,ans);    }        return 0;} </code></pre>        <div id="aplayer-HrYLAvxQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-HrYLAvxQ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4300</title>
    <link href="/2020/02/07/HDU-4300/"/>
    <url>/2020/02/07/HDU-4300/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-4300 Clairewd’s message</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4300" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4300</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>第一行给的是26个字母对应的翻译密码，而第二行给的是文本串，该文本串前面部分为加密后的内容，而后部分(可能不完整)为未加密的内容。求：一行字符串前一半为加密后的内容，后一半为未加密的内容。一一对应的关系。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>由题意可知，文本串前一部分是加密过后的内容，后一部分是未加密的内容，而这一部分可能是不完整的。则可理解为s=stringA+stringB。可以根据第一行给的加密方式将s整体当作加密内容，将其转化为整体未加密的内容，即字符串s转化成了t。这时候将原s的所有后缀与t匹配，这个过程实际上就是ex-kmp，将t作为子串，s作为母串，求t与s的所有后缀的公共前缀的长度extend[]。如果extend[i]+i==len(s)&amp;&amp;i&gt;=extend[i].即以i为分界点，s[0…i-1]作为stringA，s[i…len-1]作为stringB，即stringB就是原文本内容。(i&gt;=extend[i]的原因：如果stringB与t的公共连续子串的长度大于了i，这就与extend[i]的定义矛盾了。)选择最近的符合条件的点作为答案。分两部分输出即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;const int maxm=1000+5;int T,len1,len2,Next[maxn],Extend[maxn],t[maxm],q[maxm];char S[maxn],s1[maxn],s2[maxn];void next_pre(){    int i=0,po=0;    while(s1[i]==s1[i+1]&amp;&amp;i+1&lt;len2)i++;    Next[0]=len2;Next[1]=i;po=1;    for(int i=2;i&lt;len1;i++)    {        if(Next[i-po]+i&lt;Next[po]+po)            Next[i]=Next[i-po];        else         {            int j=Next[po]+po-i;            if(j&lt;0)j=0;            while(s1[i+j]==s1[j]&amp;&amp;i+j&lt;len2)j++;            Next[i]=j;            po=i;        }    }}void extend_pre(){    int i=0,po=0;    while(s2[i]==s1[i]&amp;&amp;i&lt;len2)i++;    Extend[0]=i;    for(int i=1;i&lt;len2;i++)    {        if(Next[i-po]+i&lt;Extend[po]+po)            Extend[i]=Next[i-po];        else         {            int j=Extend[po]+po-i;            if(j&lt;0)j=0;//            cout&lt;&lt;j&lt;&lt;&#39; &#39;&lt;&lt;i+j&lt;&lt;endl;//            cout&lt;&lt;s1[j]&lt;&lt;&#39; &#39;&lt;&lt;s2[i+j]&lt;&lt;endl;            while(s2[i+j]==s1[j]&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len2)j++;            Extend[i]=j;            po=i;        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(Next,0,sizeof(Next));        memset(Extend,0,sizeof(Extend));        memset(t,0,sizeof(t));        memset(q,0,sizeof(q));        memset(S,0,sizeof(S));        memset(s1,0,sizeof(s1));        memset(s2,0,sizeof(s2));        scanf(&quot;%s%s&quot;,S,s2);        len1=strlen(s2);len2=strlen(s2);        for(int i=0;i&lt;26;i++)        {            t[i]=S[i]-&#39;a&#39;;//a,b,c...z分别转化为s1[0],s1[1],s1[2]...s1[25]             q[S[i]-&#39;a&#39;]=i;//再转化回去，形成映射         }        for(int i=0;i&lt;len2;i++)        {            s1[i]=q[s2[i]-&#39;a&#39;]+&#39;a&#39;;        }        s1[len2]=&#39;\0&#39;;//        cout&lt;&lt;s1&lt;&lt;endl;        next_pre();        extend_pre();//        for(int i=0;i&lt;len2;i++)cout&lt;&lt;Next[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;//        for(int i=0;i&lt;len2;i++)cout&lt;&lt;Extend[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;        int opt=0;        for(int i=0;i&lt;len2;i++)        {            if(Extend[i]+i==len2&amp;&amp;i&gt;=Extend[i])            {                opt=i;                break;            }        }//        cout&lt;&lt;opt&lt;&lt;endl;        for(int i=0;i&lt;opt;i++)printf(&quot;%c&quot;,s2[i]);        for(int i=0;i&lt;opt;i++)printf(&quot;%c&quot;,q[s2[i]-&#39;a&#39;]+&#39;a&#39;);        if(opt==0)        {            printf(&quot;%s&quot;,s2);            for(int i=0;i&lt;len2;i++)printf(&quot;%c&quot;,q[s2[i]-&#39;a&#39;]+&#39;a&#39;);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-oUyxIPGQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-oUyxIPGQ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>ex-kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1238</title>
    <link href="/2020/02/07/HDU-1238/"/>
    <url>/2020/02/07/HDU-1238/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1238 Substrings</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1238#author=organicsalt" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1238#author=organicsalt</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给n个字符串，问是否存在一个子串(或将该子串reverse)为所有字符串的子串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>将第一个字符串的所有子串与其余子串匹配一遍，如果有一个匹配失败，就将该子串reverse再匹配。这里使用reverse会更快，用kmp加速。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;int n,T,Next[maxn],len1,len2;string s[105],s2;void next_pre(int len){    int i=0,j=1;Next[0]=-1;    while(j&lt;len)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int next_work(int opt,int len){    int i=0,j=0;len2=s[opt].length();    while(i&lt;len2)    {        if(s2[j]==s[opt][i]||j==-1)i++,j++;        else j=Next[j];        if(j==len)        {            return 1;        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(Next,0,sizeof(Next));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];        len1=s[1].length();        for(int i=len1;i&gt;=0;i--)        {            int sign=0;            for(int l=0;l+i-1&lt;len1;l++)            {                int r=l+i-1;                s2=s[1].substr(l,i);                memset(Next,0,sizeof(Next));                next_pre(i);                sign=0;                for(int k=2;k&lt;=n;k++)                {                    int x1=next_work(k,i);                    if(x1==0)                    {                        reverse(s2.begin(),s2.end());                        memset(Next,0,sizeof(Next));                        next_pre(i);                        int x2=next_work(k,i);                        if(x2==0)                        {                            sign=1;                            break;                        }                    }                    else continue;                }                if(sign==0)                {                    printf(&quot;%d\n&quot;,i);                    break;                }            }            if(sign==0)            {                break;            }        }    }    return 0;}</code></pre>        <div id="aplayer-DiXeHTMz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DiXeHTMz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2328</title>
    <link href="/2020/02/07/HDU-2328/"/>
    <url>/2020/02/07/HDU-2328/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 2328 Corporate Identity</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2328" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2328</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求n个字符串的最长公共子串，若有多个则输出字典序最小的，若没有就输出“IDENTITY LOST”。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题就相当简单了，直接暴力枚举第一个字符串的所有子串，用kmp与所有别的字符串匹配，看它们是否都包含了这个子串，将符合条件的子串存进数组，在排序sort一下，输出第一个字符串即可。用到substr函数。<br>不过数据可能比较水，理论上时间复杂度是不够的，以为会TLE，结果可以过，甚至暴力都可以过。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=4000+5;int len1,len2,Next[maxn],n,ans;string s1[maxn],s2,Ans[maxn];void next_pre(int len){    int i=0,j=1;Next[0]=-1;    while(j&lt;len)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int next_work(int opt,int len){    int i=0,j=0;int len2=s1[opt].length();    while(i&lt;len2)    {        if(s1[opt][i]==s2[j]||j==-1)i++,j++;        else j=Next[j];        if(j==len)        {            return 1;        }    }    return 0;}int cmp(string x,string y){    return x&lt;y;}int main(){    while(1)    {        memset(Next,0,sizeof(Next));        ans=0;        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s1[i];        len1=s1[1].length();        for(int l=len1;l&gt;=1;l--)        {            int sign=0;            for(int i=0;i+l-1&lt;len1;i++)            {                sign=0;                int r=i+l-1;                s2=s1[1].substr(i,l);                memset(Next,0,sizeof(Next));                next_pre(l);                for(int k=2;k&lt;=n;k++)                {                    int x=next_work(k,l);                    if(x==0)                    {                        sign=1;                        break;                    }                }                if(sign==0)                {                    ans++;                    Ans[ans]=s2;                }            }            if(ans)            break;        }        if(ans==0)        {            printf(&quot;IDENTITY LOST\n&quot;);            continue;        }        else         {            sort(Ans+1,Ans+1+ans,cmp);            cout&lt;&lt;Ans[1]&lt;&lt;endl;        }    }    return 0;}</code></pre>        <div id="aplayer-YdxQulqy" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-YdxQulqy"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3374</title>
    <link href="/2020/02/07/HDU-3374/"/>
    <url>/2020/02/07/HDU-3374/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3374 String Problem</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3374" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3374</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>对于一个字符串，它可以每次左移一次，得到一个新的字符串，因此一个长度为n的字符串，可以得到n个字符串。问，字典序最小的字符串排第几位，一共有多少个，字典序最大的字符串排第几位，一共有多少个<br>ps:如果最大和最小的有多个，输出最先出现的那个。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>求有多少个相同的字符串相对简单，并且运用到了kmp的知识，只有内部循环的字符串才可能会重复，对于这种字符串来讲它的循环节T= n-Next[n]，出现次数times=n/T。如何求最大字符串和最小字符串呢？这个就需要用到字符串的最小表示法和最大表示法。这里简单描述一下字符串的最小表示法，至于字符串的最大表示法，可以将最小表示法照搬修改即可。<br>字符串的最小表示法：<br>设定一个opt1和一个opt2与k。初始opt1=0，opt2=1，k=0，一开始指向s[0],s[1]<br>如果s[opt1+k]==s[opt2+k]，则k++.注意opt2+k可能越界，所以要对len取模。当k==len时，说明每一个字符串都恰好等于，没有字符串比当前的小。就直接返回min(opt1,opt2)<br>如果s[opt1+k]&gt;s[opt2+k],说明s[opt1…..opt1+k]之间的每个字符都不可能作为最小字符串的起始点.于是opt1滑至opt1+k+1，k=0.<br>如果s[opt1+k]&lt;s[opt2+k],说明s[opt2…..opt2+k]之间的每个字符都不可能作为最小字符串的起始点.于是opt2滑至opt2+k+1，k=0.<br>如果opt1==opt2，则让刚才修改过的opt++；<br>最后返回min(opt1,opt2)就可以了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int len1,len2,Next[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int get_min(){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len2&amp;&amp;opt2&lt;len2&amp;&amp;k&lt;len2)    {        if(s2[(opt1+k)%len2]==s2[(opt2+k)%len2])k++;        else if(s2[(opt1+k)%len2]&gt;s2[(opt2+k)%len2])        {            opt1=opt1+k+1,k=0;            if(opt1==opt2)                opt1++;        }        else if(s2[(opt1+k)%len2]&lt;s2[(opt2+k)%len2])        {            opt2=opt2+k+1,k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int get_max(){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len2&amp;&amp;opt2&lt;len2&amp;&amp;k&lt;len2)    {        if(s2[(opt1+k)%len2]==s2[(opt2+k)%len2])k++;        else if(s2[(opt1+k)%len2]&lt;s2[(opt2+k)%len2])        {            opt1=opt1+k+1,k=0;            if(opt1==opt2)                opt1++;        }        else if(s2[(opt1+k)%len2]&gt;s2[(opt2+k)%len2])        {            opt2=opt2+k+1,k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int main(){    while(scanf(&quot;%s&quot;,s2)!=EOF)    {        len2=strlen(s2);        memset(Next,0,sizeof(Next));        next_pre();        int T=len2-Next[len2];int times=0;        if(len2%T==0)        {            times=len2/T;        }        else             times=1;        int x1=get_min();        int x2=get_max();        printf(&quot;%d %d %d %d\n&quot;,x1+1,times,x2+1,times);    }    return 0;}</code></pre>        <div id="aplayer-EqaZdSbb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EqaZdSbb"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
      <tag>字符串的最小(大)表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2609</title>
    <link href="/2020/02/07/HDU-2609/"/>
    <url>/2020/02/07/HDU-2609/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 2609 How many</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2609" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2609</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给n个字符串，每个字符串可以滑动形成新的字符串，问有多少个不同的字符串。<br>ps：若一个字符串滑动后与另一个字符串相同，则这两个字符串相同。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>先将每个字符串的最小表示法找到，然后用string数组储存字符串的最小表示法，然后sort排序，匹配找到总数</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+5;const int maxm=100+5;int len2,Next[maxn],len1,n;string s[maxn];char a[maxn][maxm];int cmp(string x,string y){    return x&lt;y;}int get_min(int opt){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len1&amp;&amp;opt2&lt;len1&amp;&amp;k&lt;len1)    {        if(s[opt][(opt1+k)%len1]==s[opt][(opt2+k)%len1])k++;        else if(s[opt][(opt1+k)%len1]&gt;s[opt][(opt2+k)%len1])        {            opt1=opt1+k+1;k=0;            if(opt1==opt2)                opt1++;        }        else if(s[opt][(opt1+k)%len1]&lt;s[opt][(opt2+k)%len1])        {            opt2=opt2+k+1;k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(a,0,sizeof(a));//char  与 string不同，必须清空！string s[i] 清空：s[i].clear();         for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];        for(int i=1;i&lt;=n;i++)        {            len1=s[i].length();            int x=get_min(i);            int opt=0;            while(opt&lt;len1)            {                a[i][opt]=s[i][(x+opt)%len1];                opt++;            }        }        for(int i=1;i&lt;=n;i++)s[i]=a[i];        sort(s+1,s+1+n,cmp);        int ans=1;        for(int i=2;i&lt;=n;i++)        {            if(s[i]!=s[i-1])ans++;        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-iPrTFrth" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-iPrTFrth"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>字符串的最小(大)表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FZU-1901</title>
    <link href="/2020/02/07/FZU-1901/"/>
    <url>/2020/02/07/FZU-1901/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>FZU - 1901 Period II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/FZU-1901" target="_blank" rel="noopener">https://vjudge.net/problem/FZU-1901</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>对于一个正整数p，p&lt;=字符串的长度，使得任意的s[i]==s[i+p]，求出所有符合要求的p。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题和之前的某个题意很迷的密码题有点相似，那个题当时就是用的ex-kmp，做这个题开始时题意不理解，百度了一下题意。一开始想的就是用kmp，似乎网上用kmp的很多，但我一下子不知道如何运行Next，不过，我突然发现，令s2=s1，用s1的所有后缀匹配s2的结果让我意外，所有符合Extend[i]+i&gt;=len的都是p，当然len本身也是。很显然这个题可以用ex-kmp来做。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int T,len1,len2,Next[maxn],Extend[maxn],Ans[maxn];string s1,s2;//s1的所有后缀与s2匹配 void next_pre(){    int i=0,po=0;    while(s2[i]==s2[i+1]&amp;&amp;i+1&lt;len2)i++;    Next[0]=len2;Next[1]=i;po=1;    for(int i=2;i&lt;len2;i++)    {        if(Next[i-po]+i&lt;Next[po]+po)            Next[i]=Next[i-po];        else         {            int j=Next[po]+po-i;            if(j&lt;0)j=0;            while(s2[j+i]==s2[j]&amp;&amp;i+j&lt;len2)j++;            Next[i]=j;            po=i;        }    }} void extend_pre(){    int i=0,po=0;    while(s1[i]==s2[i]&amp;&amp;i&lt;len2&amp;&amp;i&lt;len1)i++;    Extend[0]=i;    for(int i=1;i&lt;len1;i++)    {        if(Next[i-po]+i&lt;Extend[po]+po)            Extend[i]=Next[i-po];        else         {            int j=Extend[po]+po-i;            if(j&lt;0)j=0;            while(s1[j+i]==s2[j]&amp;&amp;i+j&lt;len1&amp;&amp;j&lt;len2)j++;            Extend[i]=j;            po=i;        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);int now=0;    while(now&lt;T)    {        now++;        memset(Next,0,sizeof(Next));        memset(Extend,0,sizeof(Extend));        memset(Ans,0,sizeof(Ans));        cin&gt;&gt;s2;s1=s2;        len2=s2.length();len1=s1.length();        next_pre();        extend_pre();        int opt=0,res=0;int ans=0;        for(int i=0;i&lt;len2;i++)        {            if(Extend[i]+i&gt;=len2&amp;&amp;i!=0)            {                Ans[++ans]=i;            }            }        Ans[++ans]=len2;        printf(&quot;Case #%d: %d\n&quot;,now,ans);        for(int i=1;i&lt;ans;i++)printf(&quot;%d &quot;,Ans[i]);printf(&quot;%d\n&quot;,Ans[ans]);    }    return 0;}//注意数组不能太大，容易TLE //一开始找到第一个Extend[i]+i&gt;=len2就以为找到循环节了，实际上有问题。要线性枚举一遍才行！ </code></pre>        <div id="aplayer-fIMjsDjb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-fIMjsDjb"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>ex-kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3068</title>
    <link href="/2020/02/07/HDU-3068/"/>
    <url>/2020/02/07/HDU-3068/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3068 最长回文</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3068" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3068</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求多组数据的最长回文的长度，就是Manacher的模板题</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>讲解一下Manacher算法<br>首先该算法的时间复杂度为O(N)，一个长度为len的字符串，len可能为奇数，也可能是偶数，那么中间点就不一样了，那对于长度L=2len+1呢？<br>显然它一定是奇数。具体操作为：<br>t[0]=’$’;<br>for(int i=1;i&lt;=len;i++)t[++len]=’#’,t[++len]=s[i-1];<br>t[++len]=’#’;<br>比如字符串 abccba 就转换成了 $#a#b#c#c#b#a#;</p><p>以上是初始化的过程，接下来是具体的操作过程：<br>对于p[i]，如果i&lt;mx，设j是i关于id对称点，如图所示，则基于以下三种情况，可以求出p[i]的值：</p><p>（1）以j为中心的回文串有一部分在以id为中心的回文串之外。因为mx是以id为中心的最长回文的右边界，所以以i为中心的回文串不可能会有字符在以id为中心的回文串之外；否则mx就不是以id为中心的最长回文的右边界。所以，在这种情况下，p[i]=mx–i。<br>具体阐释一下：此时s[id,id+1,…i-1,i]=s[id,id-1,…,j+1,j]，假如以i为中心的回文串有字符在以id为中心的回文串之外，显然mx不应该为右边界！</p><p>（2）以j为中心的回文串全部在以id为中心的回文串的内部，则p[i]=p[j]，而且p[i]不可能再增加。</p><p>（3）以j为中心的回文串的左端正好与以id为中心的回文串的左端重合。则p[i]=p[j]或p[i]=mx–i，并且p[i]还有可能会继续增加，即while (s_new[i-p[i]]==s_new[i+p[i]]) p[i]++;</p><p>所以，if (i &lt; mx) p[i] = min(p[2 * id - i], mx- i)；其中2*id - i为i关于id的对称点，即上面的j点，而p[j]表示以j为中心的最长回文半径，因此可以利用p[j]来加快求解p[i]。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=110000*2+100;char s[maxn],t[maxn];int len,p[maxn];int main(){    while(scanf(&quot;%s&quot;,s)!=EOF)    {        len=0;memset(p,0,sizeof(p));        memset(t,0,sizeof(t));        int L=strlen(s),ans=0;        t[0]=&#39;$&#39;;        for(int i=1;i&lt;=L;i++)        {            t[++len]=&#39;#&#39;;t[++len]=s[i-1];        }        t[++len]=&#39;#&#39;;        int id=0,mx=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]])p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;            }            ans=max(ans,p[i]-1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-PcejZJRh" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-PcejZJRh"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4513</title>
    <link href="/2020/02/07/HDU-4513/"/>
    <url>/2020/02/07/HDU-4513/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4513 吉哥系列故事——完美队形II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4513#author=hzoi2017_wty" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4513#author=hzoi2017_wty</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>假设有n个人按顺序的身高分别是h[1], h[2] … h[n]，从中挑出一些人形成一个新的队形，新的队形若满足以下要求，则就是新的完美队形：<br>　　1、连续的<br>　　2、形成回文串<br>　　3、从左到中间那个人，身高需保证不下降</p><p>　　　问有组成完美队形的最多人数</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>要求连续的并且是回文串，这很明显就是回文串的题，应该用Manacher算法，但是又要求从左到中间，身高不下降，就需要修改一下判定条件：    while(t[i+p[i]]==t[i-p[i]]&amp;&amp;(t[i-p[i]]==0||t[i-p[i]]&lt;=t[i-p[i]+2]))p[i]++;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000*2+15;int T,n,p[maxn],s[maxn],t[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(p,0,sizeof(p));        memset(t,0,sizeof(t));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;s[i]);        int len=0;        t[0]=10000;        for(int i=1;i&lt;=n;i++)        {            t[++len]=0;t[++len]=s[i];        }        t[++len]=0;        int id=0,mx=0,ans=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]]&amp;&amp;(t[i-p[i]]==0||t[i-p[i]]&lt;=t[i-p[i]+2]))p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;            }            ans=max(ans,p[i]-1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-GdwZgdBC" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-GdwZgdBC"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3294</title>
    <link href="/2020/02/07/HDU-3294/"/>
    <url>/2020/02/07/HDU-3294/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3294 Girls’ research</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3294#author=asasas5d" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3294#author=asasas5d</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>先给一个字符x，然后给一个 字符串，表示字符串中所有字符x变成’a’，其余的字符依次往前变换。例如b babad就转换成azazc。让寻找第一个最长回文串，长度若小于2，则输出No solution!，否则输出起点，终点和转换后的最长回文串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最长回文串问题，当然就是用Manacher，先计算出字符x与‘a’的差值，然后将字符串进行转换。然后直接跑Manacher，更新ans时注意更新储存一下终点和起点</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000*2+105;int p[maxn],len,a[maxn],S,T;char s[maxn],t[maxn],x[3];int main(){    while(scanf(&quot;%s&quot;,x)!=EOF)    {        len=0;S=0;T=0;        scanf(&quot;%s&quot;,&amp;s);        int delt=x[0]-&#39;a&#39;;        int L=strlen(s);        for(int i=0;i&lt;L;i++)        {            a[i]=s[i]-&#39;a&#39;-delt;            if(a[i]&lt;0)a[i]+=26;            s[i]=a[i]+&#39;a&#39;;        }        t[0]=&#39;$&#39;;        for(int i=1;i&lt;=L;i++)        {            t[++len]=&#39;#&#39;;t[++len]=s[i-1];        }        t[++len]=&#39;#&#39;;        int mx=0,id=0,ans=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]])p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;                if(ans&lt;p[i]-1)                {                    ans=p[i]-1;                    T=(mx-1)/2;                    S=T-ans+1;                    T--;S--;                }            }        }        if(ans&lt;2)        {            printf(&quot;No solution!\n&quot;);        }        else         {            printf(&quot;%d %d\n&quot;,S,T);            for(int i=S;i&lt;=T;i++)            printf(&quot;%c&quot;,s[i]);cout&lt;&lt;endl;        }    }    return 0;}</code></pre><p>//注意读入时要！=EOF，否则TLE</p>        <div id="aplayer-AYOrRxlW" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-AYOrRxlW"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4763</title>
    <link href="/2020/02/07/HDU-4763/"/>
    <url>/2020/02/07/HDU-4763/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4763 Theme Section</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4763#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4763#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>字符串E是字符串S的前缀和后缀，同时也出现在字符串S的中间，不与前缀后缀重合，问字符串S中符合要求的字符串E的最大长度。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这题显示是kmp问题，kmp中Next[i]表示字符串s从0…..i-1中前缀与后缀的最大公共子串，而问题就是求EAEBE，A，B长度任意(可以为0)，显然E最长为Next[len]，于是可以从len-Next[len]开始往前看Next[now]与E的大小关系，now&gt;=2*E，因为不可以重叠，如果找不到呢，E就应该缩小，理论是E–，所以E=Next[E]，继续寻找，直到找到或者无法继续。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int n,len1,len2,Next[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        memset(Next,0,sizeof(Next));        scanf(&quot;%s&quot;,s2);        len2=strlen(s2);        next_pre();        int L=Next[len2];        int sign=0;        while(L)        {            int now=len2-L;            while(Next[now]==0&amp;&amp;now&gt;=2*L)now--;            while(now&gt;=2*L)            {                if(Next[now]&gt;=L)                {                    break;                }                else now--;            }            if(Next[now]&gt;=L&amp;&amp;now&gt;=2*L)            {                sign=1;                printf(&quot;%d\n&quot;,L);                break;            }            L=Next[L];        }        if(sign==0)        {            printf(&quot;0\n&quot;);            continue;        }    }    return 0;}</code></pre><p>//注意要判定now&gt;=2*L！</p>        <div id="aplayer-IlFBfVDK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-IlFBfVDK"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2387</title>
    <link href="/2020/02/07/POJ-2387/"/>
    <url>/2020/02/07/POJ-2387/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2387 Til the Cows Come Home</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2387#author=ght5160" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2387#author=ght5160</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求从1到n的最短距离</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最短路模板，spfa或者dijkstra+堆优化。<br>朴素Dijkstra：时间复杂度o(n^2)<br>堆优化Dijkstra：时间复杂度o(（V+E）logV）</p><p>spfa在稀疏图O（E），稠密图O（VE）</p><p>dijkstra+堆优化的代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=2000+5;int n,m,k=1,dist[maxn],vis[maxn],head[maxn];struct node{    int to,next,w;}edge[maxn*2];struct N{    int now,w;    bool operator &lt; (N x)const{return x.w&lt;w;}};void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(!vis[edge[i].to]&amp;&amp;dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);add(a,b,c);add(b,a,c);    }    dijkstra();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre><p>spfa的代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=2000+5;int n,m,k=1,head[maxn],dist[maxn],vis[maxn]; struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(){    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    queue&lt;int&gt;q;    dist[1]=0;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    q.push(edge[i].to);                    vis[edge[i].to]=1;                }            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);add(a,b,c);add(b,a,c);    }    spfa();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre>        <div id="aplayer-phKWLyQA" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-phKWLyQA"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2253</title>
    <link href="/2020/02/07/POJ-2253/"/>
    <url>/2020/02/07/POJ-2253/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2253 Frogger</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2253#author=dusenlin" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2253#author=dusenlin</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>两块石头之间的青蛙距离被定义为两块石头之间所有可能路径上的最小必要跳跃距离，某条路径的必要跳跃距离即这条路径中单次跳跃的最远跳跃距离。求1到2的最小必要跳跃距离。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>数据很小，符合Floyd算法。每一次更新的时候需要调整一下：<br>dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));<br>因为必要跳跃距离是指整个路径单次跳跃的最远距离，所以取max</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=200+5;int n;double dist[maxn][maxn],x[maxn],y[maxn];int main(){    int opt=0;    while(1)    {        opt++;        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                dist[i][j]=0x3f3f3f3f;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(i!=j)                dist[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));            }        }        for(int k=1;k&lt;=n;k++)        {            for(int i=1;i&lt;=n;i++)            {                for(int j=1;j&lt;=n;j++)                {                    dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));                }            }            }        printf(&quot;Scenario #%d\n&quot;,opt);        printf(&quot;Frog Distance = %.3lf\n&quot;,dist[1][2]);        cout&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-EOVGYQwN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EOVGYQwN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1797</title>
    <link href="/2020/02/07/POJ-1797/"/>
    <url>/2020/02/07/POJ-1797/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1797 Heavy Transportation</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1797#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1797#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求1-n路径上边权最小值最大。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最短路径的变形题，用spfa来实现<br>原本的dist[edge[i].to]=min(dist[edge[i].to],dist[x]+edge[i].w)<br>修改为dist[edge[i].to]=max(dist[edge[i].to],min(dist[x],edge[i].w)<br>注意初始化dist全为0，由于收缩，dist[1] =0x3f3f3f3f;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000000+5;const int maxm=1000+5;int k=1,T,n,m,head[maxm],vis[maxm],dist[maxm];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    dist[1]=0x3f3f3f3f;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;min(dist[x],edge[i].w))            {                dist[edge[i].to]=min(dist[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);int opt=0;    while(T--)    {        opt++;        memset(head,0,sizeof(head));        k=1;memset(edge,0,sizeof(edge));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,c);        }        spfa();        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,dist[n]);    }}</code></pre>        <div id="aplayer-DmsHiKgb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DmsHiKgb"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3268</title>
    <link href="/2020/02/07/POJ-3268/"/>
    <url>/2020/02/07/POJ-3268/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3268 Silver Cow Party</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3268#author=Demon_de_Laplace" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3268#author=Demon_de_Laplace</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>N头牛，M条单行道，在s出举行聚会，每头牛出发和返回都是走最短路，问所有牛中走的路程最远的牛走了多远？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>建边的时候建双向边，k=2开始.<br>当边号为偶数时，说明是正边；<br>当边号为奇数时，说明时反边；<br>从s出发，跑正边，dist[i]存的是从s到i的最短距离；<br>从s出发，跑反边，dist[i]存的是从i到s的最短距离；<br>ans=max(ans,dist1[i]+dist2[i])</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int n,m,t,k=1,head[maxn],vis[maxn],dist1[maxn],dist2[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa1(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist1,0x3f3f3f3f,sizeof(dist1));    vis[t]=1;dist1[t]=0;    q.push(t);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(i%2==1)continue;            if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)            {                dist1[edge[i].to]=dist1[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void spfa2(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist2,0x3f3f3f3f,sizeof(dist2));    vis[t]=1;dist2[t]=0;    q.push(t);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(i%2==0)continue;            if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)            {                dist2[edge[i].to]=dist2[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);add(b,a,c);    }    spfa1();spfa2();    int ans=0;    for(int i=1;i&lt;=n;i++)    {        ans=max(ans,dist1[i]+dist2[i]);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-ynigUeNx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ynigUeNx"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1860</title>
    <link href="/2020/02/07/POJ-1860/"/>
    <url>/2020/02/07/POJ-1860/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1860 Currency Exchange</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1860#author=riba2534" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1860#author=riba2534</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出每两种货币之间交换的手续费和汇率，求出从当前货币s开始交换，能否赚。能赚输出YES，否则输出NO</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>运用spfa判断是否存在存在正环(类似于判负环)。和判负环一样，记录一下点出现的次数，一旦出现此次数&gt;n就可以作出判断。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10000+5;int n,m,s,k=1,head[maxn],vis[maxn],used[maxn];double w,dist[maxn];struct node{    int to,next;double w,q;}edge[maxn*2];void add(int u,int v,double q,double w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].q=q;}int spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    dist[s]=w;vis[s]=1;used[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;(dist[x]-edge[i].w)*edge[i].q)            {                dist[edge[i].to]=(dist[x]-edge[i].w)*edge[i].q;                if(!vis[edge[i].to])                {                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d%lf&quot;,&amp;n,&amp;m,&amp;s,&amp;w);    for(int i=1;i&lt;=m;i++)    {        int a,b;double w1,w2,q1,q2;        scanf(&quot;%d%d%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;q1,&amp;w1,&amp;q2,&amp;w2);        add(a,b,q1,w1);add(b,a,q2,w2);    }    int x=spfa();    if(x==1)printf(&quot;YES\n&quot;);    else printf(&quot;NO\n&quot;);    return 0;}</code></pre>        <div id="aplayer-psUsVgtW" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-psUsVgtW"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3259</title>
    <link href="/2020/02/07/POJ-3259/"/>
    <url>/2020/02/07/POJ-3259/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3259 Wormholes</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3259#author=chen_zhe" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3259#author=chen_zhe</a>_</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个教室，m条走廊(双向)，w条密道(单向)。走廊耗时&gt;0，密道可耗时&lt;0，问是否可以回到过去。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>密道耗时&lt;0，再根据题目要求，就是问该图是否存在负环。由于这是一个连通图，从哪个点出发效果都一样，不妨从1开始出发，判断是否存在负环，判断方法：每次进行收缩时记录次数++，一旦超过了n就可以作出判断。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=50000+5;int k=1,T,n,m,w,head[maxn],vis[maxn],dist[maxn],used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int spfa(){    queue&lt;int&gt;q;    memset(used,0,sizeof(used));    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    vis[1]=1;dist[1]=0;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;w);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,c);        }        for(int i=1;i&lt;=w;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,-c);        }        int x=spfa();        if(x==1)printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    }    return 0;}</code></pre>        <div id="aplayer-EXcWnhBV" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EXcWnhBV"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1502</title>
    <link href="/2020/02/07/POJ-1502/"/>
    <url>/2020/02/07/POJ-1502/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1502 MPI Maelstrom</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1502#author=20175101008" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1502#author=20175101008</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出a[i][j]之间的值，若a[i][j]==’x’说明i，j之间不通，问从1开始同时向2…..n传递信息，需要多久全部结点都收到？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=100，显然可以用Floyd算法，读入时字符串读入，加以处理，得到a[i][j]之间的距离，i，j不通则将长度设为无穷大，然后开始跑Floyd，最后统计dist[1][i],i∈[2,n]的最大值，该值为答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200+5;int n,a[maxn][maxn],dist[maxn][maxn];int main(){    memset(dist,0x3f3f3f3f,sizeof(dist));    scanf(&quot;%d&quot;,&amp;n);    char x[10];    for(int i=2;i&lt;=n;i++)    {        for(int j=1;j&lt;i;j++)        {            scanf(&quot;%s&quot;,x);            if(x[0]==&#39;x&#39;)a[j][i]=a[i][j]=0x3f3f3f3f;            else             {                int sum=0;                for(int k=0;k&lt;=strlen(x)-1;k++)                {                    sum=sum*10+x[k]-&#39;0&#39;;                }                a[j][i]=a[i][j]=sum;            }        }    }    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(i==j)dist[i][j]=0;            else dist[i][j]=a[i][j];        }    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);            }        }    }    int ans=0;    for(int i=2;i&lt;=n;i++)    ans=max(ans,dist[1][i]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-faULovby" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-faULovby"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3660</title>
    <link href="/2020/02/07/POJ-3660/"/>
    <url>/2020/02/07/POJ-3660/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3660 Cow Contest</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3660#author=arasHi" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3660#author=arasHi</a>_</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n头牛，m条比赛结果，每行两个数字，第一个数字表示的是胜利者。<br>问有几头牛的排名可以确定？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>排名可以确定，这该如何理解？对于结点i，如果箭头指向i所包含的结点数为ans1，i箭头指出所包含的结点数为ans2，若ans1+ans2==n-1就说明结点i的排名可以确定。问题在于如何确定ans1，ans2的值。<br>举个例子：若a可以到b，b可以到c，那么a就可以到c。这就是传递闭包了。<br><img src="https://img-blog.csdn.net/20170409190428811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MTM3NjEyNDA2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt=""><br>如何进行传递闭包呢？以上例子，a可以到b，b可以到c，则dist[a][b]=1,dist[b][c]=1,则a可以到c，即dist[a][c]=1；用floyd进行收缩即可。然后每个结点是否可以到达剩余的n-1个结点，或者剩余n-1个结点能否到达该结点，即ans1+ans2==n。判断条件就是dist[i][j]==1||dist[j][i]==1;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int n,m,dist[maxn][maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=m;i++)    {        int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        dist[a][b]=1;    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(dist[i][k]==1&amp;&amp;dist[k][j]==1)                dist[i][j]=1;            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        int sign=0;        for(int j=1;j&lt;=n;j++)        {            if(i==j)continue;            if(dist[i][j]||dist[j][i])continue;            else sign=1;        }        if(sign==0)ans++;    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-ohLJJeos" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ohLJJeos"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>闭包传递</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2240</title>
    <link href="/2020/02/07/POJ-2240/"/>
    <url>/2020/02/07/POJ-2240/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2240 Arbitrage</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2240#author=Andy_acmer" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2240#author=Andy_acmer</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n种货币，m条货币的汇率关系。比如：USDollar 0.5 BritishPound<br>说明1个USDollar货币，可以换成0.5个BritishPound货币，问是否可以通过这种关系来获利。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>由于货币名字使字符串，那么用map比较方便,map&lt;string,int&gt;q，可以将字符串映射成int型。然后跑spfa，看是否存在正环，与判断负环的方法一样。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;const int maxn=10000+5;int n,m,head[maxn],vis[maxn],used[maxn],k=1;double dist[maxn];map&lt;string,int&gt;q;struct node{    int to,next;double w;}edge[maxn*2];void add(int u,int v,double w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;    }int spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    vis[1]=1;used[1]=1;dist[1]=1.0;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;dist[x]*edge[i].w)            {                dist[edge[i].to]=dist[x]*edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    int now=0;    while(1)    {        now++;        k=1;memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        q.clear();        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        int tot=0;        for(int i=1;i&lt;=n;i++)        {            string x;cin&gt;&gt;x;            q[x]=++tot;            }                scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            string a,b;double c;            cin&gt;&gt;a&gt;&gt;c&gt;&gt;b;            add(q[a],q[b],c);        }        int x=spfa();        printf(&quot;Case %d: &quot;,now);        if(x==1)printf(&quot;Yes\n&quot;);        else printf(&quot;No\n&quot;);    }    return 0;}</code></pre>        <div id="aplayer-IiVabMVN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-IiVabMVN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1511</title>
    <link href="/2020/02/07/POJ-1511/"/>
    <url>/2020/02/07/POJ-1511/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1511 Invitation Cards</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1511#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1511#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>n-1个人从1号点出发，到剩余n-1个宣传点，然后再回到1号点汇报结果，求所有人往返路径和的最小值。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>m条边，边号为偶数的表示正方向，边号为奇数的表示反方向。spfa1()沿着正方向跑，起点为1，则dist[i]表示的是从1到i的最短距离。spfa2()沿着反方向跑，起点为1，则dist2[i]表示的是从i到1的最短距离。最终答案就是dist1[i]+dist2[i]的总和，i∈[2,n]。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">    #include&lt;cstdio&gt;    #include&lt;cstring&gt;    #include&lt;iostream&gt;    #include&lt;algorithm&gt;    #include&lt;queue&gt;    using namespace std;    const long long maxn=1000000+5;    struct node    {        long long to,next,w;    }edge[maxn*2];    long long k=1,head[maxn],vis[maxn],dist1[maxn],dist2[maxn],T,n,m;    void add(long long u,long long v,long long w)    {        edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;    }    void spfa1()//1到其余所有点     {        queue&lt;long long&gt;q;        memset(vis,0,sizeof(vis));        memset(dist1,0x3f3f3f3f,sizeof(dist1));        dist1[1]=0;vis[1]=1;        q.push(1);        while(!q.empty())        {            long long x=q.front();q.pop();vis[x]=0;            for(long long i=head[x];i;i=edge[i].next)            {                if(i%2==1)continue;                if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)                {                    dist1[edge[i].to]=dist1[x]+edge[i].w;                    if(!vis[edge[i].to])                    {                        vis[edge[i].to]=1;                        q.push(edge[i].to);                    }                }            }        }    }    void spfa2()//其余所有点到1；     {        queue&lt;long long&gt;q;        memset(vis,0,sizeof(vis));        memset(dist2,0x3f3f3f3f,sizeof(dist2));        dist2[1]=0;vis[1]=1;        q.push(1);        while(!q.empty())        {            long long x=q.front();q.pop();vis[x]=0;            for(long long i=head[x];i;i=edge[i].next)            {                if(i%2==0)continue;                if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)                {                    dist2[edge[i].to]=dist2[x]+edge[i].w;                    if(!vis[edge[i].to])                    {                        vis[edge[i].to]=1;                        q.push(edge[i].to);                    }                }            }        }    }    int main()    {        scanf(&quot;%lld&quot;,&amp;T);        while(T--)        {            k=1;            memset(head,0,sizeof(head));            memset(edge,0,sizeof(edge));            scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);            for(long long i=1;i&lt;=m;i++)            {                long long a,b,c;                scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);                add(a,b,c);add(b,a,c);            }            spfa1();             spfa2();            long long ans=0;            for(long long i=2;i&lt;=n;i++)            {                ans+=dist1[i]+dist2[i];                }                printf(&quot;%lld\n&quot;,ans);        }        return 0;    }</code></pre>        <div id="aplayer-wfoweJVp" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-wfoweJVp"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3159</title>
    <link href="/2020/02/07/POJ-3159/"/>
    <url>/2020/02/07/POJ-3159/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3159 Candies</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3159#author=2018112767" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3159#author=2018112767</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个同学，m条信息，每条信息为a,b,c三个整数表示a相信b的糖果不会比自己多于c。问n同学最多比1同学多多少个糖果？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是差分约束的题目，由题知Have[b]-Have[a]&lt;=c;即<br>Have[b]&lt;=c+Have[a]；而最短路的更新条件是dist[edge[i].to]&gt;dist[x]+edge[i].w，就说明了dist[edge[i].to]&lt;=dist[x]+edge[i].w;于是建边就可以a—&gt;b,边权为c，跑最短路。dist[n]就是答案</p><p>ps：一开始跑spfa，TLE，此图有点稠密，用dijkstra+堆优化更保险！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=150000+5;struct node{    int to,next,w;}edge[maxn*2];int k=1,head[maxn],vis[maxn],dist[maxn],n,m;void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}struct N{    int now,w;    bool operator &lt; (N x) const{return x.w&lt;w;}};void spfa(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);    }    dijkstra();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre>        <div id="aplayer-MuPILEwC" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-MuPILEwC"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>差分约束</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2502</title>
    <link href="/2020/02/07/POJ-2502/"/>
    <url>/2020/02/07/POJ-2502/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2502 Subway</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2502#author=1738160864" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2502#author=1738160864</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>小k要从家去学校，他可以选择步行或者地铁，步行的速度是10km/h，地铁的速度是40km/h。假设小k非常的幸运，每次他到地铁站就立刻会有地铁。小k可以随意上下地铁，并且可以在地铁线路之间转换。所有的地铁运行都是双向的。<br>注意地铁站不会重复出现。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=200，所以可以用Floyd。每次出现的新地铁站，先与起点更新时间花费，此时速度为v1，然后输入地铁线，此时速度为v2，可以更新相邻地铁站之间的时间花费，并且更新起点与地铁站之间的时间花费，此时速度为v1。最后地铁站输入完之后，tot++，这就是终点编号，所有结点与终点的时间花费需要更新。然后开始跑Floyd。最后dist[0][tot]储存答案，需要四舍五入，即int ans=dist[0][tot]+0.5;ans为最终答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int maxn=200+5;double v1=10*1000/60;double v2=40*1000/60;double dist[maxn][maxn],a[maxn][maxn],x[maxn],y[maxn],sx,sy,tx,ty;int main(){    int tot=1;int s=0;    memset(a,0x7f7f7f7f,sizeof(a));    memset(dist,0x7f7f7f7f,sizeof(dist));    scanf(&quot;%lf%lf%lf%lf&quot;,&amp;sx,&amp;sy,&amp;tx,&amp;ty);    while(scanf(&quot;%lf%lf&quot;,&amp;x[tot],&amp;y[tot])!=EOF)    {        a[tot][0]=a[0][tot]=sqrt((sx-x[tot])*(sx-x[tot])+(sy-y[tot])*(sy-y[tot]))/v1;        while(1)        {            tot++;            scanf(&quot;%lf%lf&quot;,&amp;x[tot],&amp;y[tot]);            if(x[tot]==-1&amp;&amp;y[tot]==-1)            {                break;            }            a[tot][tot-1]=a[tot-1][tot]=sqrt((x[tot]-x[tot-1])*(x[tot]-x[tot-1])+(y[tot]-y[tot-1])*(y[tot]-y[tot-1]))/v2;            a[tot][0]=a[0][tot]=sqrt((sx-x[tot])*(sx-x[tot])+(sy-y[tot])*(sy-y[tot]))/v1;                    }    }        for(int i=1;i&lt;=tot;i++)        {            for(int j=1;j&lt;=tot;j++)            {                a[i][j]=a[j][i]=min(a[i][j],sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/v1);            }        }        tot++;        a[0][tot]=a[tot][0]=sqrt((sx-tx)*(sx-tx)+(sy-ty)*(sy-ty))/v1;        for(int i=1;i&lt;tot;i++)        {            a[i][tot]=a[tot][i]=sqrt((x[i]-tx)*(x[i]-tx)+(y[i]-ty)*(y[i]-ty))/v1;        }        for(int i=0;i&lt;=tot;i++)        {            for(int j=0;j&lt;=tot;j++)            {                dist[i][j]=a[i][j];            }        }        for(int k=0;k&lt;=tot;k++)        {            for(int i=0;i&lt;=tot;i++)            {                for(int j=0;j&lt;=tot;j++)                {                    dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);                }            }        }        int ans=dist[0][tot]+0.5;        printf(&quot;%d\n&quot;,ans);        return 0;}</code></pre>        <div id="aplayer-QAsIeRee" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-QAsIeRee"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1062</title>
    <link href="/2020/02/07/POJ-1062/"/>
    <url>/2020/02/07/POJ-1062/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1062 昂贵的聘礼</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1062#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1062#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一个人要买1号物品，而此物品可以通过直接购买或者到别人的手中买别的东西+一些金币来得到。但是需要注意：如果两人地位等级差距超过了delt，就不可以进行间接交易，即该交易圈的人两两之间等级差异不可大于delt。问要得到1号物品至少要花费多少钱？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>建立一个源点，它与所有物品建边，即s–&gt;i（边权为物品原价），因为每个物品除了直接购买，还可以间接购买，设间接购买物品为j，则建边方式为j–&gt;i（边权为额外金币）然后跑最短路，注意最短路的条件不再是dist[edge[i].to]&gt;dist[x]+edge[i].w，因为当价格相等时也需要进入队列来进行松弛，所以应变为dist[edge[i].to]&gt;dist[x]+edge[i].w;然后就是等级限制的判断了。刚开始的s的等级需要从最低到最高都设置一次，意味着跑n次spfa，s就是这次spfa的最低等级，因此a[edge[i].to].l&gt;=limit&amp;&amp;edge[i].to]-limit&lt;=delt||x==0||delt==0；delt==0意味着没有等级限制。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int n,delt,head[maxn],vis[maxn],dist[maxn],k=1,liv[maxn],ans=0x3f3f3f3f;struct Node{    int p,l,x;}a[maxn];struct node{    int next,to,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(int limit){    queue&lt;int&gt;q;    for(int i=1;i&lt;=n;i++)dist[i]=a[i].p;    memset(vis,0,sizeof(vis));    vis[0]=1;dist[0]=0;    q.push(0);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;=dist[x]+edge[i].w&amp;&amp;(delt==0||(a[edge[i].to].l&gt;=limit&amp;&amp;a[edge[i].to].l-limit&lt;=delt)))            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }        }    ans=min(ans,dist[1]);}int main(){    scanf(&quot;%d%d&quot;,&amp;delt,&amp;n);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d%d%d&quot;,&amp;a[i].p,&amp;a[i].l,&amp;a[i].x);        liv[i]=a[i].l;        add(0,i,a[i].p);        for(int j=1;j&lt;=a[i].x;j++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            add(x,i,y);        }    }    sort(liv+1,liv+1+n);    for(int i=1;i&lt;=n;i++)    spfa(liv[i]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-ySQfebHd" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ySQfebHd"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1847</title>
    <link href="/2020/02/07/POJ-1847/"/>
    <url>/2020/02/07/POJ-1847/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1847 Tram</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1847" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1847</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>输入n,a,b三个数，表示有n个点(1-n)，起点是a，终点是b，然后接下来有n行，每一行的第一个数m表示后面将会有m个数，输入结构是这样的，然后我再具体的解释一下。</p><p>3 2 1     3表示共有n个点，接下来有n行，2表示起点，1表示终点<br>2 2 3     第一个数2表示后面有2个数，因为这是第1行，所以后面两个数表示从1到2和从1到3的边<br>2 3 1     表示从2到3和从2到1的边<br>2 1 2     表示从3到1和从3到2的边</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=100，可以跑Floyd，dist初始化无穷大，每个结点所连接的第一个结点与它的距离为0，其余相连的为1，然后跑Floyd。dist[s][t]为最终的结果。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int n,s,t,dist[maxn][maxn];int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;s,&amp;t);    memset(dist,0x3f3f3f3f,sizeof(dist));    for(int i=1;i&lt;=n;i++)    {        int m;        scanf(&quot;%d&quot;,&amp;m);        for(int j=1;j&lt;=m;j++)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            if(j==1)            {                dist[i][x]=0;            }            else             {                dist[i][x]=1;            }        }    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);            }        }    }    if(dist[s][t]&lt;0x3f3f3f3f)    printf(&quot;%d\n&quot;,dist[s][t]);    else     printf(&quot;-1\n&quot;);    return 0;}</code></pre>        <div id="aplayer-xZVgNUGs" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-xZVgNUGs"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LightOJ1074</title>
    <link href="/2020/02/07/LightOJ-1074/"/>
    <url>/2020/02/07/LightOJ-1074/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>LightOJ - 1074 Extended Traffic</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/LightOJ-1074#author=bbisnouse" target="_blank" rel="noopener">https://vjudge.net/problem/LightOJ-1074#author=bbisnouse</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在一个堵车的城市中, 每个路口都有一个拥挤程度a[i], 从u驶向v得到一个数量, 值为(a[v]-a[u])^3, 给出Q组查询, 每组给出一个数, 求1到这个数的点的最小数量, 如果不可达输出 ？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始觉得n很小，可以直接跑floyd，但是后来WA了两发，发现可能存在负环，所以需要判断负环，因此选择spfa，一旦判断出了负环就dfs，找到负环可以达到的所有点。对于查询一一输出结果即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200005;int n,T,a[maxn],head[maxn],vis[maxn],dist[maxn],k=1,used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dfs(int x){    if(vis[x])return ;    vis[x]=1;dist[x]=0x3f3f3f3f;    for(int i=head[x];i;i=edge[i].next)    {        dfs(edge[i].to);    }}void spfa(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(used,0,sizeof(used));    dist[1]=0;vis[1]=1;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)                    {                        memset(vis,0,sizeof(vis));                        dfs(edge[i].to);                        return ;                    }                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=0;    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(a,0,sizeof(a));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);        int m;        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            int w=(a[y]-a[x])*(a[y]-a[x])*(a[y]-a[x]);            add(x,y,w);        }        spfa();        int p;        scanf(&quot;%d&quot;,&amp;p);        printf(&quot;Case %d:\n&quot;,opt);        for(int i=1;i&lt;=p;i++)        {            int t;            scanf(&quot;%d&quot;,&amp;t);            if(dist[t]==0x3f3f3f3f||dist[t]&lt;3)printf(&quot;?\n&quot;);            else printf(&quot;%d\n&quot;,dist[t]);        }    }    return 0;}</code></pre>        <div id="aplayer-JNMisNcV" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-JNMisNcV"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4725</title>
    <link href="/2020/02/07/HDU-4725/"/>
    <url>/2020/02/07/HDU-4725/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4725 The Shortest Path in Nya Graph</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4725#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4725#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>现在给你n个点 ，这些点的分布是层型分布的，你可以从第i层走到相邻的层（i+1，i-1）中，这样走的花费是c，接着他会给你m（从u-&gt;v）条小路，从小路走的花费 是w，问你从1-&gt;n所走的最小花费是多少。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>看到数据范围就不敢用spfa了，太过玄学，不想TLE，所以选择dijkstra，这题的难点在于建边。当然，很容易想到将层转化成点，比如第i个点的层数为deep[i],则转化为点deep[i]+n.对于给的小道就直接建边a–&gt;b权值为c,b–&gt;a权值为c（建双向边），将deep数组从小到大排列，对于deep[i] 和 deep[i-1] （i∈[2,n]），首先要判断它们是否刚好相差1，只有刚好相差1才可以建边，建边方式为add(deep[i-1]+n,deep[i]+n,c);add(deep[i]+n,deep[i-1]+n,c)，相邻层数可以相互移动，消耗为c。</p><p>如何将点和层联系起来呢？<br>点i与它本来层的关系：add(deep[i]+n,i,0)；<br>点i与它上一层的关系(deep[i]&gt;1)：add(i,deep[i]-1+n,c)<br>点i与它下一层的关系(deep[i]&lt;n)：add(i,deep[i]+1+n,c)</p><p>ps:不可以add(i,deep[i]+n,0)；<br>原因：<br>1<br>3 0 1<br>1 1 1<br>本身1是不可到达3的，如果强行add(i,deep[i]+n,0)就会导致同层所有点相连了！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;int n,m,T,k=1,c,head[maxn],vis[maxn],dist[maxn],deep[maxn];struct node{    int to,next,w;}edge[maxn*8];struct N{    int now,w;    bool operator &lt; (N x)const{return x.w&lt;w;}};void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    int now=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        now++;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(deep,0,sizeof(deep));        k=1;        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;c);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;deep[i]);//            add(i,n+deep[i],0);            add(n+deep[i],i,0);            if(deep[i]&gt;1)add(i,n+deep[i]-1,c);            if(deep[i]&lt;n)add(i,n+deep[i]+1,c);        }        sort(deep+1,deep+1+n);        for(int i=2;i&lt;=n;i++)        {            if(deep[i]-deep[i-1]!=1)continue;            add(deep[i-1]+n,deep[i]+n,c);            add(deep[i]+n,deep[i-1]+n,c);        }        for(int i=1;i&lt;=m;i++)        {            int a,b,w;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);            add(a,b,w);add(b,a,w);        }        dijkstra();        printf(&quot;Case #%d: &quot;,now);        if(dist[n]==0x3f3f3f3f)printf(&quot;-1\n&quot;);        else printf(&quot;%d\n&quot;,dist[n]);    }    return 0;}</code></pre>        <div id="aplayer-nVEPUDMR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-nVEPUDMR"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3169</title>
    <link href="/2020/02/07/POJ-3169/"/>
    <url>/2020/02/07/POJ-3169/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3169 Layout</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3169#author=634579757" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3169#author=634579757</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有N头牛排队，多头牛可以在同一点。现有几对相互喜好的牛，他们不能超过一定距离，有几对相互厌恶的牛，他们至少隔开一定距离。求1和N最远相距多少。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这很显然是差分约束的题目。为了保证图能够联通，需要固定i，j的大小顺序。 对于前m1个a,b,c表示a和b之间的距离不超过c，不妨设a&gt;b，则应满足d[a]-d[b]&lt;=c，最短路的要求就是如此，所以建边：b–&gt;a 边权为c。对于后m2个a，b，c表示a和b之间的距离不小于c，不妨设a&gt;b，则应满足d[a]-d[b]&gt;=c，即d[b]&lt;=d[a]-c，所以建边：a–&gt;b边权为-c。然后开始跑spfa，期间要判断负环，如果有负环存在则说明无解；如果dist[n]==0x3f3f3f3f,说明n号可以无限远。其余的则dist[n]为答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int k=1,head[maxn],dist[maxn],vis[maxn],n,m1,m2,used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    dist[1]=0;vis[1]=1;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m1,&amp;m2);    for(int i=1;i&lt;=m1;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        if(b&gt;a)swap(a,b);        add(b,a,c);    }    for(int i=1;i&lt;=m2;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        if(b&gt;a)swap(a,b);        add(a,b,-c);    }    int x=spfa();    if(x==1)printf(&quot;-1\n&quot;);    else     {        if(dist[n]==0x3f3f3f3f)printf(&quot;-2\n&quot;);        else printf(&quot;%d\n&quot;,dist[n]);    }    return 0;}</code></pre>        <div id="aplayer-XARbuVhU" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-XARbuVhU"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>差分约束</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4370</title>
    <link href="/2020/02/07/HDU-4370/"/>
    <url>/2020/02/07/HDU-4370/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4370 0 or 1</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4370#author=cjyl" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4370#author=cjyl</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出一个n×n的矩阵，求一个符合题意的n×n的只含有0和1的矩阵，使得两个矩阵位置对应的元素相乘后和最小。</p><p>题意要求01矩阵：</p><ol><li><p>X12+X13+…+X1n=1</p><p>2.X14+X24+…+X(n-1)n=1</p><p>3.∑Xki (1&lt;=k&lt;=n)=∑Xij (1&lt;=j&lt;=n).（1&lt;i&lt;n）</p></li></ol><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>对于条件1，可以说明1结点一定有且仅有一个出度，并且不是指向自己。<br>对于条件2，可以说明n结点一定有且仅有一个入度，并且该入度的发出者不是自己。<br>对于条件3，可以说明每个2-n-1的每一个结点的出度等于入度。<br>而题目要求求ΣCij * X ij最小值，即求最短路。<br>但是要分2种情况：<br>原因：结点1一定会指向结点i(i∈[2,n])，然后结点i一定指向别的结点，注意结点i不可以直接指向它自己，因为这样出度就不等于入读。最终会指向结点n，或者指向结点1形成自环。对于结点n来讲也是一样。</p><p>情况1：结点1最终指向结点n，则dist[n]就是最小值</p><p>情况2：结点1形成自环，那么结点n也必须形成自环。则dist[1]+dist[n]为答案。<br>针对情况2需要跑两次spfa，第一次spfa以1为起点，第二次spfa以n为起点。</p><p>最终答案为min(ans,d1+d2)其中ans=dist[n],d1=dist[1]，d2=dist[n]（这是第二次跑的spfa的结果）</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=30000+5;int n,c[305][305],head[maxn],vis[maxn],dist[maxn];struct node{    int to,next,w;}edge[maxn*2];void spfa(int s){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=n;i++)    {        if(i==s)        continue;        else         {            dist[i]=c[s][i];            q.push(i);            vis[i]=1;        }    }    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=1;i&lt;=n;i++)        {            if(dist[i]&gt;dist[x]+c[x][i])            {                dist[i]=dist[x]+c[x][i];                if(!vis[i])                {                    vis[i]=1;                    q.push(i);                }            }        }    }}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;c[i][j]);            }        }        spfa(1);        int ans=dist[n];        int d1=dist[1];        spfa(n);        int d2=dist[n];        printf(&quot;%d\n&quot;,min(ans,d1+d2));            }}</code></pre>        <div id="aplayer-VZxSPBBW" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-VZxSPBBW"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA-10480</title>
    <link href="/2020/02/07/UVA-10480/"/>
    <url>/2020/02/07/UVA-10480/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>UVA - 10480 Sabotage</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/UVA-10480" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-10480</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个点，m条无向边，权值为wi。问从1到2，要割断的最小代价。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>1–&gt;2要进行割断并且要消耗最小，显然这是最小割问题。建边的时候要注意是双向边，起点s=1，终点t=2，跑dinic，最小割=最大流。<br>然后从s开始dfs，要edge[i].w&gt;0才开始继续，即s可到达的为一个集合，其余则为t可到达的。然后对于所有正向边，看是否u为s集合，v为t集合，<br>如果是就输出。<br>一开始想着这题和HDU - 4289 Control差不多，以为要拆点，结果就WA了。HDU - 4289 Control这道题由于是点权，将点转换成边，<br>所以需要拆点连边，而这道题说明了m条边的边权，所以不必拆点！<br>为什么割边的判断条件不是edge[i].w==0呢？原因是可能流量流过该边，并且最后该边edge[i].w==0但是实际上并没有割去这条边，<br>只是由于前面的流量影响了这条边！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int N=200+5;int k=1,head[maxn],deep[maxn],s,t,ans,n,m,vis[maxn];struct node{    int to,next,w,u;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].u=u;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}void DFS(int x){    if(vis[x])return ;    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(edge[i].w)        {            DFS(edge[i].to);            }    }}int main(){    while(1)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(vis,0,sizeof(vis));        ans=0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,0);            add(b,a,c);add(a,b,0);        }                s=1;t=2;        dinic();        DFS(s);        for(int i=2;i&lt;=k;i+=2)        {            if(vis[edge[i].u]==1&amp;&amp;vis[edge[i].to]==0)            {                int u=edge[i].u;int v=edge[i].to;                printf(&quot;%d %d\n&quot;,u,v);            }        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-iyyFgtvs" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-iyyFgtvs"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3436</title>
    <link href="/2020/02/07/POJ-3436/"/>
    <url>/2020/02/07/POJ-3436/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3436 ACM Computer Factory</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3436#author=yupengju" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3436#author=yupengju</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有p种零件，n个工厂加工，第i个工厂一小时可以加工Qi个电脑，对于每一个工厂第一个数字表示一小时加工数量Qi，<br>然后有p个数字，若为0则表示不能有这个零件，1则表示必须有这个零件，2表示有没有都无所谓。最后p个数字，表示加工后电脑零件的存在情况，<br>只有p个零件都为1才表示电脑加工完成。问一小时最多生产多少电脑？生产线有几条？如何设计？（special judge）（1 ≤ P ≤ 10, 1 ≤ N ≤ 50, 1 ≤ Qi ≤ 10000）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>如果一开始直接想以零件为个体来建图就相当复杂，感觉无从下手，于是就从略大一点的个体出发，从工厂出发，s为起点，t为终点，如果一开始工厂要求的零件都没有，即p个数字都是0或者2，则s–&gt;i，边权为工厂容量或者无穷大。由于工厂自身一小时生产力有限，因此要对工厂进行拆点，i–&gt;i+N，边权为工厂容量。如果一个工厂生产后电脑的零件情况与另一个工厂生产前对零件的要求情况一致，则可以连边，i+N–&gt;j，边权为无穷大。如果工厂生产后电脑的零件情况均为1，则可以连边，i+N–&gt;t,边权为无穷大或者工厂容量。<br>这样跑dinic就可以求得最大流，但是还要输出生产线的情况。如何记录呢？在建边的时候记录一下工厂最开始的容量，和边的起点。<br>跑完dinic之后，对所有的偶数边（偶数边才是正向边）判断容量是否减少了，并且起点∈[1+N,n+N],终点∈[1,N],然后储存起点，终点，流量。<br>最后依次输出即可</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10000+5;const int N=52;int head[maxn],deep[maxn],k=1,s,t,p,n,ans,u[maxn],v[maxn],w[maxn];struct node{    int to,next,w,from,tot;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].from=u;edge[k].tot=w;}struct N{    int w,r[12],c[12];}a[maxn];bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;p,&amp;n)!=EOF)    {        k=1;s=0;t=4*N;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(u,0,sizeof(u));        memset(v,0,sizeof(v));        memset(w,0,sizeof(w));        memset(a,0,sizeof(a));        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i].w);            for(int j=1;j&lt;=p;j++)            {                scanf(&quot;%d&quot;,&amp;a[i].r[j]);            }            for(int j=1;j&lt;=p;j++)            {                scanf(&quot;%d&quot;,&amp;a[i].c[j]);            }        }        for(int i=1;i&lt;=n;i++)        {            int sign=0;            for(int k=1;k&lt;=p;k++)            {                if(a[i].r[k]==1)                {                    sign=1;                    break;                }            }            if(sign==0)            {                add(s,i,a[i].w);add(i,s,0);            }            add(i,i+N,a[i].w);add(i+N,i,0);            for(int j=1;j&lt;=n;j++)            {                sign=0;                if(i==j)continue;                for(int k=1;k&lt;=p;k++)                {                    if(a[i].c[k]!=a[j].r[k]&amp;&amp;a[j].r[k]!=2)                    {                        sign=1;                        break;                    }                }                if(sign==0)                {                    add(i+N,j,0x3f3f3f3f);add(j,i+N,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            int sign=0;            for(int k=1;k&lt;=p;k++)            {                if(a[i].c[k]!=1)                {                    sign=1;                    break;                }            }            if(sign==0)            {                add(i+N,t,a[i].w);add(t,i+N,0);            }        }        dinic();        int tot=0;        for(int i=2;i&lt;=k;i+=2)        {            if(edge[i].from&gt;=1+N&amp;&amp;edge[i].from&lt;=n+N&amp;&amp;edge[i].to&gt;=1&amp;&amp;edge[i].to&lt;=n&amp;&amp;edge[i].w&lt;edge[i].tot)            {                u[++tot]=edge[i].from-N;                v[tot]=edge[i].to;                w[tot]=edge[i].tot-edge[i].w;            }        }        printf(&quot;%d %d\n&quot;,ans,tot);        for(int i=1;i&lt;=tot;i++)        {            printf(&quot;%d %d %d\n&quot;,u[i],v[i],w[i]);        }    }    return 0;}</code></pre>        <div id="aplayer-XXLXjjmA" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-XXLXjjmA"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3281</title>
    <link href="/2020/02/07/POJ-3281/"/>
    <url>/2020/02/07/POJ-3281/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3281 Dining or  P2891 [USACO07OPEN]吃饭Dining</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3281" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3281</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有F种食物和D种饮料，每种食物或饮料只能供一头牛享用，且每头牛只享用一种食物和一种饮料。<br>现在有n头牛，每头牛都有自己喜欢的食物种类列表和饮料种类列表，问最多能使几头牛同时享用到自己喜欢的食物和饮料。（1 &lt;= f &lt;= 100, 1 &lt;= d &lt;= 100, 1 &lt;= n &lt;= 100）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>我一开始想到的办法稍微有点复杂。首先着很明显是最大流问题，难点就只有建图，<br>最开始我想到的建图是一个超级源点，指向牛，然后牛指向食物，由于食物只有一次使用机会，所以食物–&gt;食物’（流量为1）表示的是，<br>该食物的数量为1，然后食物’指向牛’，牛’指向饮料，饮料–&gt;饮料’（流量为1），然后饮料’指向超级汇点。但是这种方法有问题。<br>至于问题，我现在没找到，之后再想想。</p><p>ps:后面想通了，由于牛–&gt;食物，食物–&gt;食物’，食物’–&gt;牛’；这样单次经过的牛可能不是同一头牛，会导致错乱，当然答案不对。</p><p>正确做法：显然上面的建图有点复杂了，对于牛来讲，它必须满足食物和饮料均有，所以将牛放在中间，超级源点指向牛，而每种牛只有一条，<br>所以牛–&gt;牛’（容量为1），牛’–&gt;饮料，饮料指向超级源点，跑网络流dinic就可以了</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=300000+5;const int N=101;int n,k=1,head[maxn],vis[maxn],deep[maxn],f,d,s,t,ans;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}int dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }    return ans;}int main(){//    freopen(&quot;P2891_3.in&quot;,&quot;r&quot;,stdin);    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d);    s=0;t=10*N;    for(int i=1;i&lt;=f;i++)    {        add(s,i,1);add(i,s,0);    }    for(int i=1;i&lt;=d;i++)    {        add(i+3*N,t,1);add(t,i+3*N,0);    }    for(int i=1;i&lt;=n;i++)    {        int fi,di;        scanf(&quot;%d%d&quot;,&amp;fi,&amp;di);        for(int j=1;j&lt;=fi;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(x,i+N,1);add(i+N,x,0);        }        add(i+N,i+2*N,1);add(i+2*N,i+N,0);        for(int j=1;j&lt;=di;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+2*N,x+3*N,1);add(x+3*N,i+2*N,0);        }    }    /*for(int i=1;i&lt;=n;i++)    {        add(s,i,1);add(i,s,0);    }    for(int i=1;i&lt;=n;i++)    {        int fi,di;        scanf(&quot;%d%d&quot;,&amp;fi,&amp;di);        for(int j=1;j&lt;=fi;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i,x+N,1);add(x+N,i,0);            add(x+2*N,i+3*N,1);add(i+3*N,x+2*N,0);        }        for(int j=1;j&lt;=di;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+3*N,x+4*N,1);add(x+4*N,i+3*N,0);            add(x+5*N,i+6*N,1);add(i+6*N,x+5*N,0);        }    }    for(int i=1;i&lt;=f;i++)    {        add(i+N,i+2*N,1);add(i+2*N,i+N,0);    }    for(int i=1;i&lt;=d;i++)    {        add(i+4*N,i+5*N,1);add(i+5*N,i+4*N,0);    }    for(int i=1;i&lt;=n;i++)    {        add(i+6*N,t,1);add(t,i+6*N,0);    }*/    dinic();    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-mUsyZNnz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-mUsyZNnz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2516</title>
    <link href="/2020/02/07/POJ-2516/"/>
    <url>/2020/02/07/POJ-2516/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2516 Minimum Cost</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2516" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2516</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有 n 个商店，k种物品和 m 个供货商，让你求进满足商店需求的货物的最小花费？<br>有必要说一下输入数据。<br>首先n ，k ，m。<br>然后是一个n*m的矩阵，n个商店对每种货物的需求，表示第 i 个商店需要第 j 种货物 x个?<br>然后是m * k 的矩阵，m个供货商可以供k种货物的数量，表示第 i 个供货商 提供第 j 中货物 x 个<br>接下来是 k 个 n * m 的矩阵，表示第 i 个货物，由 k 供应商发货给 j 商店的价格x<br>（注意如果供不应求的或输出-1）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始将商店分成很多，对于商品1有1-n商店，对于商品2有n+1-2<em>n商店，对于商品k有n</em>（k-1）-n<em>k商店。<br>对于供货商也是同理，s为起点，与商店连接，边权为商店对该物品的需求，费用为0，t为终点，供货商与t连接，边权为供货商能提供的量，费用为0，然后有后面k个矩阵可以建图，商店与供货商连接，注意要一一对应，因为商店和供货商相当于拆了点了，边权为无穷大，费用为价格。<br>但是最后跑费用流就凉了，TLE！！！难受！<br>然后看了一下题解，题解的办法是对于每次的商品来跑费用流，就不需要对商店和供货商进行拆点，跑k次费用流。<br>如果maxflow==需求，就输出mincost，否则就输出-1<br>TLE原因：SPFA费用流算法在稠密图上运行比较慢。可以将一个稠密大图拆成多个小图，虽然小图依然是稠密图，但是减少的幅度是非常大的。<br>从2500</em>2500到50*50.这样，只需建K次图，跑K遍SPFA费用流即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N=3000+5;const int maxn=40000+5;int k=1,sign,ans,n,m,q,s,t,head[maxn],dist[maxn],vis[maxn],flow[maxn],pre[maxn],last[maxn],maxflow,mincost,rd[52][52],cd[52][52];struct node{    int to,next,w,dis;}edge[maxn*2];void add(int u,int v,int w,int dis){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].dis=dis;}bool spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(flow,0x3f3f3f3f,sizeof(flow));    memset(vis,0,sizeof(vis));    memset(pre,0,sizeof(pre));    memset(last,0,sizeof(last));    vis[s]=1;dist[s]=0;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].dis&amp;&amp;edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].dis;                pre[edge[i].to]=x;                last[edge[i].to]=i;                flow[edge[i].to]=min(flow[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return pre[t];}void MCMF(){    while(spfa())    {        maxflow+=flow[t];        mincost+=flow[t]*dist[t];        int now=t;        while(now!=s)        {            edge[last[now]].w-=flow[t];            edge[last[now]^1].w+=flow[t];            now=pre[now];        }    }}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q)!=EOF)    {        s=0;t=N*5;        k=1;ans=0;sign=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        maxflow=0;mincost=0;        if(n==0&amp;&amp;m==0&amp;&amp;q==0)break;        int tot=0;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=q;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                tot+=x;                rd[i][j]=x;            }        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=q;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                cd[i][j]=x;            }        }        for(int i=1;i&lt;=q;i++)        {            k=1;            memset(head,0,sizeof(head));            memset(edge,0,sizeof(edge));            maxflow=0;mincost=0;            for(int j=1;j&lt;=n;j++)            {                add(s,j,rd[j][i],0);add(j,s,0,0);            }            for(int j=1;j&lt;=m;j++)            {                add(j+N,t,cd[j][i],0);add(t,j+N,0,0);            }            for(int j=1;j&lt;=n;j++)            {                for(int p=1;p&lt;=m;p++)                {                    int x;scanf(&quot;%d&quot;,&amp;x);                    add(j,p+N,0x3f3f3f3f,x);add(p+N,j,0,-x);                }            }            MCMF();            ans+=mincost;            sign+=maxflow;        }        if(sign==tot)        printf(&quot;%d\n&quot;,ans);        else         printf(&quot;-1\n&quot;);    }    return 0;}</code></pre>        <div id="aplayer-WeVcDkSz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-WeVcDkSz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2195</title>
    <link href="/2020/02/07/POJ-2195/"/>
    <url>/2020/02/07/POJ-2195/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2195 Going Home</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2195#author=hrbustacm" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2195#author=hrbustacm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>免费送房子，m表示人，H表示房子，每个房子只能进一个人，房子数等于人数。<br>黄弘毅为了方便起见决定要让所有人到自己的房子的距离和最小，请问这个距离和是多少？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>距离和，这个问题一看显然就是费用流问题，而此题就是最小费用流的裸题，将人和房子统计出来，然后s与人连边，边权为1，费用dis为0，房子与t连边，边权为0，费用dis为0，人与房子连边，边权为1，费用dis为曼哈顿距离。然后跑MCMF就可以了。</p><p>ps：我麻烦了一点，对房子进行了拆点，其实可以不拆，毕竟与t相连，流量固定了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int n,m,k=1,s,t,head[maxn],flow[maxn],dist[maxn],x1[maxn],x2[maxn],y1[maxn],y2[maxn];int vis[maxn],maxflow,mincost,pre[maxn],last[maxn];struct node{    int to,next,w,dis;}edge[maxn*2];void add(int u,int v,int w,int dis){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].dis=dis;}bool spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(flow,0x3f3f3f3f,sizeof(flow));    memset(vis,0,sizeof(vis));    memset(pre,0,sizeof(pre));    memset(last,0,sizeof(last));    vis[s]=1;dist[s]=0;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].dis&amp;&amp;edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].dis;                pre[edge[i].to]=x;                last[edge[i].to]=i;                flow[edge[i].to]=min(flow[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return pre[t];}void MCMF(){    while(spfa())    {        maxflow+=flow[t];        mincost+=flow[t]*dist[t];        int now=t;        while(now!=s)        {            edge[last[now]].w-=flow[t];            edge[last[now]^1].w+=flow[t];            now=pre[now];        }    }}int main(){    while(1)    {        s=0,t=4*N;        int tot1=0,tot2=0;        maxflow=0;mincost=0;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(x1,0,sizeof(x1));        memset(x2,0,sizeof(x2));        memset(y1,0,sizeof(y1));        memset(y2,0,sizeof(y2));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=0;j&lt;x.length();j++)            {                if(x[j]==&#39;m&#39;)                {                    tot1++;x1[tot1]=j+1;y1[tot1]=i;                }                else if(x[j]==&#39;H&#39;)                {                    tot2++;x2[tot2]=j+1;y2[tot2]=i;                }            }        }        for(int i=1;i&lt;=tot1;i++)        {            add(s,i,1,0);add(i,s,0,0);            for(int j=1;j&lt;=tot2;j++)            {                int w=abs(x1[i]-x2[j])+abs(y1[i]-y2[j]);                add(i,j+N,1,w);add(j+N,i,0,-w);            }        }        for(int i=1;i&lt;=tot2;i++)        {            add(i+N,t,1,0);add(t,i+N,0,0);        }        MCMF();        printf(&quot;%d\n&quot;,mincost);    }    return 0;}</code></pre>        <div id="aplayer-KQJXwPqB" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KQJXwPqB"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1459</title>
    <link href="/2020/02/07/POJ-1459/"/>
    <url>/2020/02/07/POJ-1459/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1459 Power Network</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1459#author=alexandleo" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1459#author=alexandleo</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>每组测试数据给出N，Np，Nc，M。N代表结点数量，M代表边的数量，Np代表结点中电站的数量（只产电，不耗电），<br>Nc代表消费者数量（只耗电，不产电），其他结点代表中转站（不产电，不耗电）。<br>接着M组（u，v）w数据，代表u到v容量为w，接着Np组（u）w，代表结点u产电w，接着Nc组（u）w，代表结点u耗电w。<br>求电网中能消耗的最大电能值。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>求最大电能，显然这是最大流问题，s与所有的电站连接，边权为产电量，t与所有的消费者连接，边权为耗电量，然后根据m条边的信息，<br>如果u，v属于电站，则值不变，如果不是电站，那么需要+N，成为另一个集合，再建边，边权为容量w，然后跑网络流dinic。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=205;int k=1,s,t,head[maxn],deep[maxn],n,m,np,nc,ans,vis[maxn],u[maxn],v[maxn],w[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;np,&amp;nc,&amp;m)!=EOF)    {        ans=0;        k=1;        memset(head,0,sizeof(head));        memset(vis,0,sizeof(vis));        t=N*5;s=t+1;        for(int i=1;i&lt;=m;i++)        {            char x,y,z;            int a,b,c;            cin&gt;&gt;x&gt;&gt;a&gt;&gt;y&gt;&gt;b&gt;&gt;z&gt;&gt;c;            u[i]=a;v[i]=b;w[i]=c;        }        for(int i=1;i&lt;=np;i++)        {            int b,c;char x,y;            cin&gt;&gt;x&gt;&gt;b&gt;&gt;y&gt;&gt;c;            add(s,b,c);add(b,s,0);            vis[b]=1;        }        for(int i=1;i&lt;=m;i++)        {            if(!vis[u[i]])u[i]+=N;            if(!vis[v[i]])v[i]+=N;            add(u[i],v[i],w[i]);add(v[i],u[i],0);        }        for(int i=1;i&lt;=nc;i++)        {            int b,c;char x,y;            cin&gt;&gt;x&gt;&gt;b&gt;&gt;y&gt;&gt;c;            add(b+N,t,c);add(t,b+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-MKtMWFZq" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-MKtMWFZq"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1087</title>
    <link href="/2020/02/07/POJ-1087/"/>
    <url>/2020/02/07/POJ-1087/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1087 A Plug for UNIX</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1087#author=cjyl" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1087#author=cjyl</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>宾馆里有几种插座，分别有其对应型号，你携带了几种用电器（手机，电脑一类的），也有其对应型号；<br>可是不一定用电器就能和插座匹配上，于是宾馆的商店里提供了一些转换器，这些转换器可以将某一型号电源转换成另一型号的。<br>问，你的用电器最少会有多少种无法充电 。注意插座型号是字符串形式，长度小于24，用电器名称也是字符串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是最大流问题。先说一下细节，插座和用电器的数量肯定都只有一个，但是转换器的数量是无限的。<br>建图：设起点为s，终点为t，首先s与所有的用电器相连，边权为1，（一开始还想着拆点，我怕是个哈批啊，对于两边的点，边权就是容量，<br>不需要去拆点！），t与所有的插座相连。如果型号相同，就可以二者之间进行连边。然后对于转换器，转换器之间可以相连，并且转换可以实现A–&gt;B，<br>也可以实现B–&gt;A。所以，对于用电器型号=A||B的都可以连边，对于插座型号=A||B的都可以连边，边权为1，对于转换器之间可以相连的，直接连接，<br>由于容量无穷大，因此不必拆点！</p><p>代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;const int maxn=300000+5;const int N=200+5;int s,t,n,k=1,m,q,ans,head[maxn],deep[maxn];char r[maxn][25],mr[maxn][25],mc[maxn][25];struct node{    int to,next,w;}edge[maxn*2];struct N{    char s[40];char r[25];}a[maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        s=0;t=4*N;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,r[i]);        }        scanf(&quot;%d&quot;,&amp;q);        for(int i=1;i&lt;=q;i++)        {            add(s,i,1);add(i,s,0);            char x;            scanf(&quot;%s%s&quot;,a[i].s,a[i].r);        }        for(int i=1;i&lt;=q;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(strcmp(a[i].r,r[j])==0)                {                    add(i,j+N,1);add(j+N,i,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            add(i+N,t,1);add(t,i+N,0);        }        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%s%s&quot;,mr[i],mc[i]);            for(int j=1;j&lt;=q;j++)            {                if(strcmp(a[j].r,mr[i])==0||strcmp(a[j].r,mc[i])==0)                {                    add(j,i+2*N,1);add(i+2*N,j,0);                }            }            for(int j=1;j&lt;=n;j++)            {                if(strcmp(r[j],mc[i])==0||strcmp(r[j],mr[i])==0)                {                    add(i+2*N,j+N,1);add(j+N,i+2*N,0);                }            }        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=m;j++)            {                if(i!=j&amp;&amp;strcmp(mc[i],mr[j])==0)                {                    add(i+2*N,j+2*N,0x3f3f3f3f);add(j+2*N,i+2*N,0);                }            }            for(int j=1;j&lt;=m;j++)            {                if(i!=j&amp;&amp;strcmp(mr[i],mc[j])==0)                {                    add(i+2*N,j+2*N,0x3f3f3f3f);add(j+2*N,i+2*N,0);                }            }        }        dinic();        printf(&quot;%d\n&quot;,q-ans);    }    return 0;}    </code></pre>        <div id="aplayer-lNxPIfZR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-lNxPIfZR"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4292</title>
    <link href="/2020/02/07/HDU-4292/"/>
    <url>/2020/02/07/HDU-4292/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4292 Food</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4292#author=yupengju" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4292#author=yupengju</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>昊妈决定只给每个人一种食物和一种饮料，而且每种饮料和食物都只能提供有限次。现在给出每个人喜欢的食物种类和饮料种类，<br>昊妈可以最多让多少人得到满足呢？第一行给出N F D表示人数，食物种类数，饮料种类数第二行给出F个数字表示第i种食物有几个第三行给出D个数字<br>表示第i种饮料有几个接下来N行分别给出第i个人对第j种食物的喜爱情况，Y是喜欢N是不喜欢，再来N行对饮料的</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题是最大流问题，重点自然就是建图，一个人要满足，必须同时拥有食物和饮料。而一个人也最多可以满足一次，<br>而且饮料和食物的容量也是有限的。最简单的自然是食物连向起点，边权为食物的容量；饮料连向中点，边权为饮料的容量；如果某人i喜欢食物j，<br>那么二者就要连边，即j–&gt;i+N，边权为1，并且人位于中间必须拆点，即i+N–&gt;i+2<em>N,边权为1。如果某人i喜欢饮料j，那么i+2</em>N–&gt;j+3*N，边权为1<br>建好后跑dinic。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int k=1,n,f,d,deep[maxn],head[maxn],ans,s,t;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(edge[i].w&amp;&amp;!deep[edge[i].to])            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d)!=EOF)    {        k=1;s=0;t=5*N;ans=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=f;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(s,i,x);add(i,s,0);        }        for(int i=1;i&lt;=d;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+3*N,t,x);add(t,i+3*N,0);        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=1;j&lt;=f;j++)            {                if(x[j-1]==&#39;Y&#39;)                {                    add(j,i+N,1);add(i+N,j,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=1;j&lt;=d;j++)            {                if(x[j-1]==&#39;Y&#39;)                {                    add(i+2*N,j+3*N,1);add(j+3*N,i+2*N,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            add(i+N,i+2*N,1);add(i+2*N,i+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-aODIwKIt" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-aODIwKIt"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4289</title>
    <link href="/2020/02/07/HDU-4289/"/>
    <url>/2020/02/07/HDU-4289/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4289 Control</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4289" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4289</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个无向图，有些不法分子要从S点T点，现在要抓住所有的不法分子阻止他们去T，那么就要控制某一些城市等待他们，<br>控制每个城市花费不同，问最少花费是多少。第一行是两个整数N，M（2&lt;=N&lt;=200，1&lt;=M&lt;=20000）,分别表示城市数量和道路数量，<br>城市的编号为1到N。 第二行是两个整数S，T（1&lt;=S,T&lt;=N）,分别表示起点和终点的位置。 接下来以下N行，分别表示控制第每一个城市的成本costi<br>（cost&lt;10^7）。 接下来M行，每行有两个整数A，B表示城市A和B之间存在一条双向道路。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>根据题意，要设法将S，T分割开，求最小花费，显然是求图的最小割，即求最大流。一开始想着单独将S，T隔开，<br>无向边u，v建边：u+N–&gt;v,边权0x3f3f3f3f，v+N-&gt;u，边权0x3f3f3f3f，当然回路也要建立。然后跑dinic，然后将跑出来的最大流和单独隔离s、单独隔离t三者取最小。但是这样跑出来不对。</p><p>错误原因就是：这是双向图，s可以作为起点，也可以作为中间点。</p><p>正确做法是：无向边u，v建边：u+N–&gt;v,边权0x3f3f3f3f，v+N-&gt;u，边权0x3f3f3f3f，当然回路也要建立，然后u–&gt;u+N,边权为cost。<br>然后从s–&gt;t+N，跑dinic，求最大流。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=50000+5;const int N=200+5;int k=1,n,m,s,t,ans,head[maxn],deep[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F-f));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        k=1;ans=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);t+=N;        for(int i=1;i&lt;=n;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i,i+N,x);add(i+N,i,0);        }        for(int i=1;i&lt;=m;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a+N,b,0x3f3f3f3f);add(b,a+N,0);            add(b+N,a,0x3f3f3f3f);add(a,b+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-OBODMdxv" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-OBODMdxv"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4280</title>
    <link href="/2020/02/07/HDU-4280/"/>
    <url>/2020/02/07/HDU-4280/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4280 Island Transport</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4280#author=smilestruggler" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4280#author=smilestruggler</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在n个岛屿中，有m条双向航线，航线有单位时间内的运输上限，现在求从最左侧到最右侧的最大运输</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题意含明显它是最大流的模板题，直接建边，然后找到起点s和终点t就可以了，然后直接跑dinic。但是n=100000，m=100000，数据规模大，<br>dinic容易超时，但是我们可以做优化。</p><p>优化1：bfs只要跑到t就返回1，开始dfs。</p><p>优化2；dfs内每次min(F-f,edge[i].w），f表示之前已经流过的流量，F-f表示剩余可流的流量，一旦F==f就break，表示满流了！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int T,n,m,s,t,head[maxn],deep[maxn],k=1,ans;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        ans=0;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        int minn=0x3f3f3f3f,maxx=-0x3f3f3f3f;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            if(minn&gt;x)            {                minn=x;                s=i;            }            if(maxx&lt;x)            {                maxx=x;                t=i;            }        }        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);            add(b,a,c);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-tvWzSWmK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-tvWzSWmK"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3605</title>
    <link href="/2020/02/07/HDU-3605/"/>
    <url>/2020/02/07/HDU-3605/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3605 Escape</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3605" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3605</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个人，m个星球，前n行，每一行有m个数字，分别表示第i个星球是否适合这个人。最后一行有m个，表示每个星球的最多居住人数。n (1 &lt;= n &lt;= 100000), m (1 &lt;= m &lt;= 10)</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始想多没想就开始建裸图，心里想：别看着图稠密，边多，实际上一跑就出结果了。事实证明自己太天真，n<em>n</em>m的数据量早就TLE！<br>正确做法有点意思：由于m很小，就可以考虑状态压缩。对于第i个人，m个星球的居住情况已知，转换为二进制储存，所有的状态也不过才2^10而已，<br>起点s连向状态，边权为这种状态的总人数，然后10个星球与这种状态匹配，若星球属于这个状态，则状态连向星球，边权为无穷大，<br>然后星球与终点t连接，边权为星球的最大居住人数。然后就可以跑dinic了，若ans==n，就YES，否则就NO。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=5000;int k=1,head[maxn],deep[maxn],n,m,s,t,ans,now[1&lt;&lt;11];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        s=0,t=2*N;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(now,0,sizeof(now));        ans=0;        for(int i=1;i&lt;=n;i++)        {            int state=0;            for(int j=1;j&lt;=m;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                if(x==1)                {                    state=state|(1&lt;&lt;(j-1));                }            }            now[state]++;        }        for(int i=0;i&lt;=(1&lt;&lt;m)-1;i++)        {            if(now[i])            {                add(s,i,now[i]);add(i,s,0);                for(int j=1;j&lt;=m;j++)                {                    if((i&amp;(1&lt;&lt;(j-1)))&gt;0)                    {                        add(i,N+j,0x3f3f3f3f);add(N+j,i,0);                    }                }            }        }        for(int i=1;i&lt;=m;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(N+i,t,x);add(t,N+i,0);        }        dinic();        if(n==ans)        {            printf(&quot;YES\n&quot;);        }        else         {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-hZdhrspm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-hZdhrspm"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3081</title>
    <link href="/2020/02/07/HDU-3081/"/>
    <url>/2020/02/07/HDU-3081/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3081 Marriage Match II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3081" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3081</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有N个女孩要与N个男孩玩配对游戏.每个女孩有一个可选男孩的集合(即该女孩可以选自己集合中的任意一个男孩作为该轮的搭档).<br>然后从第一轮开始,每个女孩都要和一个不同的男孩配对.如果第一轮N个女孩都配对成功,那么就开始第二轮配对,女孩依然从自己的备选男孩集合中选择,<br>但是不能选那些已经被该女孩在前几轮选择中选过的男孩了(比如i女孩在第一轮选了j男孩,那么i在第二轮就不能选j男孩了). 问你游戏最多能进行多少轮?</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>女生:1<del>n;男生:(n+1)</del>(n*2)。对于女生u，她可以直接连向不讨厌的男生，边权为1。</p><p>假设我们当前二分尝试的轮数为K(即能够进行K轮匹配):首先如果女孩i可能选择男孩j,那么就有边(i, j+n, 1).且源点到每个女孩i有边(s,i,K),<br>每个男孩j到汇点t有边(j+n,t,K).</p><p>如果最大流==K*n,那么就表示可以进行最少K轮匹配.</p><p>证明：如果满流,那么每个女生肯定选择了K个不同的男孩,每个男孩肯定被K个不同的女孩选择了(因为一个女孩到一个男孩边容量只为1,所以该女孩最多只能选该男孩一次).<br> 那么上面这样就能保证这个游戏可以进行K轮吗?可以的,假设当前图的流量为0,说明任何女孩都没选男孩. 你可以想象假如此时从S到所有女孩有流量1<br>(虽然容量是K,但是目前我们只放出1流量)流出,那么这些流量肯定会汇集到t(因为最大流为K<em>n,而我们此时只不过n流量).<br>这个汇集的过程就是第一轮女孩选择了各自不同男孩的结果. 现在从S到所有女孩又有流量1流出(即第二轮开始了),<br>这些流量肯定又经过了n个男孩汇集到t点了 且 如果上一轮i女孩的流量走到j男孩,这一轮i女孩的流量肯定不走j男孩了(因为i女孩到j男孩的边只有1容量).<br>综上所述,只要最大流==K</em>n,那么就能进行K轮.</p><p>即如果女孩{1,2,3,4,5,6,7,8,9}是朋友的话,且2号女孩能选择男孩3,我们如果标记来使得其他所有女孩都能选择男孩3呢?<br>我选择的是闭包传递，当然也可以用并查集。<br>ps：不要把男孩也算进,比如女孩1与男孩2能选,女孩3与男孩2能选,但是女孩1与女孩3可不是朋友,她们不属于同一个并查集。<br>一开始这里就出了问题。如果我们dist[a][b+N]=1,而dist[b+N][a]不管，就不存在问题了！</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int k=1,head[maxn],deep[maxn],s,t,n,m,ans,T,f,dist[N][N];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}bool solve(int mid){        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        ans=0;        for(int i=1;i&lt;=n;i++)        {            add(s,i,mid);add(i,s,0);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=n+1;j&lt;=2*n;j++)            {                if(dist[i][j]==0x3f3f3f3f)continue;                add(i,j,1);add(j,i,0);            }        }        for(int i=1+n;i&lt;=n*2;i++)        {            add(i,t,mid);add(t,i,0);        }        dinic();        if(ans==mid*n)return 1;        return 0;}int main(){    //1-ngirl,(n+1)-(2*n)boy    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        ans=0;        s=0,t=8*N;        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;f);        memset(dist,0x3f3f3f3f,sizeof(dist));        for(int i=1;i&lt;=m;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b+n]=1;        }        for(int i=1;i&lt;=f;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b]=dist[b][a]=1;        }        for(int K=1;K&lt;=2*n;K++)        {            for(int i=1;i&lt;=2*n;i++)            {                for(int j=1;j&lt;=2*n;j++)                {                    if(dist[i][K]==1&amp;&amp;dist[K][j]==1)                    {                        dist[i][j]=1;                    }                }            }        }        int l=0,r=n,ANS=0;        while(l&lt;=r)        {            int mid=(l+r)/2;            if(solve(mid))            {                ANS=mid;                l=mid+1;            }            else r=mid-1;        }        printf(&quot;%d\n&quot;,ANS);    }    return 0;}</code></pre>        <div id="aplayer-gTeuvNQe" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-gTeuvNQe"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>二分</tag>
      
      <tag>闭包传递</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2732</title>
    <link href="/2020/02/07/HDU-2732/"/>
    <url>/2020/02/07/HDU-2732/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h3><p>HDU - 2732 Leapin’ Lizards</p><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://vjudge.net/problem/HDU-2732" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2732</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>题目是说一个n*m的迷宫中，有每个格子有柱子。柱子高度为0~3，高度为0的柱子是不能站的（高度为0就是没有柱子）<br>在一些有柱子的格子上有一些蜥蜴，一次最多跳距离d,相邻格子的距离是1，只要跳出迷宫就是安全的。这个距离是曼哈顿距离（好像是的）<br>。蜥蜴一次最多跳距离d,但是起跳的地方的柱子高度会减一，一个柱子同一时间只能有一个蜥蜴要求最少几个不能逃出迷宫。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最大流问题，求出dinic跑出的最大流，然后总数-ans就是剩余的数。建图方法：</p><p>1.每个柱子有容纳量，超过了就塌了。u–&gt;u’ 边权为容纳量</p><p>2.有蜥蜴的柱子与起点s相连，即s–&gt;u,边权为1</p><p>3.边界上可以跳出界的与终点相连，条件(x1&lt;=p||y1&lt;=p||n-x1+1&lt;=p||len-y1+1&lt;=p)&amp;&amp;h[x1][y1]，u’–&gt;t,边权0x3f3f3f3f</p><p>4.任意两个有容纳量的柱子，且曼哈顿距离&lt;=d，可以相连，即u’–&gt;v,v’-&gt;u，边权为0x3f3f3f3f.</p><p>ps：1.注意输出时候单复数！<br>2.注意是j+(i-1)*len(len 表示一行的列数！！！）一开始写成了n，WA了一片。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int N=500+5;int k=1,head[maxn],deep[maxn],s,t,n,m,T,ans,p,h[30][N*10];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=0;    while(T--)    {        opt++;        k=1;ans=0;s=0;t=5*N;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(h,0,sizeof(h));        scanf(&quot;%d%d&quot;,&amp;n,&amp;p);        int len=0;int tot=0;        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;len=x.length();            for(int j=1;j&lt;=len;j++)            {                int w=x[j-1]-&#39;0&#39;;h[i][j]=w;                if(w)                {                    add(j+(i-1)*len,j+(i-1)*len+N,w);add(j+(i-1)*len+N,j+(i-1)*len,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;len=x.length();            for(int j=1;j&lt;=len;j++)            {                if(x[j-1]==&#39;L&#39;)                {                    tot++;                    add(s,j+(i-1)*len,1);add(j+(i-1)*len,s,0);                }            }        }        for(int x1=1;x1&lt;=n;x1++)        {            for(int y1=1;y1&lt;=len;y1++)            {                for(int x2=1;x2&lt;=n;x2++)                {                    for(int y2=1;y2&lt;=len;y2++)                    {                        if(x1==x2&amp;&amp;y1==y2)continue;                        if(abs(x1-x2)+abs(y1-y2)&gt;p)continue;                        if(!h[x1][y1]||!h[x2][y2])continue;                        add(y1+(x1-1)*len+N,y2+(x2-1)*len,0x3f3f3f3f);add(y2+(x2-1)*len,y1+(x1-1)*len+N,0);                        add(y2+(x2-1)*len+N,y1+(x1-1)*len,0x3f3f3f3f);add(y1+(x1-1)*len,y2+(x2-1)*len+N,0);                    }                }            }        }        for(int x1=1;x1&lt;=n;x1++)        {            for(int y1=1;y1&lt;=len;y1++)            {                if((x1&lt;=p||y1&lt;=p||n-x1+1&lt;=p||len-y1+1&lt;=p)&amp;&amp;h[x1][y1])                {                    add(y1+(x1-1)*len+N,t,0x3f3f3f3f);add(t,y1+(x1-1)*len+N,0);                }            }        }        dinic();        printf(&quot;Case #%d: &quot;,opt);        if(ans==tot)        {            printf(&quot;no lizard was left behind.\n&quot;);            continue;        }        else if(tot-ans==1)        {            printf(&quot;1 lizard was left behind.\n&quot;);        }        else         {            printf(&quot;%d lizards were left behind.\n&quot;,tot-ans);        }    }    return 0;}</code></pre>        <div id="aplayer-tPLIXUWn" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-tPLIXUWn"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
