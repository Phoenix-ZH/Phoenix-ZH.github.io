<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Educational Codeforces Round 104 (Rated for Div. 2)</title>
    <link href="/2021/02/16/Educational%20Codeforces%20Round%20104%20(Rated%20for%20Div.%202)/"/>
    <url>/2021/02/16/Educational%20Codeforces%20Round%20104%20(Rated%20for%20Div.%202)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-Arena"><a href="#A-Arena" class="headerlink" title="A. Arena"></a>A. Arena</h1><p><img src="https://img-blog.csdnimg.cn/20210216104018869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>比赛次数无限次，赢了的人可以等级+1，问有多少个人可以赢。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举a[i]&gt;a<a href="1&lt;i&lt;=n">1</a>的个数即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=100+50;int T,n,m,a[maxn];int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        sort(a+1,a+1+n);        int tot=0;        for(int i=2;i&lt;=n;i++){            if(a[i]&gt;a[1]){                tot++;            }        }        cout&lt;&lt;tot&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="B-Cat-Cycle"><a href="#B-Cat-Cycle" class="headerlink" title="B. Cat Cycle"></a>B. Cat Cycle</h1><p><img src="https://img-blog.csdnimg.cn/20210216104207961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>A的顺序是n,n-1,n-2,…,3,2,1,n,n-1…;B的顺序是1,2,3,…,n,1,2…如果某一时刻B的值与A相等，那么B就顺次再移动一次（即B的一小时相当于跳了两格，而正常情况下跳一格）,问在k小时，B的位置是多少？</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>假如n=5：</p><p>时刻:1,2,3,4,5,6,7,8,9…<br>   A：5,4,3,2,1,5,4,3,2,1,5,4,3,2,1,5,4,3,2,1…<br>   B：1,2,4,5,2,3,5,1,3,4,1,2,4,5,2,3,5,1,3,4…</p><p>B发生跳跃的时刻是3，5，7，9…</p><p>假如n=7：</p><p>A：7,6,5,4,3,2,1,7,6,5,4,3,2,1,7,6,5,4,3,2,1…<br>B：1,2,3,5,6,7,2,3,4,6,7,1,3,4,5,7,1,2,4,5,6…</p><p>B发生跳跃的时刻是4 ，7，10，13…</p><p>假如n=4：</p><p>A:4,3,2,1,4,3,2,1…<br>B:1,2,3,4,1,2,3,4…</p><p>A与B的值不会发生重叠</p><p>所以规律就是：如果n是偶数，B正常跳即可；如果n是奇数，B会在(n+1)/2,(n+1)/2+(n+1)/2-1,(n+1)/2*3-2…多跳一格。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,n,k;int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n&gt;&gt;k;        if(n%2==0){            k%=n;            if(k==0)k=n;            cout&lt;&lt;k&lt;&lt;endl;        }        else{            ll t=(n+1)/2-1;            ll cnt=(k-1)/t;            k+=cnt;            k%=n;            if(k==0)k=n;            cout&lt;&lt;k&lt;&lt;endl;        }    }    return 0;}</code></pre><h1 id="C-Minimum-Ties"><a href="#C-Minimum-Ties" class="headerlink" title="C. Minimum Ties"></a>C. Minimum Ties</h1><p><img src="https://img-blog.csdnimg.cn/20210216105444315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>一共有n(n-1)/2场比赛，输出n(n-1)/2个整数，分别表示1队VS2队，1队VS3队，1队VSn队，2队VS3队的比赛结果，1表示左边的队伍胜利，-1表示左边的队伍失败，0表示平均，胜利的队得3分，失败的队不得分，平均各得一分。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>一共n(n-1)/2场比赛，最多就n(n-1)/2个场次有队伍可以胜利，平摊给每一个队就是(n-1)/2,但是可能存在(n-1)%2==1，那么就必须每个队伍需要平局，否则，每个队胜利(n-1)/2即可，其余n-1场失败就可以了。对于平均可以1~2、3~4、5~6…平局。假设平均胜利场次pwin=(n-1)/2,平均失败场次plose=n-1-pwin-pp(pp表示是否存平局，0表示不存在，1表示存在)，对于每次枚举的主场队伍i，如果它还需要胜利，并且对手j还需要失败，就让i胜利，否则就让它失败。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+50;int T,n,win[maxn],lose[maxn];int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n;        memset(win,0,sizeof(int)*(n+10));        memset(lose,0,sizeof(int)*(n+10));        int tot=(n-1)*n/2;        int pp=(tot%n)*2/n;        int pwin=tot/n;        int plose=n-1-pwin-pp;        int sign=0;        if(pp)sign=1;        for(int i=1;i&lt;=n;i++){            for(int j=i+1;j&lt;=n;j++){                if(sign&amp;&amp;i%2){                    if(j==i+1){                        cout&lt;&lt;0&lt;&lt;&#39; &#39;;                    }                    else{                        if(win[i]&lt;pwin&amp;&amp;lose[j]&lt;plose){                            cout&lt;&lt;1&lt;&lt;&#39; &#39;;                            win[i]++;lose[j]++;                        }                        else cout&lt;&lt;-1&lt;&lt;&#39; &#39;;                    }                }                else{                    if(win[i]&lt;pwin&amp;&amp;lose[j]&lt;plose){                            cout&lt;&lt;1&lt;&lt;&#39; &#39;;                            win[i]++;lose[j]++;                        }                        else cout&lt;&lt;-1&lt;&lt;&#39; &#39;;                }            }        }        cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-Pythagorean-Triples"><a href="#D-Pythagorean-Triples" class="headerlink" title="D. Pythagorean Triples"></a>D. Pythagorean Triples</h1><p><img src="https://img-blog.csdnimg.cn/20210216110446346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>问1&lt;=a&lt;=b&lt;=c&lt;=n中，有多少个(a,b,c)满足</p><script type="math/tex; mode=display">c=a^2-b(1)</script><script type="math/tex; mode=display">c^2=a^2+b^b(2)</script><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>将(1)完全平方得：</p><script type="math/tex; mode=display">c^2=a^4-2a^2b+b^2</script><p>和(2)  联立得：</p><script type="math/tex; mode=display">a^4-2a^2b-a^2=0-->a^2-1=2b</script><p>所以：</p><script type="math/tex; mode=display">b=(a^2-1)/2</script><p>而</p><script type="math/tex; mode=display">c=(a^2+1)/2</script><p>注意条件1&lt;=a&lt;=b&lt;=c&lt;=n,并且a <em> a -1和a </em> a+1要是偶数。直接枚举a（1&lt;=a&lt;=sqrt(2*n+1)）</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,n;int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n;        ll ans=0;        ll up=sqrt(2*n+1);        for(ll a=1;a&lt;=up;a++){            if((a*a-1)%2)continue;            ll b=(a*a-1)/2;            if(b&lt;a||b&gt;n)continue;            if((a*a+1)%2)continue;            ll c=(a*a+1)/2;            if(c&lt;b||c&gt;n)continue;            ans++;        }        cout&lt;&lt;ans&lt;&lt;endl;    }        return 0;}</code></pre><h1 id="E-Cheap-Dinner"><a href="#E-Cheap-Dinner" class="headerlink" title="E. Cheap Dinner"></a>E. Cheap Dinner</h1><p><img src="https://img-blog.csdnimg.cn/20210216111200407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>有n1个first courses,n2个second courses，n3个 drinks，n4个 desserts，a[],b[],c[],d[]分别对应价格，m1组xi，yi表示第xi种first courses和第y种second courses不可搭配，m2、m3组xi，yi同理。问搭配出合理套餐的最低价，如果不能搭配就输出-1.</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>对于n2个second courses，它最多就只有m1对first courses不能搭配，如果我们找到每一个second courses搭配出first courses的最低价由此更新second courses，即bi=bi+min{ai}，先将a[]从小到大排好，然后用vector<int>储存second courses不能搭配的first courses，然后对vector<int>s[i]排序，找到第i个second courses可以搭配的最便宜的first courses。同理对于drinks、desserts亦可以用上述的办法，ci=ci+min{bi},di=di+min{ci};显然min{di}就是答案</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=200000+50;ll T,n1,n2,n3,n4,m1,m2,m3,id[maxn];vector&lt;int&gt;s[maxn];struct Node{    ll w,id;}a[maxn],b[maxn],c[maxn],d[maxn];bool cmp(Node x,Node y){    if(x.w==y.w)return x.id&lt;y.id;    return x.w&lt;y.w;}int main(){    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;n3&gt;&gt;n4;    for(int i=1;i&lt;=n1;i++)cin&gt;&gt;a[i].w,a[i].id=i;    for(int i=1;i&lt;=n2;i++)cin&gt;&gt;b[i].w,b[i].id=i;    for(int i=1;i&lt;=n3;i++)cin&gt;&gt;c[i].w,c[i].id=i;    for(int i=1;i&lt;=n4;i++)cin&gt;&gt;d[i].w,d[i].id=i;    sort(a+1,a+1+n1,cmp);    for(int i=1;i&lt;=n1;i++)id[a[i].id]=i;    cin&gt;&gt;m1;    for(int i=1;i&lt;=m1;i++){        int x,y;cin&gt;&gt;x&gt;&gt;y;        s[y].push_back(id[x]);    }    for(int i=1;i&lt;=n2;i++){        int opt=1;        sort(s[i].begin(),s[i].end());        for(int j=0;j&lt;s[i].size();j++){            if(s[i][j]==opt){                opt++;            }            else{                break;            }        }        if(opt==n1+1)b[i].w=1e9;        else b[i].w+=a[opt].w;    }    sort(b+1,b+1+n2,cmp);    for(int i=1;i&lt;=n2;i++)id[b[i].id]=i;    cin&gt;&gt;m2;    for(int i=1;i&lt;=150000;i++)s[i].clear();    for(int i=1;i&lt;=m2;i++){        int x,y;cin&gt;&gt;x&gt;&gt;y;        s[y].push_back(id[x]);    }    for(int i=1;i&lt;=n3;i++){        int opt=1;        sort(s[i].begin(),s[i].end());        for(int j=0;j&lt;s[i].size();j++){            if(s[i][j]==opt){                opt++;            }            else{                break;            }        }        if(opt==n2+1)c[i].w=1e9;        else c[i].w+=b[opt].w;        if(c[i].w&gt;=1e9)c[i].w=1e9;    }    sort(c+1,c+1+n3,cmp);    for(int i=1;i&lt;=n3;i++)id[c[i].id]=i;    cin&gt;&gt;m3;    for(int i=1;i&lt;=150000;i++)s[i].clear();    for(int i=1;i&lt;=m3;i++){        int x,y;cin&gt;&gt;x&gt;&gt;y;        s[y].push_back(id[x]);    }    for(int i=1;i&lt;=n4;i++){        int opt=1;        sort(s[i].begin(),s[i].end());        for(int j=0;j&lt;s[i].size();j++){            if(s[i][j]==opt){                opt++;            }            else{                break;            }        }        if(opt==n3+1)d[i].w=1e9;        else d[i].w+=c[opt].w;        if(d[i].w&gt;=1e9)d[i].w=1e9;        }    ll ans=1e9;    for(int i=1;i&lt;=n4;i++){        ans=min(ans,d[i].w);    }    if(ans==1e9)cout&lt;&lt;-1&lt;&lt;endl;    else cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-DYqjVfDR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DYqjVfDR"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1485E-Move and Swap</title>
    <link href="/2021/02/14/CodeForces-1485E-Move%20and%20Swap/"/>
    <url>/2021/02/14/CodeForces-1485E-Move%20and%20Swap/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p><img src="https://img-blog.csdnimg.cn/20210214103417800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><p>n个节点的树，每个节点(2~n)有值a[i],一开始红色点和蓝色点都在头节点1，移动d步求最大的|a[i]-a[j]|之和。</p><p>每一步：<br>红色点只能移动到r的子节点<br>蓝色点可以移动到下一层的任意一点<br>每次可以选择交换红色点和蓝色点的位置(也可以不交换)</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一开始想着贪心：每次选择每层最大的和最小的，但是这样贪心显然不对，样例都过不了。</p><p>于是想树形DP：</p><p>假设红色点和蓝色点不可以交换，dp[i]表示红色点当前走到i点时最大的总和,fa[i]表示节点i的父亲节点。那么dp[i]=max(dp[i],dp[fa[i]]+|a[i]-a[j]|)(j就是蓝色点，即与i同层的节点)，这里可以依靠预处理出同一层最大的a[i]的值和最小的a[i]的值。如果红色点和蓝色点可以交换，那么dp[i]=max(dp[i],dp[fa[j]]+abs(a[i]-a[j]))，即dp[i]=max(dp[i],dp[fa[j]]+a[j]-a[i],dp[fa[j]]-a[j]+a[i])，这里可以预处理出dp[fa[j]]+a[j]和dp[fa[j]]-a[j].</p><p>首先用dfs求出深度，将同一深度的放到一个集合，然后通过对每一个深度进行预处理求处最小的a[i]和最大的a[i]以及最大的dp[fa[i]]+a[i]和dp[fa[i]]-a[i].</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=4e5+50;typedef long long ll;int T,n,k=1,head[maxn];ll a[maxn],dp[maxn];struct Edge{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;} int deep[maxn],fa[maxn],Maxx_deep;vector&lt;int&gt;s[maxn];void dfs(int u,int f){    deep[u]=deep[f]+1;fa[u]=f;s[deep[u]].push_back(u);    Maxx_deep=max(Maxx_deep,deep[u]);    for(int i=head[u];i;i=edge[i].next){        if(edge[i].to==f)continue;        dfs(edge[i].to,u);    }}int main(){    cin&gt;&gt;T;    while(T--){        k=1;Maxx_deep=0;        cin&gt;&gt;n;        memset(head,0,sizeof(int)*(2*n+10));        memset(dp,0,sizeof(ll)*(n+5));        for(int i=2;i&lt;=n;i++){            int f;cin&gt;&gt;f;            add(f,i);add(i,f);        }        for(int i=2;i&lt;=n;i++)cin&gt;&gt;a[i];        dfs(1,1);        ll ans=-1e18;        for(int i=2;i&lt;=Maxx_deep;i++){            ll minn=1e18,maxx=-1e18,maxxe1=-1e18,maxxe2=-1e18;            for(int j=0;j&lt;s[i].size();j++){                minn=min(minn,a[s[i][j]]);                maxx=max(maxx,a[s[i][j]]);                maxxe1=max(maxxe1,dp[fa[s[i][j]]]+a[s[i][j]]);                maxxe2=max(maxxe2,dp[fa[s[i][j]]]-a[s[i][j]]);            }            for(int j=0;j&lt;s[i].size();j++){                dp[s[i][j]]=max(dp[s[i][j]],dp[fa[s[i][j]]]+max(abs(a[s[i][j]]-minn),abs(a[s[i][j]]-maxx)));                dp[s[i][j]]=max(dp[s[i][j]],maxxe1-a[s[i][j]]);                dp[s[i][j]]=max(dp[s[i][j]],maxxe2+a[s[i][j]]);                ans=max(ans,dp[s[i][j]]);            }        }        cout&lt;&lt;ans&lt;&lt;endl;        for(int i=1;i&lt;=Maxx_deep;i++)s[i].clear();    }    return 0;}</code></pre>        <div id="aplayer-LcuSuljn" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LcuSuljn"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1485</title>
    <link href="/2021/02/13/CodeForces-1485/"/>
    <url>/2021/02/13/CodeForces-1485/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-Floor-and-Mod"><a href="#C-Floor-and-Mod" class="headerlink" title="C. Floor and Mod"></a>C. Floor and Mod</h1><p><img src="https://img-blog.csdnimg.cn/20210213214904895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>1&lt;=a&lt;=x,    1&lt;=b&lt;=y,给定x和y，找出有多少组(x,y)满足  ⌊a/b⌋=a%b</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于 ⌊a/b⌋=a%b，则可设a=k <em> b+k（1&lt;=k&lt;=b-1）,而1&lt;=k </em> b+k&lt;=x(1&lt;=k&lt;=b-1),所以可以推出k * k&lt;=x(1&lt;=k&lt;=b-1),得到k&lt;=sqrt(x).这样可以通过枚举k的值，确定b的数量来得到最终的答案。</p><p>由1&lt;=k * b+k&lt;=x可以得到b&lt;=x/k-1.结合1&lt;=k&lt;=b-1和1&lt;=b&lt;=y，可以推导出k&lt;b&lt;=min(x/k-1,y),所以对于任意的k它对应的b的数量就是max(0,min(x/k-1,y)-k).全部加起来就是答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,x,y;int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;x&gt;&gt;y;        ll ans=0;        for(ll i=1;i&lt;sqrt(x);i++){            ans+=max(0ll,min(x/i-1,y)-i);        }         cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-Multiples-and-Power-Differences"><a href="#D-Multiples-and-Power-Differences" class="headerlink" title="D. Multiples and Power Differences"></a>D. Multiples and Power Differences</h1><p><img src="https://img-blog.csdnimg.cn/20210213220037351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定n行m列的矩阵a，需要构造同样规模的矩阵b，所得bij是aij的倍数，且相邻bij的相差的值=k^4(k&gt;=1)，并且bij&lt;=1000000</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>观察到aij&lt;=16，就从这里下手，假如b[i][j]=16！那么b[i][j]一定是a[i][j]倍数，但是16！&gt;1000000，但是{1，2，3，…，16}的公倍数d=3 <em> 7 </em> 11 <em> 13 </em> 15 * 16，因此可以让b[i][j]=16！，但是这样不满足相邻的b[i][j]的差值=k^4,我们可以让部分b[i][j]加上a[i][j]^4,这样既保证了b[i][j]是a[i][j]的倍数，又满足了差值的要求。令b[i][j]=d,然后相邻的就需要加上自身a[i][j]^4.这样就可以求出b[i][j]</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500+50;typedef long long ll;ll n,m,a[maxn][maxn],b[maxn][maxn];int vis[maxn][maxn];int main(){    ll ans=3*7*11*13*15*16;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)            cin&gt;&gt;a[i][j];    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            if(!vis[i][j]){                b[i][j]=ans;                vis[i+1][j]=vis[i][j+1]=1;            }            else{                b[i][j]=ans+a[i][j]*a[i][j]*a[i][j]*a[i][j];            }        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            cout&lt;&lt;b[i][j]&lt;&lt;&#39; &#39;;        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-ToCFWqKG" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ToCFWqKG"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020（ICPC）亚洲区域赛（南京）赛后总结</title>
    <link href="/2020/12/21/2020%EF%BC%88ICPC%EF%BC%89%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B%EF%BC%88%E5%8D%97%E4%BA%AC%EF%BC%89%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/21/2020%EF%BC%88ICPC%EF%BC%89%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B%EF%BC%88%E5%8D%97%E4%BA%AC%EF%BC%89%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    2020年的ICPC基本结束（还剩下济南站），我们队也打完了2020年的最后一场正式比赛。从最开始的<strong>轮流做队（LLZ）</strong>（其实就是我们三个人的第一个字母组合起来的）到后面的<strong>69岁，是acmer队（Mabaoguo）</strong>（队友觉得之前的队名不吉利，每次都轮流改题，场面一度混论，真是队如其名，于是就改名了），从暑假的集训到省赛再到天梯赛最后到ICPC的南京站，我们队2020年的比赛也就全部结束了。</p><p>​    比赛开始前5min，三个人都不知道该选哪个题下手，随便挑了A、B、G题，看了1min。“这都是些什么题啊？”然后就等着看榜做题，顺带再看了一下A题。大概8min后，看到K题有人AC了，然后三人同时看K题（不再轮流做了QAQ），发现是一个构造题：<strong>构造出有且仅有k个gcd（ai，i）=1</strong>的全排列。当时第一反应就是k个之后的数就ai=i，k个前面的数循环后移一位。顺利签到一题。</p><p>​    接着<strong>看榜做题</strong>，lcy翻译了L题的题意，当时感觉这题和这周CF的DIV3的最后一题特别相似，都是问一个区间内点的最大重复个数，lzy思路可能和我的有点类似，但我的略麻烦，需要用树状数组来维护。lzy WA了一次之后，修改了b[]的上下界后AC了L题。这时我们的排名还看得过去。（和我们预想的一样，我们队可能做简单题会很快，但是半银难度的题目就不行了）。</p><p>​    此时比赛过去了1h，lcy先给我解释了F题（这也是本次比赛最让我们崩溃的题目），然后给我看了他的推导公式，接下来的半个小时我们三人都成功地被这个期望公式给误导了。想了很久，发现了里面的一个漏洞“我们似乎总是认为 Kotori 能够知道最后一个是perfect烟花！”至此，公式错误。转战E题。</p><p>​    E题也是构造题，（实际上A题和K<strong>签到</strong>题也是构造题，南京站简直就是<strong>构造专场</strong>），有且只有1个雷在任意一个位置（x，y），当时想的解法就是：全排列LRUD四个方向（最多就24种组合，这似乎就是题解做法）然后把所有给定LRUD串按照组合方式排列起来，一旦按照这种走法不踩到雷就输出答案并且中断程序，如果所有组合都没有正确答案那就说明不存在解。当时构造出这种解法的时候，我感觉很对，于是提交了一发：<strong>WA！</strong>直接就很懵逼，重新检查了一遍代码，发现自己string串从0开始存的，结果遍历却从1开始遍历的，重新提交：<strong>AC！</strong>（直接贡献了20min罚时，非常崩溃）</p><p>​    最后还是来到了F题，lzy开始做M题（树形DP背包），lcy重新给出了新的公式：假设做k次烟花后点然一次，那么前k次可能出现perfect烟花：概率为(1-(1-p)^k)，也可能不出现perfect烟花：概率为(1-p)^k，就分成两部分。最后得出一个差比数列，最后求出公式，其中的N是无穷大，可以把它的式子合并掉，结果正确的式子竟然和我之前盲猜的一个可以过样例的数据是一样的！答案就是：min{(kn+m)/(1-(1-p)^k)}，那么就要三分k来求得最小的答案。这时候才发现我们三人都忘了三分怎么打的了（忘记边界如何处理的），我试着回忆了一下高中用三分做的HDU的一个题，然后跑了一下样例，以为过样例了就交了（其实样例的最后一个点我没过，我和lcy都没有看到），然后：<strong>WA！</strong>lcy试着改了一下才发现我们连样例都没有过，当时心态就很爆炸，我又贡献了20min的罚时。</p><p>​    就这样时间过去了4个小时，比赛进入封榜状态，此时rank199，几乎没戏了。当时内心可谓煎熬极了，想着前2个小时都挺不错的，结果被一个三分搞得心态爆炸。从焦虑、急躁逐渐释然，也许本身自己实力就不怎么样，也许比赛就这样打铁了。我也被逼的没办法了，想了一个偏方”我们三分模板虽然不对，但是总体上是正确的，那么我们可以再枚举一下最后的 [l,r]这个区间的答案，这个复杂度并不高，就常数级别。“然后lcy觉得可能也就只能这样了，就在志愿者举着手机监控下去上厕所了（差评！网络赛就是特别复杂，而且上厕所还要监控着去，上次天梯赛竟然就站在我后面录像，还说什么”我们一定保护你的隐私！“，woc，我上个厕所，还有监考人员围观，我真是服了！），然后蹭lcy上厕所，lzy在想M题，我告诉lzy”要不再交一发吧，我实在没有办法了！“ “交吧！<strong>”激动的心，颤抖的手</strong>，提交之后1s、2s、3s（居然3s了都没WA？），4s“恭喜通过此题，Accepted！” “woc！过了！！！这都能AC？”</p><p>​    最后半个小时两人Debug M题，我想H计数题，可能我们队本身就不会计数题吧，几乎从没有AC过计数类型的题目，M题一开始lzy 想的是贪心，正着贪不对，反着贪也不对，于是正反各贪一次，终于过了样例，在我们三人的注视下提交了上去，1s之后<strong>WA</strong>。我们怎么也没有想到这是一个DP背包。</p><p>​    比赛结束。没有什么奇迹，也没有什么意外，带了一堆模板，唯独没有三分的格式模板，感觉自己很菜，世人皆会的三分，我却不会，差点坑死队友。</p><p>​    2020年的ICPC就这么结束了，没有取得什么值得炫耀的成绩，但终归没有浪费掉2020下半年的时间。我们队也只是很普通的一个ACM队，没有多么拔尖的个人实力，也没有多么完美的团队配合，但是我们也在2020下半年打了大大小小的比赛，虽然没有什么奇迹发生，但是也算对得起我们平时的努力。比赛没有想象中的那么美好，但也没有想象中的那么糟糕。没能拿到金牌、银牌，但短暂地经历了区域赛，感受到了比赛的紧张氛围，也感受到了劫后余生的幸运。2020再见，也愿2021自己不再像2020这般菜！</p>        <div id="aplayer-xVIcjEjZ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-xVIcjEjZ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>总结与游记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1461B-Find the Spruce</title>
    <link href="/2020/12/12/CodeForces-1461B-Find%20the%20Spruce/"/>
    <url>/2020/12/12/CodeForces-1461B-Find%20the%20Spruce/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p> <img src="https://img-blog.csdnimg.cn/20201212171832411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>求出所有符合要求的图形。一开始想着枚举所有的点(i,j)，以点(i,j)为起点，向下不断寻找符合条件的图形，但是觉得太麻烦了。然后发现每一个点是否可以继续向下寻找符合条件的图形完全取决于点(i+1,j-1)、(i+1,j)、(i+1,j+1)这三个点是否都是<strong>*</strong>,并且点(i,j)可以向下找到几个符合条件的图形，也是取决于这三个点中最小的符合条件的图形的数量。这样完全可以从最后一行向上进行动态转移。一开始初始化所有为*的点(i,j),令它们dp[i][j]=1，然后从最后一行向上更新 dp[i][j]+=min(dp[i+1][j-1],min(dp[i+1][j],dp[i+1][j+1])); 最后答案就是所有dp[i][j]之和。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500+50;typedef long long ll;ll T,n,m,dp[maxn][maxn];char s[maxn][maxn];int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i]+1;        for(int i=1;i&lt;=n;i++){            for(int j=1;j&lt;=m;j++){                if(s[i][j]==&#39;*&#39;){                    dp[i][j]=1;                }                else{                    dp[i][j]=0;                }            }        }        ll tot=0;        for(int i=n-1;i&gt;=1;i--){            for(int j=1;j&lt;=m;j++){                if(j-1&gt;=1&amp;&amp;j+1&lt;=m&amp;&amp;dp[i][j]==1&amp;&amp;dp[i+1][j-1]&amp;&amp;dp[i+1][j]&amp;&amp;dp[i+1][j+1]){                    dp[i][j]+=min(dp[i+1][j-1],min(dp[i+1][j],dp[i+1][j+1]));                }            }        }        for(int i=1;i&lt;=n;i++){            for(int j=1;j&lt;=m;j++){                tot+=dp[i][j];            }        }        cout&lt;&lt;tot&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-oNRmZlJk" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-oNRmZlJk"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1461C-Random Events</title>
    <link href="/2020/12/12/CodeForces-1461C-Random%20Events/"/>
    <url>/2020/12/12/CodeForces-1461C-Random%20Events/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：<img src="https://img-blog.csdnimg.cn/20201212203328807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"></h1><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>对于后缀序ai,ai+1,…,an如果该序列已经全部满足ai=i，那么对于任意的r∈[i,n]，他们是否排序都不会影响最终答案。但是如果不是这种序列就必须保证最后一个ai!=i必须有r=i，并且进行概率为p的操作。而后面的操作是否进行实际上都不影响答案，如果不进行刚才的操作，就必须保证r&gt;i的操作至少进行一次。因此答案需要累加r&gt;i的每钟操作一次。特判一下整个序列都已经从小到大排好的情况，此时答案为1.</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+50;int T,n,m,a[maxn];struct Node{    int f;double q;}t[maxn];int cmp(Node x,Node y){    return x.f&lt;y.f;}int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        for(int i=1;i&lt;=m;i++)cin&gt;&gt;t[i].f&gt;&gt;t[i].q;        sort(t+1,t+1+m,cmp);        int s=0;        for(int i=n;i&gt;=1;i--){            if(a[i]!=i){                s=i;                break;            }         }        double ans=0,sum=1.0;        for(int i=m;i&gt;=1;i--){            if(t[i].f&gt;=s){                ans=ans+sum*t[i].q;                sum*=(1-t[i].q);            }            else{                break;            }        }        if(s==0)ans=1.0;        printf(&quot;%.7lf\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-oLjagOun" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-oLjagOun"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1461D-Divide and Summarize</title>
    <link href="/2020/12/12/CodeForces-1461D-Divide%20and%20Summarize/"/>
    <url>/2020/12/12/CodeForces-1461D-Divide%20and%20Summarize/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p> <img src="https://img-blog.csdnimg.cn/2020121220503433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>直接模拟这个二分的过程，然后标记查询区间元素总和，用map标记。dfs进行二分模拟的上界是a[]的最大值，下界是a[]的最小值。用树状数组储存答案，查询区间内元素总和。对于dfs模拟中要判断mid是否存在于a[]中，如果不存在就需要再二分找到最接近mid的。（a[]从小到大排序）把所有可以得到的答案都用map标记后，再进行后面的查询，直接输出答案。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+50;typedef long long ll;ll T,n,m,a[maxn],sum[maxn],minn,maxx;map&lt;ll,int&gt;mp;ll lowbit(ll x){    return x&amp;(-x);}ll query(ll x){    ll res=0;    while(x){        res+=sum[x];        x-=lowbit(x);    }    return res;}void add(ll x,ll w){    while(x&lt;=maxx){        sum[x]+=w;        x+=lowbit(x);    }}void dfs(ll l,ll r){    mp[query(r)-query(l-1)]=1;    if(l&gt;=r)return ;    ll mid=(l+r)/2;    ll t1=lower_bound(a+1,a+1+n,mid)-a;    ll t2=lower_bound(a+1,a+1+n,mid+1)-a;    ll midl,midr;    if(a[t1]==mid)midl=mid;    else midl=a[t1-1];    midr=a[t2];    dfs(l,midl);dfs(midr,r);}int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n&gt;&gt;m;        maxx=0;minn=1e18;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],maxx=max(maxx,a[i]),minn=min(minn,a[i]);        sort(a+1,a+1+n);        for(int i=0;i&lt;=maxx;i++)sum[i]=0;        for(int i=1;i&lt;=n;i++){            add(a[i],a[i]);        }        mp.clear();        dfs(minn,maxx);        while(m--){            ll x;cin&gt;&gt;x;            if(mp[x])cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre>        <div id="aplayer-XEYborJP" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-XEYborJP"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>二分</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1461E-Water Level</title>
    <link href="/2020/12/12/CodeForces-1461E-Water%20Level/"/>
    <url>/2020/12/12/CodeForces-1461E-Water%20Level/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p> <img src="https://img-blog.csdnimg.cn/20201212170552244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"> </p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>每一天的开始，可以加y升的水，每一天一定会用x升的水，需要保证每时每刻水量都在[l,r]。</p><p>如果x=y：那么只要k-x&gt;=l||k+x&lt;=r，可以让水量一直维持在k(k∈[l,r])。</p><p>如果x<y：那么k一定会不断减小。对于第一天，需要考虑是否可以加y升水。而之后第i天一定会减少x升水，第i+1天一定可以加入y升水，相当于一天减少delt=x-y升水。然后计算出维持的天数tot，如果tot>=t就输出Yes</p><p>如果x&gt;y：那么就可以模拟这个过程，并且记录变量k是否到达过当前的值，一旦到达说明存在一个循环且该循环所有位置都处于[l,r]中，可以直接输出Yes。对于k，可以不断减少x，直到无法减少，此后一定可以再加y，再次减少x。每一次t-=(k-l)/x，k=k-(k-l)/x。一旦t&lt;=0就输出Yes。用mp[]来记录k的轨迹，一旦出现mp[k]=1就到达了上述的循环。k减到无法再减x时候，k就应该加y，注意此时当天k一定要减少x。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll k,l,r,t,x,y;map&lt;ll,int&gt;mp;int main(){    cin&gt;&gt;k&gt;&gt;l&gt;&gt;r&gt;&gt;t&gt;&gt;x&gt;&gt;y;    if(x==y){        if(k+y&lt;=r||k-y&gt;=l)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        return 0;    }    else if(x&gt;y){        ll delt=x-y,tot=0;        if(k+y&lt;=r)k+=y;        if(k-x&gt;=l){            k-=x,tot++;            tot=tot+(k-l)/delt;        }        if(tot&gt;=t)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        return 0;    }    else{        ll sign=0;        while(1){            t-=(k-l)/x;            k=k-(k-l)/x*x;            if(t&lt;=0){                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;                return 0;            }            if(mp[k]){                sign=1;                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;                return 0;            }            mp[k]=1;            if(k+y&lt;=r)k+=y;            k-=x;t--;            if(k&lt;l||k&gt;r)break;        }        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-LQsKJUyX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LQsKJUyX"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序星编程之路</title>
    <link href="/2020/11/21/%E7%A8%8B%E5%BA%8F%E6%98%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/"/>
    <url>/2020/11/21/%E7%A8%8B%E5%BA%8F%E6%98%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-Love-“A”"><a href="#A-Love-“A”" class="headerlink" title="A.Love “A”"></a>A.Love “A”</h1><p><img src="https://img-blog.csdnimg.cn/20201121113843192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>题意很明确：希望字符串有一半是’a’，显然我们没有必要删除’a’,只需要删除非’a’的字母，因此统计’a’的数量即可，同时也统计一下不是’a’的字母的数量，把多余的不是’a’的字母去掉即可。答案显然就是a的数量<strong>min(n,cnta+cnta-1)</strong></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n;char s[maxn];int main(){    cin&gt;&gt;s;    n=strlen(s);    int cnta=0;    for(int i=0;i&lt;n;i++)        if(s[i]==&#39;a&#39;)            cnta++;    cout&lt;&lt;min(n,cnta+cnta-1)&lt;&lt;endl;    return 0;}</code></pre><h1 id="B-谁拿了最多奖学金"><a href="#B-谁拿了最多奖学金" class="headerlink" title="B.谁拿了最多奖学金"></a>B.谁拿了最多奖学金</h1><p>  <img src="https://img-blog.csdnimg.cn/20201121115249515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img">  </p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>这里使用结构体，里面存学生姓名name，期末分数final， 班级评议成绩other，判断是否是学生干部f1(f1=1表示是，否则f1=0)，判断是否是西部省份学生(f2=1表示是，否则f2=0)，，发表的论文数量sci，获得的奖学金money.然后就是5个奖项的判断条件：</p><ol><li>院士奖学金:final&gt;80&amp;&amp;sci&gt;=1，得到8000元</li><li>五四奖学金:t[i].final&gt;85&amp;&amp;t[i].other&gt;80,得到4000元</li><li>成绩优秀奖:t[i].final&gt;90,得到2000元</li><li>西部贡献奖:t[i].final&gt;85&amp;&amp;t[i].f2,得到1000元</li><li>班级贡献奖:t[i].other&gt;80&amp;&amp;t[i].f1,得到850元。</li></ol><p>ans记录所有人的总奖学金，maxx记录最高的奖学金。然后从头开始再枚举一下看谁是第一个得到最高奖学金的输出他的姓名。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+50;struct Node{    char name[25];int final,other,f1,f2,sci,money;}t[maxn];int n;int main(){    scanf(&quot;%d&quot;,&amp;n);    int maxx=0,ans=0;    for(int i=1;i&lt;=n;i++){        char x,y;        scanf(&quot;%s%d%d %c %c%d&quot;,&amp;t[i].name,&amp;t[i].final,&amp;t[i].other,&amp;x,&amp;y,&amp;t[i].sci);//注意scanf和cin的区别，如果scanf读入不好，不妨设一下cin          if(x==&#39;Y&#39;)t[i].f1=1;        else t[i].f1=0;        if(y==&#39;Y&#39;)t[i].f2=1;        else t[i].f2=0;        if(t[i].final&gt;80&amp;&amp;t[i].sci&gt;=1)t[i].money+=8000;        if(t[i].final&gt;85&amp;&amp;t[i].other&gt;80)t[i].money+=4000;        if(t[i].final&gt;90)t[i].money+=2000;        if(t[i].final&gt;85&amp;&amp;t[i].f2)t[i].money+=1000;        if(t[i].other&gt;80&amp;&amp;t[i].f1)t[i].money+=850;        maxx=max(maxx,t[i].money);        ans+=t[i].money;    }    for(int i=1;i&lt;=n;i++){        if(t[i].money==maxx){            printf(&quot;%s\n&quot;,t[i].name);            break;        }    }    printf(&quot;%d\n%d\n&quot;,maxx,ans);     return 0 ;}</code></pre><h1 id="C-玩具谜题"><a href="#C-玩具谜题" class="headerlink" title="C.玩具谜题"></a>C.玩具谜题</h1><p><img src="https://img-blog.csdnimg.cn/2020112111591167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>结构体记录人的状态（sta=0表示向内，sta=1表示向外）以及姓名。有n个人，从0~n-1记录所有人的状态和姓名。有m次操作，每次操作有a和s，a表示顺逆，s表示距离步数。当人朝内，a=0，表示顺时针，对应的人的编号-s，a=1，表示逆时针，对应的人编号+s，注意当编号<0，则编号要加+n（因为这是一个环，和取模类似）；当编号>=n，则编号要-n。当人朝外，a=0，表示逆时针，对应的人的编号+=s，a=1，表示顺时针，对应的人的编号-=s。朝外的操作和朝内刚好相反（可画图辅助思考）</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+50;struct Node{    char name[30];int sta;}t[maxn];int n,m;int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;=n-1;i++){        scanf(&quot;%d%s&quot;,&amp;t[i].sta,t[i].name);    }    int now=0;    while(m--){        int s,a;        cin&gt;&gt;a&gt;&gt;s;        if(t[now].sta==0){            //朝内            if(a==0)now-=s;            else now+=s;            if(now&lt;0)now+=n;            if(now&gt;=n)now-=n;        }        else{            if(a==0)now+=s;            else now-=s;            if(now&lt;0)now+=n;            if(now&gt;=n)now-=n;        }    }    printf(&quot;%s&quot;,t[now].name);    return 0;}</code></pre>        <div id="aplayer-qlAauqlV" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-qlAauqlV"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>水题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1579-三阶幻方</title>
    <link href="/2020/11/18/NOJ-1579-%E4%B8%89%E9%98%B6%E5%B9%BB%E6%96%B9/"/>
    <url>/2020/11/18/NOJ-1579-%E4%B8%89%E9%98%B6%E5%B9%BB%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三阶幻方"><a href="#三阶幻方" class="headerlink" title="三阶幻方"></a>三阶幻方</h1><p><img src="https://img-blog.csdnimg.cn/2020111822501232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int vis[15],a[5][5];void dfs(int x,int y){    int i;    if(x==4&amp;&amp;y==1){        for(i=1;i&lt;=3;i++){            if(a[i][3]+a[i][2]+a[i][1]!=15)return ;            if(a[1][i]+a[2][i]+a[3][i]!=15)return ;        }        if(a[1][1]+a[2][2]+a[3][3]!=15||a[1][3]+a[2][2]+a[3][1]!=15)return ;        for(i=1;i&lt;=3;i++){            cout&lt;&lt;a[i][1]&lt;&lt;&#39; &#39;&lt;&lt;a[i][2]&lt;&lt;&#39; &#39;&lt;&lt;a[i][3]&lt;&lt;endl;        }        cout&lt;&lt;endl;        return;    }    for(i=1;i&lt;=9;i++){        if(vis[i])continue;        vis[i]=1;        a[x][y]=i;        if(y==3)        dfs(x+1,1);        else         dfs(x,y+1);        vis[i]=0;    }}int main(){    dfs(1,1);    return 0;}</code></pre>        <div id="aplayer-DxjhgUrV" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DxjhgUrV"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1575-图的m着色问题</title>
    <link href="/2020/11/18/NOJ-1575-%E5%9B%BE%E7%9A%84m%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/18/NOJ-1575-%E5%9B%BE%E7%9A%84m%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="图的m着色问题"><a href="#图的m着色问题" class="headerlink" title="图的m着色问题"></a>图的m着色问题</h1><p><img src="https://img-blog.csdnimg.cn/20201118224855520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200+5;int n,m,r,a[maxn][maxn],ans,vis[maxn];void dfs(int cnt){    int i,j;    if(cnt==n){        ans++;        return ;    }    for(i=1;i&lt;=r;i++){        for(j=0;j&lt;cnt;j++){            if(a[cnt][j]&amp;&amp;vis[j]!=i){                vis[cnt]=i;                dfs(cnt+1);                vis[cnt]=0;            }        }    }}int main(){    int i;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r;    for(i=1;i&lt;=m;i++){        int x,y;        cin&gt;&gt;x&gt;&gt;y;        a[x][y]=a[y][x]=1;    }    for(i=1;i&lt;=r;i++){        vis[0]=i;        dfs(1);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-MyKqcDtp" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-MyKqcDtp"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1145-求图像的周长</title>
    <link href="/2020/11/18/NOJ-1145-%E6%B1%82%E5%9B%BE%E5%83%8F%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <url>/2020/11/18/NOJ-1145-%E6%B1%82%E5%9B%BE%E5%83%8F%E7%9A%84%E5%91%A8%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="求图像的周长"><a href="#求图像的周长" class="headerlink" title="求图像的周长"></a>求图像的周长</h1><p><img src="https://img-blog.csdnimg.cn/2020111822474183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+50;int n,m,x,y,ans,vis[maxn][maxn],d[8][2]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};char s[maxn][maxn];void dfs(int x,int y){    int i;    if(vis[x][y])return ;    vis[x][y]=1;    for(i=0;i&lt;8;i++){        int nx=x+d[i][0],ny=y+d[i][1];        if(i&lt;=3&amp;&amp;s[nx][ny]!=&#39;X&#39;)ans++;        if(nx&gt;=1&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=m&amp;&amp;s[nx][ny]==&#39;X&#39;)dfs(nx,ny);    }}int main(){    int i;    while(1){        cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;        ans=0;        memset(vis,0,sizeof(vis));        if(n==0&amp;&amp;m==0&amp;&amp;x==0&amp;&amp;y==0)break;        for(i=1;i&lt;=n;i++)cin&gt;&gt;s[i]+1;        dfs(x,y);        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-aflOKNZO" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-aflOKNZO"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1144-农场灌溉问题</title>
    <link href="/2020/11/18/NOJ-1144-%E5%86%9C%E5%9C%BA%E7%81%8C%E6%BA%89%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/18/NOJ-1144-%E5%86%9C%E5%9C%BA%E7%81%8C%E6%BA%89%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="农场灌溉问题"><a href="#农场灌溉问题" class="headerlink" title="农场灌溉问题"></a>农场灌溉问题</h1><p><img src="https://img-blog.csdnimg.cn/20201118224613235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;struct Node{    int l,r,u,d;}t[maxn],a[maxn][maxn];int n,m,vis[maxn][maxn]; void dfs(int x,int y){    if(vis[x][y])return ;    vis[x][y]=1;    if(a[x][y].l&amp;&amp;y-1&gt;=1&amp;&amp;a[x][y-1].r)dfs(x,y-1);    if(a[x][y].r&amp;&amp;y+1&lt;=m&amp;&amp;a[x][y+1].l)dfs(x,y+1);    if(a[x][y].d&amp;&amp;x+1&lt;=n&amp;&amp;a[x+1][y].u)dfs(x+1,y);    if(a[x][y].u&amp;&amp;x-1&gt;=1&amp;&amp;a[x-1][y].d)dfs(x-1,y);}int main(){    int i,j;    t[1].l=t[1].u=1;    t[2].r=t[2].u=1;    t[3].l=t[3].d=1;    t[4].r=t[4].d=1;    t[5].u=t[5].d=1;    t[6].l=t[6].r=1;    t[7].u=t[7].l=t[7].r=1;    t[8].l=t[8].u=t[8].d=1;    t[9].l=t[9].r=t[9].d=1;    t[10].u=t[10].d=t[10].r=1;    t[11].l=t[11].r=t[11].u=t[11].d=1;    while(1){        memset(vis,0,sizeof(vis));        cin&gt;&gt;n&gt;&gt;m;        if(n==-1&amp;&amp;m==-1)break;        for(i=1;i&lt;=n;i++){            for(j=1;j&lt;=m;j++){                char x;cin&gt;&gt;x;                a[i][j]=t[x-&#39;A&#39;+1];            }        }        int ans=0;        for(i=1;i&lt;=n;i++){            for(j=1;j&lt;=m;j++){                if(vis[i][j])continue;                ans++;                dfs(i,j);            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-XVNBDnPD" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-XVNBDnPD"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1143-字母转换</title>
    <link href="/2020/11/18/NOJ-1143-%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/11/18/NOJ-1143-%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字母转换"><a href="#字母转换" class="headerlink" title="字母转换"></a>字母转换</h1><p><img src="https://img-blog.csdnimg.cn/20201118224440693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+5;char s[maxn],t[maxn],p[maxn],s1[maxn],t1[maxn],st[maxn];int lens,lent,opti,opto;void dfs(int now){    int i;    if(opti+opto==lens*2){        for(i=1;i&lt;=lent;i++)t1[i]=s[i];        int opt1=0,opt2=1,opt3=0;        for(i=1;i&lt;=lens*2;i++){            if(p[i]==&#39;i&#39;)s1[++opt1]=t1[opt2++];            else st[++opt3]=s1[opt1--];        }        int sign=0;        for(i=1;i&lt;=lens;i++)            if(st[i]!=t[i]){                sign=1;break;            }        if(!sign){            for(i=1;i&lt;=lens*2-1;i++)cout&lt;&lt;p[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;p[i]&lt;&lt;endl;        }        return ;    }    if(opti&lt;lens){        opti++;p[now+1]=&#39;i&#39;;        dfs(now+1);        opti--;    }    if(opto&lt;opti){        opto++;p[now+1]=&#39;o&#39;;        dfs(now+1);        opto--;    }}int main(){    while(cin&gt;&gt;s+1&gt;&gt;t+1){        lens=strlen(s+1);lent=strlen(t+1);        cout&lt;&lt;&#39;[&#39;&lt;&lt;endl;;        opti=opto=0;        p[1]=&#39;i&#39;;opti++;        dfs(1);        cout&lt;&lt;&#39;]&#39;&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-GUDvTfiN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-GUDvTfiN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1142-踩气球</title>
    <link href="/2020/11/18/NOJ-1142-%E8%B8%A9%E6%B0%94%E7%90%83/"/>
    <url>/2020/11/18/NOJ-1142-%E8%B8%A9%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="踩气球"><a href="#踩气球" class="headerlink" title="踩气球"></a>踩气球</h1><p><img src="https://img-blog.csdnimg.cn/20201118224300227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>感觉题意说明不够全，好像是POJ的原题。</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int  sign1,sign2,n,m,x1=1,x2=1;void dfs(int x){    if(x==101){        if(x1==n&amp;&amp;x2==m)sign1=sign2=1;        if(x1==n)sign1=1;        return ;    }    dfs(x+1);    if(n%x==0&amp;&amp;x1*x&lt;=n){        x1*=x;        dfs(x+1);        x1/=x;    }    if(m%x==0&amp;&amp;x2*x&lt;=m){        x2*=x;        dfs(x+1);        x2/=x;    }}int main(){    while(1){        cin&gt;&gt;n&gt;&gt;m;        sign1=sign2=0;x1=x2=1;        if(n==0&amp;&amp;m==0)break;        if(n&gt;m){            int t=n;n=m;m=t;        }        dfs(2);        if(sign1==sign2)cout&lt;&lt;m&lt;&lt;endl;        else cout&lt;&lt;n&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-ASOYUizh" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ASOYUizh"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1009-迷宫问题</title>
    <link href="/2020/11/18/NOJ-1009-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/18/NOJ-1009-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h1><p><img src="https://img-blog.csdnimg.cn/20201118224130867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img">  </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=20+5;int T,sx,sy,tx,ty,vis[maxn][maxn],d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};char s[maxn][maxn];struct Node{    int x,y;};int main(){    int i;    cin&gt;&gt;T;    while(T--){        memset(vis,0,sizeof(vis));        cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;tx&gt;&gt;ty;        for(i=0;i&lt;20;i++)cin&gt;&gt;s[i];        queue&lt;Node&gt;q;        Node now;now.x=sx;now.y=sy;        q.push(now);        while(!q.empty()){            now=q.front();q.pop();            if(vis[now.x][now.y])continue;            vis[now.x][now.y]=1;            for(i=0;i&lt;4;i++){                Node nex;nex.x=now.x+d[i][0];nex.y=now.y+d[i][1];                if(nex.x&gt;=0&amp;&amp;nex.x&lt;20&amp;&amp;nex.y&gt;=0&amp;&amp;nex.y&lt;20&amp;&amp;!vis[nex.x][nex.y]&amp;&amp;s[nex.x][nex.y]==&#39;.&#39;)q.push(nex);                 }        }        if(vis[tx][ty])cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-ufNZkvdz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ufNZkvdz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1008-素数环问题</title>
    <link href="/2020/11/18/NOJ-1008-%E7%B4%A0%E6%95%B0%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/18/NOJ-1008-%E7%B4%A0%E6%95%B0%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="素数环问题"><a href="#素数环问题" class="headerlink" title="素数环问题"></a>素数环问题</h1><p><img src="https://img-blog.csdnimg.cn/20201118223538578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=105;int n=20,vis[maxn],a[maxn],cnt;void swap(int x,int y){    int t=a[x];    a[x]=a[y];    a[y]=t;}void dfs(int now){    int i;    if(now==n+1){        if(vis[a[1]+a[20]])return;        for(i=1;i&lt;=n-1;i++){            if(vis[a[i]+a[i+1]]){                return ;            }        }        cnt++;        if(cnt==2){            for(i=1;i&lt;=n-1;i++){                cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;            }            cout&lt;&lt;a[n]&lt;&lt;endl;                exit(0);        }        return ;    }    for(i=now;i&lt;=n;i++){        swap(i,now);        if(!vis[a[now]+a[now-1]])        dfs(now+1);        swap(i,now);    }}int main(){    int i,j;    for(i=1;i&lt;=n;i++)a[i]=i;    for(i=2;i&lt;=50;i++){        for(j=2;j&lt;=sqrt(i);j++){            if(i%j==0){                vis[i]=1;                break;            }        }    }    dfs(1);    return 0;}</code></pre>        <div id="aplayer-QKudYQga" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-QKudYQga"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1007-8皇后问题</title>
    <link href="/2020/11/18/NOJ-1007-8%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/18/NOJ-1007-8%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="8皇后问题"><a href="#8皇后问题" class="headerlink" title="8皇后问题"></a>8皇后问题</h1><p><img src="https://img-blog.csdnimg.cn/20201118223256841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=25;int vis[maxn][maxn],used[maxn][maxn],n,cnt=0;void dfs(int tot){    int i,j;    if(tot==n+1){        cnt++;printf(&quot;No %d:\n&quot;,cnt);        for(i=1;i&lt;=8;i++){            for(j=1;j&lt;=8;j++){                if(!used[i][j]){                    cout&lt;&lt;&#39;.&#39;;                }                else{                    cout&lt;&lt;&#39;A&#39;;                }            }            cout&lt;&lt;endl;        }        return ;    }    for(i=1;i&lt;=8;i++){        if(vis[0][i]||vis[1][tot+i-1]||vis[2][tot-i+n])continue;        used[tot][i]=1;vis[0][i]=vis[1][tot+i-1]=vis[2][tot-i+n]=1;        dfs(tot+1);        used[tot][i]=0;vis[0][i]=vis[1][tot+i-1]=vis[2][tot-i+n]=0;    }}int main(){    n=8;    dfs(1);    return 0;}</code></pre>        <div id="aplayer-bDbfyLXG" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-bDbfyLXG"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1006-堡垒问题</title>
    <link href="/2020/11/18/NOJ-1006-%E5%A0%A1%E5%9E%92%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/18/NOJ-1006-%E5%A0%A1%E5%9E%92%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="堡垒问题"><a href="#堡垒问题" class="headerlink" title="堡垒问题"></a>堡垒问题</h1><p><img src="https://img-blog.csdnimg.cn/20201118222928852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=20+5;int n,vis[maxn][maxn],ans;char a[maxn][maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}void dfs(int now,int cnt){    if(now==n*n){        ans=max(ans,cnt);        return ;    }    int r=now/n,c=now%n,i;    if(a[r][c]!=&#39;X&#39;&amp;&amp;vis[r][c]==0){        vis[r][c]=1;        for(i=r+1;i&lt;=n;i++){            if(a[i][c]!=&#39;X&#39;)vis[i][c]=1;            else break;        }        for(i=c+1;i&lt;=n;i++){            if(a[r][i]!=&#39;X&#39;)vis[r][i]=1;            else break;        }        dfs(now+1,cnt+1);        vis[r][c]=0;        for(i=r+1;i&lt;=n;i++){            if(a[i][c]!=&#39;X&#39;)vis[i][c]=0;            else break;        }        for(i=c+1;i&lt;=n;i++){            if(a[r][i]!=&#39;X&#39;)vis[r][i]=0;            else break;        }    }    dfs(now+1,cnt);}int main(){    int i,j;    while(1){        cin&gt;&gt;n;        if(n==0)break;        ans=0;        memset(vis,0,sizeof(vis));        for(i=0;i&lt;n;i++){            for(j=0;j&lt;n;j++){                cin&gt;&gt;a[i][j];            }        }        dfs(0,0);        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-LmmZCGNE" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LmmZCGNE"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1005-装载问题</title>
    <link href="/2020/11/18/NOJ-1005-%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/18/NOJ-1005-%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h1><p><img src="https://img-blog.csdnimg.cn/20201118222742789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=1000+50;int c1,c2,n,w[maxn],sign;void dfs(int now){    if(now==n+1){        sign=1;        return ;    }    if(c1&gt;=w[now]){        c1-=w[now];        dfs(now+1);        c1+=w[now];    }    if(c2&gt;=w[now]){        c2-=w[now];        dfs(now+1);        c2+=w[now];    }}int main(){    int i;    while(1){        cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;n;sign=0;        if(c1==0&amp;&amp;c2==0&amp;&amp;n==0)break;        for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i];        dfs(1);        if(sign)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-ORpowBlP" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ORpowBlP"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1004-01背包问题</title>
    <link href="/2020/11/18/NOJ-1004-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/18/NOJ-1004-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><p><img src="https://img-blog.csdnimg.cn/20201118222503261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=10000+50;int n,m,w[maxn],p[maxn],dp[maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}int main(){    int i,j;    while(1){        memset(dp,0,sizeof(dp));        cin&gt;&gt;n&gt;&gt;m;        if(n==0&amp;&amp;m==0)break;        for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i];        for(i=1;i&lt;=n;i++)cin&gt;&gt;p[i];        for(i=1;i&lt;=n;i++){            for(j=m;j&gt;=w[i];j--){                dp[j]=max(dp[j],dp[j-w[i]]+p[i]);            }        }        int ans=0;        for(i=1;i&lt;=m;i++)ans=max(ans,dp[i]);        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre>        <div id="aplayer-EidPCEHA" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EidPCEHA"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1324-穷举所有排列</title>
    <link href="/2020/11/18/NOJ-1324-%E7%A9%B7%E4%B8%BE%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97/"/>
    <url>/2020/11/18/NOJ-1324-%E7%A9%B7%E4%B8%BE%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="穷举所有排列"><a href="#穷举所有排列" class="headerlink" title="穷举所有排列"></a>穷举所有排列</h1><p><img src="https://img-blog.csdnimg.cn/20201118222334286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=25;int n;char a[maxn];void dfs(int t){    int i;    if(t==n+1){        for(i=1;i&lt;=n;i++)cout&lt;&lt;a[i];cout&lt;&lt;endl;        return ;    }    for(i=t;i&lt;=n;i++){        swap(a[i],a[t]);        dfs(t+1);        swap(a[i],a[t]);    }}int main(){    int i;    cin&gt;&gt;n;    for(i=1;i&lt;=n;i++)a[i]=&#39;a&#39;+i-1;    dfs(1);    return 0;}</code></pre>        <div id="aplayer-EMcdnpmX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EMcdnpmX"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1243-循环赛日程表</title>
    <link href="/2020/11/18/NOJ-1243-%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8/"/>
    <url>/2020/11/18/NOJ-1243-%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h1><p><img src="https://img-blog.csdnimg.cn/20201118222155565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=500+50;int n,a[maxn][maxn];void dfs(int r,int c,int h){    if(h==1)return ;    h/=2;    a[r+h][c+h]=a[r][c];    a[r][c+h]=a[r][c]+h;    a[r+h][c]=a[r][c]+h;    dfs(r,c,h);    dfs(r+h,c+h,h);    dfs(r,c+h,h);    dfs(r+h,c,h);}int main(){    int i,j;    cin&gt;&gt;n;    n=pow(2,n);    a[1][1]=1;    dfs(1,1,n);    for(i=1;i&lt;=n;i++){        for(j=1;j&lt;n;j++){            cout&lt;&lt;a[i][j]&lt;&lt;&#39; &#39;;        }        cout&lt;&lt;a[i][n]&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-wzMbMSpr" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-wzMbMSpr"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1574-求第k小数</title>
    <link href="/2020/11/18/NOJ-1574-%E6%B1%82%E7%AC%ACk%E5%B0%8F%E6%95%B0/"/>
    <url>/2020/11/18/NOJ-1574-%E6%B1%82%E7%AC%ACk%E5%B0%8F%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="求第k小数"><a href="#求第k小数" class="headerlink" title="求第k小数"></a>求第k小数</h1><p><img src="https://img-blog.csdnimg.cn/20201118222028150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+50;int n,a[maxn],k;int main(){    int i;    cin&gt;&gt;n;    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    cin&gt;&gt;k;    sort(a+1,a+1+n);    cout&lt;&lt;a[k]&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-LCcXOOEq" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LCcXOOEq"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1323-穷举n位二进制数</title>
    <link href="/2020/11/18/NOJ-1323-%E7%A9%B7%E4%B8%BEn%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2020/11/18/NOJ-1323-%E7%A9%B7%E4%B8%BEn%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="穷举n位二进制数"><a href="#穷举n位二进制数" class="headerlink" title="穷举n位二进制数"></a>穷举n位二进制数</h1><p> <img src="https://img-blog.csdnimg.cn/20201118221834375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=100+50;int a[maxn],n;int main(){    int i,x;    cin&gt;&gt;n;    for(i=n;i&gt;=1;i--)cout&lt;&lt;a[i];cout&lt;&lt;endl;    for(x=1;x&lt;=pow(2,n)-1;x++){        a[1]++;        for(i=1;i&lt;=n;i++){            if(a[i]&gt;=2)a[i]=0,a[i+1]++;        }        for(i=n;i&gt;=1;i--)cout&lt;&lt;a[i];cout&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-mRjtkegz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-mRjtkegz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1141-走迷宫</title>
    <link href="/2020/11/18/NOJ-1141-%E8%B5%B0%E8%BF%B7%E5%AE%AB/"/>
    <url>/2020/11/18/NOJ-1141-%E8%B5%B0%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h1><p> <img src="https://img-blog.csdnimg.cn/20201118221630766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=20+50;int n,m,sx,sy,tx,ty,a[maxn][maxn],vis[maxn][maxn],d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};struct Node{    int x,y;};int main(){    int i,j;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;sx&gt;&gt;sy&gt;&gt;tx&gt;&gt;ty;    for(i=0;i&lt;n;i++){        for(j=0;j&lt;m;j++){            cin&gt;&gt;a[i][j];        }    }    queue&lt;Node&gt;q;    Node now;now.x=sx;now.y=sy;    q.push(now);    while(!q.empty()){        now=q.front();q.pop();        if(vis[now.x][now.y])continue ;        vis[now.x][now.y]=1;        for(i=0;i&lt;4;i++){            Node nex;nex.x=now.x+d[i][0];nex.y=now.y+d[i][1];            if(nex.x&gt;=0&amp;&amp;nex.x&lt;=n-1&amp;&amp;nex.y&gt;=0&amp;&amp;nex.y&lt;=m-1&amp;&amp;!a[nex.x][nex.y])q.push(nex);        }    }    if(vis[tx][ty])cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-gOXuAUkL" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-gOXuAUkL"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1003-快速排序</title>
    <link href="/2020/11/18/NOJ-1003-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/11/18/NOJ-1003-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p> <img src="https://img-blog.csdnimg.cn/20201118220841435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+50;int n,a[maxn];void QuickSort(int l,int r){    if(l&gt;=r)return ;    int i=l,j=r,x=a[l];    while(i&lt;j){        while(x&lt;=a[j]&amp;&amp;i&lt;j)j--;        if(i&lt;j)a[i++]=a[j];        while(a[i]&lt;=x&amp;&amp;i&lt;j)i++;        if(i&lt;j)a[j--]=a[i];    }    a[i]=x;    QuickSort(l,i-1);QuickSort(i+1,r);}int main(){    int i;    cin&gt;&gt;n;    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    QuickSort(1,n);    for(i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-oOsskAQM" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-oOsskAQM"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1002-归并排序</title>
    <link href="/2020/11/18/NOJ-1002-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/11/18/NOJ-1002-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><img src="https://img-blog.csdnimg.cn/20201118220648400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+50;int n,a[maxn],t[maxn];void Sort(int l,int r,int mid){    int i=l,j=mid+1,k=0;    while(i&lt;=mid&amp;&amp;j&lt;=r){        if(a[i]&lt;=a[j])t[++k]=a[i++];        else t[++k]=a[j++];    }    if(i==mid+1){        while(j&lt;=r)t[++k]=a[j++];    }    if(j==r+1){        while(i&lt;=mid)t[++k]=a[i++];    }    for(i=l,k=1;i&lt;=r;i++,k++)a[i]=t[k];}void MergeSort(int l,int r){    int mid=(l+r)/2;    if(l&gt;=r)return ;    MergeSort(l,mid);MergeSort(mid+1,r);    Sort(l,r,mid);}int main(){    int i;    cin&gt;&gt;n;    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    MergeSort(1,n);    for(i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-kYWzIVIf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-kYWzIVIf"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1439A-Binary Table</title>
    <link href="/2020/11/18/CodeForces-1439A-Binary%20Table/"/>
    <url>/2020/11/18/CodeForces-1439A-Binary%20Table/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p> <img src="https://img-blog.csdnimg.cn/20201118105034340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><p>对于任意的2 * 2的正方形，可以选择其中的任意三个（0—&gt;1,1—&gt;0），使得进行若干次操作之后让所有的元素变成0.</p><p><strong>Easy版本</strong>：操作次数不超过3nm</p><p><strong>Hard版本</strong>：操作次数不超过nm</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>直接写nm的方法吧（比赛的时候觉得不可能麻烦到去讨论2 <em> 2的内部单独情况，于是就换思路了，结果今早还是换成了一开始的办法）。从上到下，从左到右（不包括最后两行，和最后一列），一旦当前的a[i][j]==1,那么就选择(i,j),(i,j+1),(i+1,j+1)进行变化。对于最后一列的选择(i,m),(i+1,m),(i+1,m-1)进行变化。对于最后两行的，从左到右，如果a[n-1]][j]==1就选择(n-1,j),(n-1,j+1),(n,j+1)；如果a[n][j]==1就选择(n,j),(n,j+1),(n-1,j+1),这样就只剩下右下角的 2 </em> 2的小方格了，比赛的时候就这里出问题了。今天早上想的方法是分别讨论1的个数为0，1，2，3，4的情况：</p><p>0：不需要变换，直接输出；</p><p>3：变换那3个1的位置，操作次数为1；</p><p>2：变换2个0的位置+任意一个1的位置，转换成了1的个数为3的情况，操作次数共为2；</p><p>1：变换1的位置+任意2个0的位置，转换成了1的个数为2个情况，操作次数为3；</p><p>4：变换任意3个1的位置，操作次数为4.</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+5;int a[maxn][maxn],T,n,m;char s[maxn][maxn];struct Node{    int x1,Y1,x2,Y2,x3,Y3;}ans[maxn*maxn];int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n&gt;&gt;m;int tot=0;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i]+1;        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=m;j++)a[i][j]=s[i][j]-&#39;0&#39;;        for(int i=1;i&lt;=n-2;i++){            for(int j=1;j&lt;=m-1;j++){                if(a[i][j]==0)continue;                tot++;                ans[tot].x1=i;ans[tot].Y1=j;ans[tot].x2=i;ans[tot].Y2=j+1;ans[tot].x3=i+1;ans[tot].Y3=j+1;                a[i][j]=0;a[i][j+1]=1-a[i][j+1];a[i+1][j+1]=1-a[i+1][j+1];            }            if(a[i][m]){                tot++;                ans[tot].x1=i;ans[tot].Y1=m;ans[tot].x2=i+1;ans[tot].Y2=m;ans[tot].x3=i+1;ans[tot].Y3=m-1;                a[i][m]=0;a[i+1][m]=1-a[i+1][m];a[i+1][m-1]=1-a[i+1][m-1];            }        }        for(int i=1;i&lt;=m-2;i++){            if(a[n-1][i]){                tot++;                ans[tot].x1=n-1;ans[tot].Y1=i;ans[tot].x2=n-1;ans[tot].Y2=i+1;ans[tot].x3=n;ans[tot].Y3=i+1;                a[n-1][i]=0;a[n-1][i+1]=1-a[n-1][i+1];a[n][i+1]=1-a[n][i+1];            }            if(a[n][i]){                tot++;                ans[tot].x1=n;ans[tot].Y1=i;ans[tot].x2=n;ans[tot].Y2=i+1;ans[tot].x3=n-1;ans[tot].Y3=i+1;                a[n][i]=0;a[n][i+1]=1-a[n][i+1];a[n-1][i+1]=1-a[n-1][i+1];            }        }        int cnt=a[n][m]+a[n-1][m-1]+a[n-1][m]+a[n][m-1];        int t[6][10]={0};        if(cnt==1){            tot++;int cnt=0,sign=0;            for(int i=n-1;i&lt;=n;i++){                for(int j=m-1;j&lt;=m;j++){                    if(a[i][j]){                        t[1][++cnt]=i;t[1][++cnt]=j;a[i][j]=0;                    }                    else{                        if(sign&gt;=2)continue;                        sign++;                        t[1][++cnt]=i;t[1][++cnt]=j;a[i][j]=1;                    }                    if(cnt==6)break;                }            }            sign=0;cnt=0;tot++;            for(int i=n-1;i&lt;=n;i++){                for(int j=m-1;j&lt;=m;j++){                    if(a[i][j]){                        if(!sign){                            sign=1;t[2][++cnt]=i;t[2][++cnt]=j;a[i][j]=0;                        }                        continue;                    }                    t[2][++cnt]=i;t[2][++cnt]=j;a[i][j]=1;                    if(cnt==6)break;                }            }            tot++;cnt=0;            for(int i=n-1;i&lt;=n;i++){                for(int j=m-1;j&lt;=m;j++){                    if(!a[i][j])continue;                    t[3][++cnt]=i;t[3][++cnt]=j;                }            }            cout&lt;&lt;tot&lt;&lt;endl;            for(int i=1;i&lt;=tot-3;i++)cout&lt;&lt;ans[i].x1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x3&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y3&lt;&lt;endl;            for(int i=1;i&lt;=3;i++)cout&lt;&lt;t[i][1]&lt;&lt;&#39; &#39;&lt;&lt;t[i][2]&lt;&lt;&#39; &#39;&lt;&lt;t[i][3]&lt;&lt;&#39; &#39;&lt;&lt;t[i][4]&lt;&lt;&#39; &#39;&lt;&lt;t[i][5]&lt;&lt;&#39; &#39;&lt;&lt;t[i][6]&lt;&lt;endl;         }        else if(cnt==2){            tot++;int sign=0,cnt=0;            for(int i=n-1;i&lt;=n;i++){                for(int j=m-1;j&lt;=m;j++){                    if(a[i][j]){                        if(!sign){                            sign=1;t[1][++cnt]=i;t[1][++cnt]=j;a[i][j]=0;                        }                        continue;                    }                    t[1][++cnt]=i;t[1][++cnt]=j;a[i][j]=1;                    if(cnt==6)break;                }            }            tot++;cnt=0;            for(int i=n-1;i&lt;=n;i++){                for(int j=m-1;j&lt;=m;j++){                    if(!a[i][j])continue;                    t[2][++cnt]=i;t[2][++cnt]=j;                }            }            cout&lt;&lt;tot&lt;&lt;endl;            for(int i=1;i&lt;=tot-2;i++)cout&lt;&lt;ans[i].x1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x3&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y3&lt;&lt;endl;            for(int i=1;i&lt;=2;i++)cout&lt;&lt;t[i][1]&lt;&lt;&#39; &#39;&lt;&lt;t[i][2]&lt;&lt;&#39; &#39;&lt;&lt;t[i][3]&lt;&lt;&#39; &#39;&lt;&lt;t[i][4]&lt;&lt;&#39; &#39;&lt;&lt;t[i][5]&lt;&lt;&#39; &#39;&lt;&lt;t[i][6]&lt;&lt;endl;         }        else if(cnt==3){            tot++;int cnt=0;            for(int i=n-1;i&lt;=n;i++){                for(int j=m-1;j&lt;=m;j++){                    if(!a[i][j])continue;                    t[1][++cnt]=i;t[1][++cnt]=j;                }            }            cout&lt;&lt;tot&lt;&lt;endl;            for(int i=1;i&lt;=tot-1;i++)cout&lt;&lt;ans[i].x1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x3&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y3&lt;&lt;endl;            for(int i=1;i&lt;=1;i++)cout&lt;&lt;t[i][1]&lt;&lt;&#39; &#39;&lt;&lt;t[i][2]&lt;&lt;&#39; &#39;&lt;&lt;t[i][3]&lt;&lt;&#39; &#39;&lt;&lt;t[i][4]&lt;&lt;&#39; &#39;&lt;&lt;t[i][5]&lt;&lt;&#39; &#39;&lt;&lt;t[i][6]&lt;&lt;endl;         }        else if(cnt==4){            cout&lt;&lt;tot+4&lt;&lt;endl;            for(int i=1;i&lt;=tot;i++)cout&lt;&lt;ans[i].x1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x3&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y3&lt;&lt;endl;            cout&lt;&lt;n-1&lt;&lt;&#39; &#39;&lt;&lt;m-1&lt;&lt;&#39; &#39;&lt;&lt;n&lt;&lt;&#39; &#39;&lt;&lt;m-1&lt;&lt;&#39; &#39;&lt;&lt;n&lt;&lt;&#39; &#39;&lt;&lt;m&lt;&lt;endl;            cout&lt;&lt;n-1&lt;&lt;&#39; &#39;&lt;&lt;m-1&lt;&lt;&#39; &#39;&lt;&lt;n-1&lt;&lt;&#39; &#39;&lt;&lt;m&lt;&lt;&#39; &#39;&lt;&lt;n&lt;&lt;&#39; &#39;&lt;&lt;m&lt;&lt;endl;            cout&lt;&lt;n-1&lt;&lt;&#39; &#39;&lt;&lt;m-1&lt;&lt;&#39; &#39;&lt;&lt;n-1&lt;&lt;&#39; &#39;&lt;&lt;m&lt;&lt;&#39; &#39;&lt;&lt;n&lt;&lt;&#39; &#39;&lt;&lt;m-1&lt;&lt;endl;            cout&lt;&lt;n-1&lt;&lt;&#39; &#39;&lt;&lt;m&lt;&lt;&#39; &#39;&lt;&lt;n&lt;&lt;&#39; &#39;&lt;&lt;m-1&lt;&lt;&#39; &#39;&lt;&lt;n&lt;&lt;&#39; &#39;&lt;&lt;m&lt;&lt;endl;        }        else{            cout&lt;&lt;tot&lt;&lt;endl;            for(int i=1;i&lt;=tot;i++)cout&lt;&lt;ans[i].x1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y1&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y2&lt;&lt;&#39; &#39;&lt;&lt;ans[i].x3&lt;&lt;&#39; &#39;&lt;&lt;ans[i].Y3&lt;&lt;endl;        }    }    return 0;}</code></pre>        <div id="aplayer-VCBQHbBN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-VCBQHbBN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>constructive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1446B-Catching Cheaters</title>
    <link href="/2020/11/16/CodeForces-1446B-Catching%20Cheaters/"/>
    <url>/2020/11/16/CodeForces-1446B-Catching%20Cheaters/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p> <img src="https://img-blog.csdnimg.cn/20201116101838941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="img"> </p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>定义DP[i][j]为以Ai和Bi作为结尾点的最大的答案（LCS(C,D)*4-|C|-|D|）,显然允许公共子序列为空，这样DP[i][j]=0.</p><p>有两种转移方式：<br>1.Ai==Bj，则DP[i][j]=min(DP[i][j],DP[i-1][j-1]+2),因为以Ai和Bj结尾的两个连续子串C和D的公共子序列的长度+1，同时两个连续子串C和D的长度+1，因此对答案的贡献就+2.<br>2.Ai!=Bj,DP[i][j]=max(DP[i][j],max(dp[i][j-1],DP[i-1][j])-1),因为以Ai和Bj结尾的两个连续子串C和D的公共子序列的长度不变，但是连续子串C或者D的长度+1，因此对答案的贡献-1</p><p><strong>PS：</strong>为什么情况2不会影响最优答案的形成？</p><p>由于情况2永远不会获得更大的LCS，它对答案的贡献也是越来越少。并且我们得到的答案一定是由情况1形成的。情况二只是针对部分C、D之间一段不存在公共子序列的情况，当到达情况一的时候并结合之前的贡献总和从而使得答案增大。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5000+50;int dp[maxn][maxn],n,m;char A[maxn],B[maxn];int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;A+1&gt;&gt;B+1;int len1=strlen(A+1),len2=strlen(B+1);    int ans=0;    for(int i=1;i&lt;=len1;i++){        for(int j=1;j&lt;=len2;j++){            if(A[i]==B[j]){                dp[i][j]=max(dp[i][j],max(dp[i-1][j-1]+2,2));            }            else{                dp[i][j]=max(dp[i][j],max(dp[i-1][j]-1,dp[i][j-1]-1));            }            ans=max(ans,dp[i][j]);        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-CJvunVhd" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CJvunVhd"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1438D-Powerful Ksenia</title>
    <link href="/2020/11/14/CodeForces-1438D-Powerful%20Ksenia/"/>
    <url>/2020/11/14/CodeForces-1438D-Powerful%20Ksenia/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>​    <img src="https://img-blog.csdnimg.cn/20201114163444944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"> </p><p>有一个长度为n的数组a，每次选择三个数字ai^aj^ak，使得最后n个数字都相等。如果存在就输出“YES”，并且输出操作次数m，再输出m行，每行是操作的数的下标；否则就输出“NO”</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>先考虑n为奇数的情况。假设n-1个数字两两相等，那么就剩余一个数字未配对，每次将这个数字（假设下标为i）ai与那n-1个数字中的任意两个进行异或，最后都可以变成ai。如何将这n-1个数字两两相等？假设那个未配对的数字是an，那么之间的1~n-1个数字可以三个为一组进行异或，前一组将ai,ai-1,ai-2进行异或，当前这组将ai+2,ai+1,ai进行异或.这样操作就可以将前n-1个数字两两配对相等。最后两两配对的数字再都与最后一个数字an进行异或就可以将n个数字都变成an。</p><p>那如何考虑n为偶数的情况？</p><p>n为偶数的时候，将数组a全部进行异或之后，假设可以实现最后全部相等，那么异或的结果就是0.假设当前对ai,aj,ak异或，那么ai=aj=ak=ai^aj^ak.那么此时再对ai,aj,ak异或，ai’^aj’^ak’=(ai^aj^ak)(ai^aj^ak)(ai^aj^ak),这样其实和原来是相等的。所以a数组最初的所有数字异或的结果=a数组最终结果的所有数字异或结果，最终由于a数组全部相等，那么a数组的异或结果就是0，即a数组的最初异或结果是0.我们将前n-1个数字当作奇数进行处理，就可以将前n-1个数字都变成an。因为前n-1个的异或结果=an，而前n-1个当作奇数情况进行上述<strong>情况一</strong>进行处理都变成了相同的数，显然最后都变了an。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+50;typedef long long ll;int n,a[maxn],cnt;struct Node{    int x,y,z;}t[maxn];int main(){    cin&gt;&gt;n;    int x=0;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],x^=a[i];    sort(a+1,a+1+n);    if(n%2){        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        for(int i=1;i+2&lt;=n;i+=2){            cnt++;t[cnt].x=i;t[cnt].y=i+1;t[cnt].z=i+2;        }        for(int i=1;i+1&lt;=n-1;i+=2){            cnt++;t[cnt].x=i;t[cnt].y=i+1;t[cnt].z=n;        }        cout&lt;&lt;cnt&lt;&lt;endl;        for(int i=1;i&lt;=cnt;i++){            cout&lt;&lt;t[i].x&lt;&lt;&#39; &#39;&lt;&lt;t[i].y&lt;&lt;&#39; &#39;&lt;&lt;t[i].z&lt;&lt;endl;        }    }    else{        if(x){            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        }        else{            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;            n--;            for(int i=1;i+2&lt;=n;i+=2){                cnt++;t[cnt].x=i;t[cnt].y=i+1;t[cnt].z=i+2;            }            for(int i=1;i+1&lt;=n-1;i+=2){                cnt++;t[cnt].x=i;t[cnt].y=i+1;t[cnt].z=n;            }            cout&lt;&lt;cnt&lt;&lt;endl;            for(int i=1;i&lt;=cnt;i++){                cout&lt;&lt;t[i].x&lt;&lt;&#39; &#39;&lt;&lt;t[i].y&lt;&lt;&#39; &#39;&lt;&lt;t[i].z&lt;&lt;endl;            }        }    }    return 0;}</code></pre>        <div id="aplayer-xQzfFzoK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-xQzfFzoK"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1438C-Engineer Artem</title>
    <link href="/2020/11/14/CodeForces-1438C-Engineer%20Artem/"/>
    <url>/2020/11/14/CodeForces-1438C-Engineer%20Artem/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h1><p>Engineer Artem </p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p> <img src="https://img-blog.csdnimg.cn/20201114115204514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Bob2VuaXhfWmVuZ0hhbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> </p><p>有T组数据，每组数据有一个n行m列的矩阵，希望通过一种操作使得矩阵任意相邻的数字不同，这个操作只能让某一个数字加1，可以操作无限次，但是每一个方格只能操作一次。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>一个数字一定可以由奇数变成偶数或者由偶数变成奇数，我们可以让坐标x+y为偶数的格子放偶数，x+y为奇数的格子放奇数。即：如果x+y为偶数的格子上的数为奇数，就让它+1；如果x+y为奇数的格子上的数为偶数，就让它+1，这样就实现的奇偶相间，也保证了相邻不等。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1005;int a[maxn][maxn],T,n,m;int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++){            for(int j=1;j&lt;=m;j++){                cin&gt;&gt;a[i][j];                if((i+j)%2==0){                    if(a[i][j]%2)a[i][j]++;                }                else{                    if(a[i][j]%2==0)a[i][j]++;                }            }        }        for(int i=1;i&lt;=n;i++){            for(int j=1;j&lt;=m;j++){                cout&lt;&lt;a[i][j]&lt;&lt;&#39; &#39;;            }            cout&lt;&lt;endl;        }    }    return 0;}</code></pre>        <div id="aplayer-bLjUVXqm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-bLjUVXqm"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1205-活动安排</title>
    <link href="/2020/11/08/NOJ-1205-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92/"/>
    <url>/2020/11/08/NOJ-1205-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h1><p><strong>描述</strong></p><p>Jack是一名nwpu的大一新生，对学校举办的各种活动都十分的好奇，想尽可能多的参加这些活动。Npwu每天共有N项活动，其开始结束时间分别为B[i],E[i],(i = 1,2,……N)<br>请问Jack一天最多能参加几项活动。当然，Jack在同一时间内只能参加一项活动，即jack参加的活动时间上不能重叠，但时间为[t1,t2],[t2,t3]的两个活动是可以同时参加的。</p><p><strong>输入</strong></p><p>第一行 一个整数N(1&lt;=n&lt;=1000)表示活动总数。<br>接下来N行表示各活动的起始，结束时间0&lt;=B[i]&lt;E[i]&lt;24</p><p><strong>输出</strong></p><p>一个整数表示Jack最多能参加的活动数目。</p><p><strong>输入样例</strong></p><p>4<br>10 11<br>2 3<br>8 10<br>0 2</p><p><strong>输出样例</strong></p><p>4</p><p><strong>提示</strong><br>printf(“%d\n,num”);</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>题意很明显希望参加的活动数目尽量多。对于活动安排问题可以采取动态规划的策略：</p><p>首先将活动的结束时间按照第一关键字排序（由小到大），再将活动的开始时间作为第二关键字排序（由小到大）</p><p>定义<strong>dp[i]</strong>表示在前i场比赛中最多可以参加几场比赛，</p><p>由此得出方程：dp[i]=max(dp[i-1],dp[temp]+1);</p><p>temp指从dp[i-1]向前找到的第一个允许参加第i场活动的活动编号，由它推导出dp[i]=dp[temp]+1;</p><p>由于每次循环时都向前找一次temp会浪费太多时间，又因为活动开始或结束时间是单调递增的，</p><p>故可以令temp在循环时逐步递增，这样时间复杂度就降到了O(n).</p><p>这里只是讲解一下动态规划的想法。就不写代码了，动态规划的代码和下面的贪心方法相似。只是这种动态规划的思路是基于贪心的思想来实现的。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>这个问题可以抽象为在一个数轴上有n条线段，现要选取其中k条线段使得这k条线段两两没有重合部分，问最大的k为多少。<br>最左边的线段放什么最好？<br>显然放右端点最靠左的线段最好，从左向右放，右端点越小妨碍越少。<br>其他线段放置按右端点排序，贪心放置线段，即能放就放。</p><p>以上两种方法的时间复杂度都是O(nlogn)，快速排序的时间复杂度是O(nlogn),而动态规划或者贪心执行更新策略的时间复杂度是O(n).</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2e3+50;int n;struct Node{    int s,f;}a[maxn];bool cmp(Node x,Node y){    if(x.f==y.f)return x.s&lt;y.s;    return x.f&lt;y.f;}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].s&gt;&gt;a[i].f;    sort(a+1,a+1+n,cmp);    int ans=1,now=1,opt=2;    while(opt&lt;=n){        if(a[opt].s&gt;=a[now].f){            ans++;            now=opt;        }        opt++;    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-CGpfWJGZ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CGpfWJGZ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1001-二分查找</title>
    <link href="/2020/11/08/NOJ-1001-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/11/08/NOJ-1001-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>描述</strong></p><p>给定一个单调递增的整数序列，问某个整数是否在序列中。</p><p><strong>输入</strong></p><p>第一行为一个整数n，表示序列中整数的个数；第二行为n（n不超过10000）个整数；第三行为一个整数m（m不超过50000），表示查询的个数；接下来m行每行一个整数k。</p><p><strong>输出</strong></p><p>每个查询的输出占一行，如果k在序列中，输出Yes，否则输出No。</p><p><strong>输入样例</strong></p><p>5<br>1 3 4 7 11<br>3<br>3<br>6<br>9</p><p><strong>输出样例</strong></p><p>Yes<br>No<br>No</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>按照题目要求进行二分查找，由于a[]是单增数列，所以对于每一个输入查询x，我们先设置左边界l=1，有边界r=n，ans储存可能的位置，进行二分查找，每一次二分查找时mid=(l+r)/2。如果a[mid]&gt;=x，说明如果存在x，那么x一定在左边界（包括mid），那么此时r=mid-1，ans=mid；如果a[mid]&lt;x，则说明x一定在有边界。二分查找完之后，要验证a[ans]是否等于x，因为二分只是由于它是有序序列进行二分，不断查找与x最接近的数字，但它不一定能够是x。</p><p>这个方法时间复杂度为O(nlogn).</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=50000+50;int n,a[maxn],m;int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    cin&gt;&gt;m;    while(m--){        int x;        cin&gt;&gt;x;        int l=1,r=n,ans=0;        while(l&lt;=r){            int mid=(l+r)/2;            if(a[mid]&gt;=x){                r=mid-1;                ans=mid;            }            else{                l=mid+1;            }        }        if(a[ans]==x){            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        }        else{            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>题目要求很明确，就是问x是否在a[]中存在，那就把a[]中出现过的数字进行标记就可以了，这里对 a[]中的每一个数字的范围解释不够清楚，所以我们可以用map进行映射处理。当然其实也可以vis[]数组进行标记，vis[]大小设置为5e5，这样让vis[a[i]]=1,然后查询vis[x]是否等于1就可以了，或者用map标记方法也一样。这种方法的时间复杂度O(n)(直接数组标记)或者O(nlogn)(map)。</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt; using namespace std;const int maxn=50000+50;map&lt;int,int&gt;mp;int n,a[maxn],m;int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],mp[a[i]]=1;    cin&gt;&gt;m;    while(m--){        int x;        cin&gt;&gt;x;        if(mp[x]==1){            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        }        else{            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        }    }}</code></pre>        <div id="aplayer-YTKxYBhM" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-YTKxYBhM"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-1541-加1乘2平方</title>
    <link href="/2020/11/08/NOJ-1541-%E5%8A%A01%E4%B9%982%E5%B9%B3%E6%96%B9/"/>
    <url>/2020/11/08/NOJ-1541-%E5%8A%A01%E4%B9%982%E5%B9%B3%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="加1乘2平方"><a href="#加1乘2平方" class="headerlink" title="加1乘2平方"></a>加1乘2平方</h1><p><strong>描述</strong></p><p>给定两个正整数m、n，问只能做加1、乘2和平方这三种变化，从m变化到n最少需要几次</p><p><strong>输入</strong></p><p>输入两个10000以内的正整数m和n，且m小于n</p><p><strong>输出</strong></p><p>输出从m变化到n的最少次数</p><p><strong>输入样例</strong></p><p>1 16</p><p><strong>输出样例</strong></p><p>3</p><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>设定dp[i]表示从m到达i最少需要i步。初始化dp[]无穷大，显然dp[m]=0,即到起点的步数为0。对于i来讲可以到达i的只有三种状态：i-1、i/2、sqrt(i)（其中i/2和sqrt(i)需要满足整数条件）。这也是基于i整体单增的条件才满足动态规划。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 10000 + 50;int dp[maxn], n,m;int min(int x,int y){    if(x&lt;=y)return x;    return y;}int main(){    cin &gt;&gt; m &gt;&gt; n;    memset(dp, 0x3f3f3f3f, sizeof(dp));    dp[m] = 0;    for (int i = m + 1; i &lt;= n;i++){        int t = sqrt(i);        dp[i] = min(dp[i], dp[i - 1]+1);        if(i%2==0)            dp[i] = min(dp[i], dp[i / 2]+1);        if(t*t==i)            dp[i] = min(dp[i], dp[t] + 1);    }    cout &lt;&lt; dp[n] &lt;&lt; endl;    return 0;}</code></pre><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>按照一般的方法进行BFS。一个点i往后搜索，它可以到达三个状态：i+1，i <em> 2，i </em> i，并且相应的步数+1.对于一个状态i如果已经到达过了就没必要再进行搜索了，因为第一次到达它的时候所耗步数一定是最小的，因为BFS本身就是层次遍历，一定是步数小的执行，所以只需要处理第一次到达的情况。并且在BFS的同时把到达过的点都标记了，避免重复搜索。一旦到达n就可以直接输出答案了，当然continue继续也没错。</p><p>网上的代码感觉基本雷同。所以这里写了两个方法，一个递推另一个队列+BFS（一般bfs都是配队列，当然优先队列有时效果更佳）。当然这里显然用递推是最简单的，而且O(n)的时间复杂度明显比bfs快。（测试数据：1 1000000）。</p><p><strong>ps：</strong>if(now.now&gt;=n||vis[now.now])continue;这里顺序不要调换，不然运行错误了找半天错。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;const int maxn = 10000 + 50;struct Node{    int now, w;};int min(int x,int y){    if(x&lt;=y)return x;    return y;}int n, m,vis[maxn];queue&lt;Node&gt;q;int main(){    cin &gt;&gt; m &gt;&gt; n;    Node now;    now.now = m;    now.w = 0;    q.push(now);    int ans=0x3f3f3f3f;    while(!q.empty()){        now= q.front();q.pop();        if(now.now==n){            ans=min(ans,now.w);continue;        }        if(now.now&gt;=n||vis[now.now])continue;        vis[now.now]=1;        Node nex;nex.now=now.now+1;nex.w=now.w+1;q.push(nex);        nex.now=now.now*2;nex.w=now.w+1;q.push(nex);        nex.now=now.now*now.now;nex.w=now.w+1;q.push(nex);     }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-oHBssHjS" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-oHBssHjS"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第45届国际大学生程序设计竞赛(ICPC)亚洲网上区域赛模拟赛 E Eat Walnuts</title>
    <link href="/2020/11/08/%E7%AC%AC45%E5%B1%8A%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B(ICPC)%E4%BA%9A%E6%B4%B2%E7%BD%91%E4%B8%8A%E5%8C%BA%E5%9F%9F%E8%B5%9B%E6%A8%A1%E6%8B%9F%E8%B5%9B%20E%20Eat%20Walnuts/"/>
    <url>/2020/11/08/%E7%AC%AC45%E5%B1%8A%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B(ICPC)%E4%BA%9A%E6%B4%B2%E7%BD%91%E4%B8%8A%E5%8C%BA%E5%9F%9F%E8%B5%9B%E6%A8%A1%E6%8B%9F%E8%B5%9B%20E%20Eat%20Walnuts/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="E-Eat-Walnuts"><a href="#E-Eat-Walnuts" class="headerlink" title="E Eat Walnuts"></a>E Eat Walnuts</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>As we all know, in the ACM ICPC held in 2017, the organizer of Xinjiang University presented a box of walnuts to each coach. Our coach is happy to share with the team members except Mr.Watermelon. He is going to test Mr.Watermelon with a game when Mr.Watermelon want to eat some walnuts.</p><p>He put some walnuts in a row and let Mr.Watermelon pick one of them. And this walnut is not the ﬁrst or last in the queue. The price Mr.Watermelon need to pay is : the walnut, the walnut in front of the walnut, and the walnut behind the walnut , the square of the sum of the size of these three walnuts.</p><p>For example, now there is a row of walnuts in front of Mr.Watermelon. Their size is: 3 1 50 20 15. If this time Mr.Watermelon picked the third walnut. He needs to pay (1 + 50 + 20) ∗ (1 + 50 + 20) = 5041.</p><p>After a walnut is taken away, it will leave the queue. Then Mr.Watermelon picks a walnut again until only two walnuts remain in the queue.</p><p>Mr.Watermelon wants to know what the minimum price he will pay when he takes walnuts until there are only two walnuts in the queue. But he needs more time to spend with his girlfriend. So he ask you to help him calculate this problem.</p><p><strong>题意</strong>：</p><p>给一个数列，将除首尾以外的数删掉，每次删掉一个数a[i]的代价为（a[i - 1] + a[i] + a[i + 1])^ 2，问最小代价 </p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>Input contains multiple test cases.The ﬁrst line of each test case contains a integer n(3 ≤ n ≤ 100), the number of walnuts at the beginning. The second line contains n positive integers separated by spaces, representing the size of each walnut. Each positive integer does not exceed 1,000.For 50% of the testcases, n ≤ 50.For 90% of the testcases, n ≤ 90.For 100% of the testcases, n ≤ 100.The number of the testcases does not exceed 1000.</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>For each test case, print a integer–the minimum price Mr.Watermelon will pay.</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>53 1 50 20 15</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>6698</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最开始定义dp[l][r]表示删除l到r之间的所有数（不包括l和r）的最小代价，最后答案就是dp[1][n]，然后感觉有点绕了，于是重新定义一下，dp[l][r]表示删除l到r之间的所有数（包括l和r）的最小代价。先全部初始化为0x3f3f3f3f，对于dp[i][i]即删除一个数的代价是(a[i-1]+a[i]+a[i+1]) <em> (a[i-1]+a[i]+a[i+1]),接下来就是<strong>区间DP</strong>，对于长度为len的区间（len：2~n），枚举左边界l，右边界r显然就是<strong>l+len-1</strong>，要求dp[l][r]就是求两个区间合并的总代价+一个数删去的代价：dp[l][r] = min(dp[l][r], dp[l][mid - 1] + dp[mid + 1][r] + (a[l - 1] + a[mid] + a[r + 1]) </em> (a[l - 1] + a[mid] + a[r + 1])。但是如果mid==l或者mid==r呢？这时候就直接是一个区间的代价+一个数删除的代价（感觉这里我写复杂了）。最后答案就是dp[2][n-1].(首尾不删除)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 50;int n, dp[maxn][maxn], a[maxn];int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF){        memset(dp, 0x3f3f3f3f, sizeof(dp));        for (int i = 1; i &lt;= n;i++){            cin &gt;&gt; a[i];    //        dp[i][i] = dp[i][i + 1] = dp[i - 1][i] = 0;        }        for (int i = 2; i &lt;= n-1;i++)            dp[i][i] = (a[i] + a[i - 1] + a[i + 1]) * (a[i] + a[i - 1] + a[i + 1]);        for (int len = 2; len &lt;= n - 2;len++){            for (int l = 2; l &lt;= n;l++){                int r = l + len - 1;                if (r &gt;= n)                    continue;                for (int mid = l; mid &lt;= r; mid++){                    if(l==mid){                        dp[l][r] = min(dp[l][r], dp[mid + 1][r] + (a[l] + a[l - 1] + a[r + 1]) * (a[l] + a[l - 1] + a[r + 1]));                    }                    else if(r==mid){                        dp[l][r] = min(dp[l][r], dp[l][mid-1] + (a[r] + a[l-1] + a[r + 1]) * (a[r] + a[l-1] + a[r + 1]));                    }                    else{                        dp[l][r] = min(dp[l][r], dp[l][mid - 1] + dp[mid + 1][r] + (a[l - 1] + a[mid] + a[r + 1]) * (a[l - 1] + a[mid] + a[r + 1]));                    }                }            }        }            /*    for (int len = 2; len &lt;= n - 1;len++){            for (int l = 1; l &lt;= n;l++){                int r = l + len;//l+1...r-1删除了                for (int mid = l + 1; mid &lt;= r-1;mid++){                    dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid + 1][r] + (a[l] + a[mid] + a[r]) * (a[l] + a[mid] + a[r]));                }            }        }        cout &lt;&lt; dp[1][n] &lt;&lt; endl;    */        cout &lt;&lt; dp[2][n - 1] &lt;&lt; endl;    }    return 0;}</code></pre>        <div id="aplayer-uxRjfqXz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-uxRjfqXz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-最大连续子序列和问题</title>
    <link href="/2020/11/06/NOJ-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/06/NOJ-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="最大连续子序列和问题"><a href="#最大连续子序列和问题" class="headerlink" title="最大连续子序列和问题"></a>最大连续子序列和问题</h1><p><strong>描述</strong>：</p><p>给定一整数序列A0，A1， A2，… An-1 （可能有负数），求A0~An-1的一个连续子序列Ai~Aj，使得Ai到Aj的和最大。</p><p><strong>输入</strong>：</p><p>先输入一个正整数n(1&lt;n&lt;1000)，再输入n个整数。</p><p><strong>输出</strong>：</p><p>输出最大连续子序列的和。</p><p><strong>输入样例</strong>：</p><pre><code>102 -1 5 -7 2 -1 4 -2 4 -5</code></pre><p><strong>输出样例</strong>：</p><pre><code>7</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>代码还没有AC，NOJ评测机炸了，但是这个O(n)的思路大概是对的：sum[i]为前i个数字的连续子序列的最大和。如果sum[i-1]<0，那对于sum[i]就没必要加上前i-1的总和了，因为这样对答案的贡献还不如0.如果sum[i-1]>0,则sum[i]=sum[i-1]+a[i].ans=max(ans,sum[i]);</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+50;int n,a[maxn],sum[maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}int main(){    int i;    cin&gt;&gt;n;    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    int ans=0;    for(i=1;i&lt;=n;i++){        if(sum[i-1]&gt;0)sum[i]=sum[i-1]+a[i];        else sum[i]=a[i];        ans=max(ans,sum[i]);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-qsCajlof" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-qsCajlof"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-0-1背包问题</title>
    <link href="/2020/11/06/NOJ-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/06/NOJ-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><p><strong>描述：</strong></p><p>一个背包容量为c ，现有n件物品，求能装入背包的最大重量是多少？</p><p><strong>输入：</strong></p><p>先输入两个正整数n、c（0&lt;n、c&lt;1000），表示物品的件数和背包容量，再输入n个正整数，分别是这n件物品的重量。</p><p><strong>输出：</strong></p><p>输出能装入背包的最大重量。</p><p><strong>输入样例：</strong></p><pre><code>5 5023 18 13 35 24</code></pre><p><strong>输出样例：</strong></p><pre><code>48</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>0-1背包的裸题，那就可以直接写一个01背包的动态转移方程：dp[j]=max(dp[j],dp[j-w[i]]+p[i])。dp[j]的意思是：当背包已装j的重量的物品时的最大价值。那么它可以由背包已装j-w[i]时最大的价值进行转移，即由dp[j-w[i]]+p[i]得到。注意每一次要将dp[]设置为0，因为背包此时无价值。当状态方程枚举结束后，我们再从 dp[]数组中找一遍，求得答案maxx=max{dp[i]}(i from 0 to c)，输出答案maxx。这种动态规划的方法的时间复杂度为O(n^2).</p><p><strong>ps：</strong>0-1背包也可以写成二维dp[][]，只是这样写成滚动数组可以更加节省空间。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>除了直接写0-1背包的动态转移方程，还可以直接写dfs，每一个背包无非就是取和不取两个状态，如果要取则要求背包容量 res&gt;=w[now]。分别用ans1，ans2表示取当前物品，不取当前物品的最大价值，dfs返回max(ans1,ans2)，dfs的终止条件是now ==n+1。时间复杂度(2^n)。</p><p><strong>ps:</strong>方法二相较于方法一思维上更加简单，容易想到，但是代码就相对麻烦，并且时间复杂度不够优秀，当然如果加上记忆化搜索后时间复杂度和动态规划是相当的。我个人更喜欢方法一。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=    2000+50;int n,c,w[maxn],dp[maxn],p[maxn];int main(){    int i,j;    scanf(&quot;%d%d&quot;,&amp;n,&amp;c);    for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i],p[i]=w[i];    for(i=1;i&lt;=n;i++){        for(j=c;j&gt;=1;j--){            if(j-w[i]&gt;=0&amp;&amp;dp[j]&lt;dp[j-w[i]]+p[i]){                dp[j]=dp[j-w[i]]+p[i];            }        }    }    int maxx=0;    for(i=0;i&lt;=c;i++)        if(maxx&lt;dp[i])            maxx=dp[i];    cout&lt;&lt;maxx&lt;&lt;endl;    return 0;}</code></pre><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=    2000+50;int n,c,w[maxn],p[maxn];int dfs(int now,int res){    if(now==n+1)return 0;    int ans1=0,ans2=0;    if(res&gt;=w[now]){        ans1=dfs(now+1,res-w[now])+p[now];    }    ans2=dfs(now+1,res);    if(ans1&gt;=ans2)return ans1;    return ans2;}int main(){    int i,j;    scanf(&quot;%d%d&quot;,&amp;n,&amp;c);    for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i],p[i]=w[i];    cout&lt;&lt;dfs(1,c)&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-bkEEOeOb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-bkEEOeOb"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-滑雪</title>
    <link href="/2020/11/05/NOJ-%E6%BB%91%E9%9B%AA/"/>
    <url>/2020/11/05/NOJ-%E6%BB%91%E9%9B%AA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h1><p><strong>描述</strong></p><p>Michael喜欢滑雪这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9<br>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。</p><p><strong>输入</strong></p><p>输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。</p><p><strong>输出</strong></p><p>输出最长区域的长度。 </p><p><strong>输入样例</strong></p><p>5 5<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9</p><p><strong>输出样例</strong></p><p>25</p><p><strong>输出提示</strong><br>printf(“%d\n,num”);</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>问题问的是最长的高度减小的序列的长度（要依次相邻），设dp[i][j]表示到达(i,j)的最长的高度不减小序列的长度。一开始想着将问题转化成最长的高度不减小（即hi&gt;=hj），然后就由每一个点出发找到相邻的比它高的，由此更新dp数组。但是发现初始点不好找，一旦要找肯定都得找一遍（直接找最小的不一定最优，这样的贪心策略很显然是错误的，完全可能最后的终点高度不是最小的），然后遍历到一个点(i,j)肯定又要更新答案，并且不能将(i,j)标记掉让后面的点不能再走到它，这样会让答案不是最优的。所以我就放弃了这种方法。</p><p>但是我们将所有的点都走一遍，由高到低进行记忆化搜索，dp[x][y]表示当前走到(x,y)的最长的高度减小的序列的长度。一旦dp[x][y]存在说明之前已经遍历过了就直接返回，否则就找到周围比它高度小的点进行dfs。这样讲所有的点都作为起点进行dfs求得的答案就是最长的长度。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200+50;int n,m,h[maxn][maxn],dp[maxn][maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};int dfs(int x,int y){    if(dp[x][y])return dp[x][y];    dp[x][y]=1;    int sign=0,ans=0,i;    for(i=0;i&lt;4;i++){        int nexx=x+d[i][0],nexy=y+d[i][1];        if(nexx&gt;=1&amp;&amp;nexx&lt;=n&amp;&amp;nexy&gt;=1&amp;&amp;nexy&lt;=m&amp;&amp;h[nexx][nexy]&gt;h[x][y])sign++,ans=max(ans,dfs(nexx,nexy)+1);    }    if(!sign)dp[x][y]=1;    else dp[x][y]=ans;    return dp[x][y];}int main(){    cin&gt;&gt;n&gt;&gt;m;    int i,j,k,maxx=0;    for(i=1;i&lt;=n;i++){        for(j=1;j&lt;=m;j++){            cin&gt;&gt;h[i][j];        }    }    int ans=0;    for(i=1;i&lt;=n;i++){        for(j=1;j&lt;=m;j++){            ans=max(ans,dfs(i,j));        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-brlqqorm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-brlqqorm"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-装盘子</title>
    <link href="/2020/11/05/NOJ-%E8%A3%85%E7%9B%98%E5%AD%90/"/>
    <url>/2020/11/05/NOJ-%E8%A3%85%E7%9B%98%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="装盘子"><a href="#装盘子" class="headerlink" title="装盘子"></a>装盘子</h1><p><strong>描述</strong></p><p>N人为了大快朵颐，行至云餐二楼，取了N个盘子，打了M个饺子。现欲将M个饺子装入N个盘子中，试问共有多少种不同的装法？<br>假设盘子足够大，并且盘子里可以什么都不放。注意像2 5 0和5 0 2之类的属于同一种放法。</p><p><strong>输入</strong></p><p>两个整数M、N(1=&lt; M,N &lt;=100)以空格隔开。</p><p><strong>输出</strong></p><p>单独一行输出共有几种装法。</p><p><strong>输入样例</strong></p><p>7 3</p><p><strong>输出样例</strong></p><p>8</p><p><strong>提示</strong></p><p>注意输出要以“\n”结尾。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>问m个饺子放到n个盘子的方法，这个题直接写动态转移方程不好写，那就换成写记忆化搜索就行了。考虑m&gt;=n和m<n两种情况。dfs(int resn ,int resm)表示剩余resn个盘子，剩余resm个饺子的放置种类数目，dp[resn][resm]对其进行记录，一旦dp[resn][resm]遍历过，就直接返回即可，优化时间复杂度。m<n的话肯定有n-m个盘子都是空的ans=dfs(rem,rem)。m>=n的话可以一个盘子不妨饺子即dfs(resn-1,resm ),也可以将每个盘子都至少放一个饺子即dfs(resn,resm-resn).由dfs(resn-1,resm)不断搜索下去可以对不同数量的空盘子均可以遍历到。最后答案就是dfs(n,m).</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+50;int n,m,dp[maxn][maxn];int dfs(int resn,int resm){    if(resn==1||resm==1||resm==0)return 1;    if(dp[resn][resm])return dp[resn][resm];    int ans=0;    if(resm&lt;resn)ans=dfs(resm,resm);    else ans=dfs(resn-1,resm)+dfs(resn,resm-resn);    dp[resn][resm]=ans;    return ans;}int main(){    cin&gt;&gt;m&gt;&gt;n;    cout&lt;&lt;dfs(n,m)&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-NRXBDozL" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-NRXBDozL"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1442-B</title>
    <link href="/2020/11/04/CodeForces-1442-B/"/>
    <url>/2020/11/04/CodeForces-1442-B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h1><p>Identify the Operations</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>一个数组a长度为n，一个数组b长度为m，a数组中的元素各不相同，b数组中的元素各不相同。在a数组中要将ai加入到bi中，可以将ai-1,ai+1划去，然后ai加入到b数组的右侧。问得到b数组的总方案数，答案对<strong>998244353</strong>取模。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>Div2的最后一题居然是水题，这是我没想到的，错过了大好的上分时机。要依次将a数组的一些元素加入到b数组中来得到b数组。这里有三种情况：</p><p>1）如果ai-1和ai+1都在b数组中。此时他们都还在数组a中，ai想加入b数组中，必须划去ai-1或者ai+1，但是显然无法划去。对于这种情况的选择方案为0.</p><p>2）ai-1和ai+1中有一个在b中，而另外一个不在。可以划去那个不在b数组中的。方案数为1.</p><p>3）ai-1和ai+1两个数字都不在b中，则有两种方案。</p><p>用vis数组来标记ai是否在b数组中。用pos数组表示一个值w在a数组中对应的位置。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200000 + 50;const int Mod = 998244353;typedef long long ll;ll a[maxn], b[maxn],pos[maxn],T,n,m,vis[maxn];int main(){    cin &gt;&gt; T;    while(T--){        cin &gt;&gt; n &gt;&gt; m;        for (int i = 1; i &lt;= n;i++){            cin &gt;&gt; a[i];            pos[a[i]] = i;            vis[a[i]] = 0;        }        for (int i = 1; i &lt;= m;i++){            cin &gt;&gt; b[i];            vis[b[i]] = 1;        }        ll ans = 1;        for (int i = 1; i &lt;= m;i++){            ll cnt = 0;            vis[b[i]] = 0;            if(pos[b[i]]-1&gt;=1&amp;&amp;!vis[a[pos[b[i]]-1]])                cnt++;            if(pos[b[i]]+1&lt;=n&amp;&amp;!vis[a[pos[b[i]]+1]])                cnt++;            ans = (ans * cnt) % Mod;        //    cout &lt;&lt; cnt &lt;&lt; endl;        }        cout &lt;&lt; ans &lt;&lt; endl;    }    return 0;}</code></pre>        <div id="aplayer-eyxLGJzC" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-eyxLGJzC"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-花生米（五）</title>
    <link href="/2020/11/04/NOJ-%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2020/11/04/NOJ-%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="花生米（五）"><a href="#花生米（五）" class="headerlink" title="花生米（五）"></a>花生米（五）</h1><p><strong>描述</strong></p><p>五一长假第六天，Tom在QQ上遇到了Kitty。呵呵，Kitty，在离散数学课上认识的PPMM……等等！Tom恍然大悟：自己这一生除了看帖不回之外最大的错误就是离散数学没学好！<br>五一长假第七天，Tom和Jerry在仓库散步的时候发现了一堆花生米（仓库，呵呵，仓库…）。这次Tom制定分花生米规则如下：<br>1、首先选出最苦的一粒花生米，放到一个瓶子里；<br>2、把剩下的花生米做成花生酱，Tom和Jerry轮流取一些花生酱吃掉；<br>3、第一个取的人只能取1.0克，以后取花生酱的数量不能少于两个人已经取过的总数量且不能超过两个人已经取过的总数量的三倍；<br>4、不能按规则3取花生酱的人必须吃掉瓶子里的花生米；<br>5、为显示规则的公平性，Jerry可以选择先取或者后取。<br>Jerry当然希望瓶子里的花生米被Tom吃掉。请计算，Jerry为了达到目的应该先取还是后取。</p><p><strong>输入</strong></p><p>本题有多个测例，每个测例的输入是一个浮点数w，w大于1.0小于等于1000.0，w最多只有一位小数，代表花生酱的数量，单位为克。<br>w小于0表示输入结束，不需要处理。</p><p><strong>输出</strong></p><p>每个测例在单独的一行内输出一个整数：Jerry先取输出1；Tom先取输出0。</p><p><strong>输入样例</strong></p><p>1.5<br>7.9<br>-1</p><p><strong>输出样例</strong></p><p>1<br>0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题和<strong>花生米（三）</strong>极其相似 <a href="https://blog.csdn.net/Phoenix_ZengHao/article/details/109495550" target="_blank" rel="noopener">https://blog.csdn.net/Phoenix_ZengHao/article/details/109495550</a>    ，只是<strong>花生米（三）</strong>中要求是后者取的花生数不能超过前者的两倍，而这个题后者取的花生数w&gt;=前面取的花生的总数并且w&lt;=前面取的花生的总数的三倍，并且Jerry希望Tom无法按则规则取花生这样Jerry就胜利了。显然这个题和<strong>花生米（三）</strong>都无法确认当前人取花生的数量，只能确认一个范围进行枚举。并且这个题还是小数。由于最多一位小数，那就全部乘10，这样就全部转化成整数问题了。dp[res]表示剩余res个的时候后手的必胜或者必败，dp[res]=0表示剩余res个的情况后手必胜。从<strong>花生米（三）</strong>知道一个状态要是必胜态，必须保证推导它的之前的状态都是必败（即要后手必胜，必须保证先手必败），设先手取了c个花生米，那么对于后手就要枚举他选择i个花生的所有状态（i from c to 3 <em> c），并且dfs的结果均为1（即先手必败）。这里用到了记忆化搜索，不赘述。这个题可以用一维数组表示的原因是由c我们就可以得到res，由res就可以得到c，因为res+c=n，所以二维数组就可以简化成一维。而<em>*花生米（三）</em></em>则不能这样表示。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+50;int dp[maxn];int dfs(int res,int c){    int i;    if(res&lt;c){        dp[res]=0;        return dp[res];    }    if(dp[res]!=-1)return dp[res];    int sign=1;    for(i=c;i&lt;=3*c;i++){        if(res&lt;i)break;        sign&amp;=dfs(res-i,c+i);        if(sign==0)break;    }    dp[res]=0;    if(!sign)dp[res]=1;    return dp[res];}int main(){    int tot=0;    while(1){        int i;        double x;        cin&gt;&gt;x;        if(x&lt;0)break;        for(i=0;i&lt;=x*10;i++){            dp[i]=-1;        }        int w=x*10;        cout&lt;&lt;1-dfs(w-10,10)&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-nqviYXty" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-nqviYXty"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-花生米（四）</title>
    <link href="/2020/11/04/NOJ-%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2020/11/04/NOJ-%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="花生米（四）"><a href="#花生米（四）" class="headerlink" title="花生米（四）"></a>花生米（四）</h1><p><strong>描述</strong></p><p>五一长假第四天，Tom逛了N个bbs，做了N^2个脑筋急转弯题，终于发现了每次吃完花生米嘴里都是苦味的原因：自己总会吃到最后一粒花生米。<br>五一长假第五天，Tom和Jerry在仓库散步的时候发现了n堆花生米（这是什么仓库啊？！）。这次Tom制定分花生米规则如下：<br>1、首先选出最苦的一粒花生米，放到一个瓶子里；<br>2、Tom和Jerry轮流从任意一堆花生米中取出任意粒吃掉；<br>3、如果Tom吃到最后一粒花生米（瓶子里的花生米除外），Jerry必须吃掉瓶子里的花生米；如果Jerry吃到最后一粒花生米（瓶子里的花生米除外），Tom自愿吃掉瓶子里的花生米；<br>4、为显示规则的公平性，Jerry可以选择先取或者后取。<br>Jerry当然希望瓶子里的花生米被Tom吃掉。请计算，Jerry为了达到目的应该先取还是后取。</p><p><strong>输入</strong></p><p>本题有多个测例。<br>每个测例的输入第一行是一个整数n，n大于零小于等于10，代表花生米的堆数（取出最苦花生米后）；接下来n行每行一个不超过100的正整数，分别代表一堆花生米的粒数（取出最苦花生米后）。<br>n等于0表示输入结束，不需要处理。</p><p><strong>输出</strong></p><p>每个测例在单独的一行内输出一个整数：Jerry先取输出1；Tom先取输出0。</p><p><strong>输入样例</strong></p><p>2<br>1<br>1<br>2<br>1<br>100<br>0</p><p><strong>输出样例</strong></p><p>0<br>1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题对比与前两个<a href="https://blog.csdn.net/Phoenix_ZengHao/article/details/109495550" target="_blank" rel="noopener">https://blog.csdn.net/Phoenix_ZengHao/article/details/109495550</a></p><p><a href="https://blog.csdn.net/Phoenix_ZengHao/article/details/109495057" target="_blank" rel="noopener">https://blog.csdn.net/Phoenix_ZengHao/article/details/109495057</a></p><p>的区别在于前两个都是Jerry希望Tom拿到最后一颗花生米。现在这个题是Jerry希望自己拿到最后一颗花生米。并且 Tom和Jerry轮流从任意一堆花生米中取出任意粒吃掉。这个初看觉得比较复杂，所以我自己把情况分成了几种情况进行讨论：</p><p>1.只有1堆花生米，那Jerry必须先手，否则让Tom先手的话，Tom直接全部取走，先手必胜。所以Jerry要先取，答案输出1.（测试数据没有这个测试点）。</p><p>2.所有的花生堆都是1个为一堆，设有n堆，如果n是偶数，那么后手必胜，Jerry选择后手，答案输出0；如果n是奇数，那么先手必胜，Jerry选择先手，答案输出1。</p><p>3.如果存在花生数量&gt;1的花生堆：</p><p>​        (1)如果总共就两堆花生：如果两堆数目一样，后手只要按照先手的取法跟着取就好了。后手必胜，输出0；否则先手必胜，输出1；</p><p>​        (2)如果花生堆数&gt;2:这时候需要判断含1个花生米的堆数，和含&gt;1个花生米的堆数。sign1=0表示只含一个花生米的堆数为偶数，sign2=0表示含&gt;1个花生米的堆数为偶数。（这里偶数不含0，为0就表示不存在这种类型的花生堆，应该认为这时的sign=1）</p><p>​        当sign1==1&amp;&amp;sign2==1的时候： 全奇数堆先手必胜，所以Jerry必须先手：比如1 1 1 3 3 3—&gt;1 3 3 3先手必胜 （后手无法赢）  </p><p>​        当存在偶数堆，则让对手取成全奇，在此之前，Jerry保持非全奇  ：比如1 1 1 1 3 3 3 3 .如果先手选3，后手跟着选3，直到3用完，先手选择1，后手到达必胜态 。 如果 先手选3中的2，—&gt;1 1 1 1 1 3 3 3 后手选 1—&gt;1 1 1 1 3 3 3,直到3用完，先手选择1，后手到达必胜态。 同理1 1 1 3 3 3 3类型和1 1 1 1 3 3 3类型。  </p><p><strong>ps</strong>： 注意 7 3 3 3 3 3 3 3 这种类型即含1个花生米的堆数=0，这个时候sign1=1，sign2=1，就是指只存在奇数堆，先手必胜。  </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,a[maxn];int main(){    while(1){        cin&gt;&gt;n;        if(n==0)break;        int sum=0,cnt=0,tot=0;         for(int i=1;i&lt;=n;i++){            cin&gt;&gt;a[i],sum+=a[i];            if(a[i]==1)cnt++;        }        if(n==1){            cout&lt;&lt;1&lt;&lt;endl;        }        else if(cnt==n){            if(n%2==0)cout&lt;&lt;0&lt;&lt;endl;            else cout&lt;&lt;1&lt;&lt;endl;        }        else{            if(n==2){                if(a[1]==a[2])cout&lt;&lt;0&lt;&lt;endl;//对称取                 else cout&lt;&lt;1&lt;&lt;endl;//Tom先手先让a[1]==a[2]，Tom对称取，Jerry必败，所以Jerry必须先手             }            else{                int sign1=0,sign2=0;                    if(cnt&gt;0&amp;&amp;cnt%2==0)sign1=0;//只含1个花生米的堆数为偶数                 else sign1=1;                if((n-cnt)%2==0)sign2=0;//含&gt;1个花生米的堆数为偶数                 else sign2=1;                 if(sign1&amp;&amp;sign2)cout&lt;&lt;1&lt;&lt;endl;//全奇数堆先手必胜，所以Jerry必须先手：比如1 1 1 3 3 3--&gt;1 3 3 3先手必胜 （后手无法赢）                 else cout&lt;&lt;0&lt;&lt;endl;//如果存在偶数堆，则让对手取成全奇，在此之前，Jerry保持非全奇                 //如果1 1 1 1 3 3 3 3 .如果先手选3，后手跟着选3，直到3用完，先手选择1，后手到达必胜态                //如果 先手选3中的2，--&gt;1 1 1 1 1 3 3 3 后手选 1--&gt;1 1 1 1 3 3 3,直到3用完，先手选择1，后手到达必胜态。                //同理1 1 1 3 3 3 3类型和1 1 1 1 3 3 3类型。                 //注意 7 3 3 3 3 3 3 3 这种类型即cnt==0，这个时候sign1=1，sign=1，就是指只存在奇数堆，先手必胜。             }        }    }    return 0;} /*73 3 3 3 3 3 3*///Jerry 后手必胜的条件：后手且吃掉最后的花生米，则Jerry无法后手胜利。</code></pre>        <div id="aplayer-QuhpkGpH" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-QuhpkGpH"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-花生米（三）</title>
    <link href="/2020/11/04/NOJ-%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/11/04/NOJ-%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="花生米（三）"><a href="#花生米（三）" class="headerlink" title="花生米（三）"></a>花生米（三）</h1><p><strong>描述</strong></p><p>五一长假第三天，Tom和Jerry在仓库散步的时候又发现了一堆花生米（仓库，又见仓库……）。这次Tom制定分花生米规则如下：<br>1、Tom和Jerry轮流从堆中取出k粒花生米吃掉；<br>2、第一次取花生米的人只能取一粒，以后取花生米的数量不能超过前一个人取花生米数量的两倍；<br>3、为显示规则的公平性，Jerry可以选择先取或者后取。<br>Jerry当然还是希望最后一粒花生米被Tom吃掉。请计算，Jerry为了达到目的应该先取还是后取。</p><p><strong>输入</strong></p><p>本题有多个测例，每个测例的输入是一个整数n，n大于零小于等于1000，代表花生米的数量。<br>n等于0表示输入结束，不需要处理。</p><p><strong>输出</strong></p><p>每个测例在单独的一行内输出一个整数：Jerry先取输出1；Tom先取输出0。</p><p><strong>输入样例</strong></p><p>1<br>2<br>3<br>4<br>5<br>0</p><p><strong>输出样例</strong></p><p>0<br>1<br>0<br>0<br>1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题与<strong>花生米（二）</strong><a href="https://blog.csdn.net/Phoenix_ZengHao/article/details/109495057" target="_blank" rel="noopener">https://blog.csdn.net/Phoenix_ZengHao/article/details/109495057</a>  相比，状态变多了。之前对于状态i，它只能由状态i-1，i-5，i-10进行推导。显然直接枚举状态并且对每一个状态做三个dp转移方程是行不通的。我们需要把所有的状态都枚举一次。但是又不确定到底可以取多少颗。假设在这之前的人拿了i颗花生米。那么当前这个人可以拿1~min（res，2 * i）。如果要让当前状态都是必胜态，必须保证下一次的所有状态都是必胜态，换言之后手当前状态必须是必胜态，那么对于先手在下一次的时候必须是必败态。</p><p>定义dfs(int res,int c)当前dfs的状态是花生米剩余res，上一次的人拿了c颗花生米。dp[res][c]同理。记录dp[res][c]是为了进行记忆化搜索，这样的时间复杂度也是O(n^2)，在思路上比直接动态规划简单，并且时间复杂度也是相当的。dp[][]初始化为-1，dfs的时候一旦dp[res][c]！=-1说明这个状态已经遍历过了，直接返回答案即可。如果dfs到res==1的时候说明后手必胜，定义dp[res][c]=0表示这个状态下后手必胜。如果没有答案这个状态，就需要枚举它推导出的所有状态，拿i个的情况（i from 1 to min(res,c)），这样枚举到的是从后手转到了先手，要想后手必胜，必须保证先手所有的状态都是必败。所以定义sign=1，sign&amp;所有的dfs的结果，一旦sign=0，那么后手就无法必胜。如果最后sign=1，那么后手就是必胜。</p><p> dp[i][j]==0：Jerry后手且此时剩余i个而对手在上一轮中取j个并且是必胜态。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,dp[maxn][maxn];int min(int x,int y){    if(x&lt;=y)return x;    return y;}int dfs(int res,int c){    int i;    if(res==1){        dp[res][c]=0;        return 0;    }    if(dp[res][c]!=-1)return dp[res][c];    int sign=1;    for(i=1;i&lt;=2*c;i++){        if(i&gt;res)break;        sign=sign&amp;dfs(res-i,i);//下一个dfs就是Jerry先手的状态了，必须全部为1，才能使得当前dfs中的为后手必胜         if(sign==0)break;    }    dp[res][c]=0;    if(sign==0)    dp[res][c]=1;    return dp[res][c];}int main(){    int i,j;    while(1){        cin&gt;&gt;n;        if(n==1){            cout&lt;&lt;0&lt;&lt;endl;            continue;        }        if(n==0)break;        for(i=0;i&lt;=1000;i++){            for(j=0;j&lt;=1000;j++){                dp[i][j]=-1;            }        }        cout&lt;&lt;1-dfs(n-1,1)&lt;&lt;endl;    }}</code></pre>        <div id="aplayer-gFpvXulY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-gFpvXulY"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-花生米（二）</title>
    <link href="/2020/11/04/NOJ-%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/11/04/NOJ-%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="花生米（二）"><a href="#花生米（二）" class="headerlink" title="花生米（二）"></a>花生米（二）</h1><p><strong>描述</strong></p><p>五一长假第二天，Tom和Jerry在仓库散步的时候又发现了一堆花生米（这个仓库还真奇怪）。这次Tom制定分花生米规则如下：<br>    1、Tom和Jerry轮流从堆中取出k粒花生米吃掉，k可以是1，5，10中的任意一个数字；<br>    2、为显示规则的公平性，Jerry可以选择先取或者后取。<br>Jerry当然还是希望最后一粒花生米被Tom吃掉。请计算，Jerry为了达到目的应该先取还是后取。</p><p><strong>输入</strong></p><p>本题有多个测例，每个测例的输入是一个整数n，n大于零小于等于1000，代表花生米的数量。<br>n等于0表示输入结束，不需要处理。</p><p><strong>输出</strong></p><p>每个测例在单独的一行内输出一个整数：Jerry先取输出1；Tom先取输出0。</p><p><strong>输入样例</strong></p><p>1<br>2<br>3<br>4<br>0</p><p><strong>输出样例</strong></p><p>0<br>1<br>0<br>1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>博弈论：<br>定义： jerry后手胜利 为必胜态。（即：Tom拿了最后一颗并且初始Jerry后手）<br>10以内的必胜状态：1,3,5,7,9.<br>由于可以一次拿10个，我们需要考虑10周围的情况:11为必胜 。<br>什么才是必败态？<br>当前面i-1,i-5,i-10这10个状态都是必胜态的时候， i一定是必败态。<br>否则 i就有机会成为必胜态。必胜状态推导出的下一个状态必然是必败态。而一个状态i作为必胜态，必须保证它的可以推导到状态全部都是必败态，否则的话Tom作为先手就一定会使得Jerry在到达该状态i的上一个状态的时候迫使他走必败态的状态，当Jerry到达i状态的时候就变成必败态了。<br>dp[i]=1表示i是必胜态。 最后看dp[n] 的值来判断Jerry是后手必胜还是先手必胜。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,dp[maxn];int main(){    dp[1]=1;dp[3]=1;dp[5]=1;dp[7]=1;dp[9]=1;dp[11]=1;    for(int i=12;i&lt;=1000;i++){        if(dp[i-1]&amp;&amp;dp[i-5]&amp;&amp;dp[i-10])dp[i]=0;        else dp[i]=1;    }    while(1){        cin&gt;&gt;n;        if(n==0)break;        if(dp[n])cout&lt;&lt;0&lt;&lt;endl;        else cout&lt;&lt;1&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-OVFNkmpY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-OVFNkmpY"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-旅游预算</title>
    <link href="/2020/11/04/NOJ-%E6%97%85%E6%B8%B8%E9%A2%84%E7%AE%97/"/>
    <url>/2020/11/04/NOJ-%E6%97%85%E6%B8%B8%E9%A2%84%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="旅游预算"><a href="#旅游预算" class="headerlink" title="旅游预算"></a>旅游预算</h1><p><strong>描述</strong></p><p>一个旅行社需要估算乘汽车从某城市到另一城市的最小费用，沿路有若干加油站，每个加油站收费不一定相同。旅游预算有如下规则： 若油箱的油过半，不停车加油，除非油箱中的油不可支持到下一站；每次加油时都加满；在一个加油站加油时，司机要花费2元买东西吃；司机不必为其他意外情况而准备额外的油；汽车开出时在起点加满油箱；计算精确到分（1元=100分）。编写程序估计实际行驶在某路线所需的最小费用。</p><p><strong>输入</strong></p><p>第一行为起点到终点的距离（实数） 第二行为三个实数，后跟一个整数，每两个数据间用一个空格隔开。其中第一个数为汽车油箱的容量（升），第二个数是每升汽油行驶的公里数，第三个数是在起点加满油箱的费用（精确到分），第四个数是加油站的数量。（〈=50）。接下去的每行包括两个实数，每个数据之间用一个空格分隔，其中第一个数是该加油站离起点的距离，第二个数是该加油站每升汽油的价格（元/升）。加油站按它们与起点的距离升序排列。所有的输入都有一定有解。</p><p><strong>输出</strong></p><p>共两行，每行都有换行 第一行为一个实数和一个整数，实数为旅行的最小费用，以元为单位，精确到分，整数表示途中加油的站的N。第二行是N个整数，表示N个加油的站的编号，按升序排列。数据间用一个空格分隔，最后一个数据后也输出空格，此外没有多余的空格。</p><p><strong>输入样例</strong></p><p>516.3 15.7 22.1 20.87 3 125.4 1.259 297.9 1.129 345.2 0.999</p><p><strong>输出样例</strong></p><p>38.09 1 </p><p>2</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由题意可知：如果在第i个加油站要加油，必须保证到达第i+1个加油站的时候油箱的油少于一半。并且一旦加油，油箱的油就加满了。dp[i]表示到达第i个加油站的最小耗费，初始化为1e9(无穷大)。dp[0]： 起点加满油箱的费用 。a[i].d表示第i个加油站距离起点的距离，a[i].w表示第i个加油站加油的单价费用。枚举当前到达的加油站i(i from 1 to n),然后再枚举上一次加油的加油站j(j from 0 to i-1，0就是起点)。if(a[i].d-a[j].d&gt;road||(a[i].d-a[j].d) <em> 2&lt;road)如果无法从j到达i或者从j到达i油箱油量过半都无法考虑，其余的情况dp[i]=min(dp[i],dp[j]+ned </em> a[i].w+2)，因为最后答案要输出在哪些加油站加了油，所以需要记录上一次加油的加油站pre[i]=j;最后再看从哪个加油站i到终点代价最小（i from 0 to n），<strong>必须保证油量可以从i到终点</strong>，ans为最终答案，ans=min(ans,dp[i]),并且记录最后一个加油站last。由last为终点前的加油站，进行回溯查询加过油的加油站。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;struct Node{    double w,d;}a[maxn]; double s,v,p,dp[maxn];int n,pre[maxn],t[maxn];double min(double x,double y){    if(x&lt;=y)return x;    return y;}int main(){    int i,j;    cin&gt;&gt;s&gt;&gt;v&gt;&gt;p&gt;&gt;dp[0]&gt;&gt;n;    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i].d&gt;&gt;a[i].w,dp[i]=1e9;    double road=v*p;    for(i=1;i&lt;=n;i++){        for(j=0;j&lt;=i-1;j++){            if(a[i].d-a[j].d&gt;road||(a[i].d-a[j].d)*2&lt;road)continue;//注意油量超过一半并且可以到达下一个点不加油！             double ned=(a[i].d-a[j].d)/p;            if(dp[i]&gt;dp[j]+ned*a[i].w+2){                dp[i]=dp[j]+ned*a[i].w+2;                pre[i]=j;            }        }    }    double ans=0x3f3f3f3f;int last=0,tot=0;    for(i=0;i&lt;=n;i++){        if(road&lt;s-a[i].d)continue;        if(ans&gt;dp[i]){            ans=dp[i];            last=i;        }    }    while(last!=0){        t[++tot]=last;        last=pre[last];    }    printf(&quot;%.2lf %d\n&quot;,ans,tot);    for(i=tot;i&gt;=1;i--)cout&lt;&lt;t[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-JCNfwsPf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-JCNfwsPf"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-石子合并</title>
    <link href="/2020/11/04/NOJ-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
    <url>/2020/11/04/NOJ-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h1><p><strong>描述</strong></p><p>在一个圆形操场的四周摆放着n堆石子(n&lt;= 100)，现要将石子有次序地合并成一堆。规定每次只能选取相邻的两堆合并成新的一堆,并将新的一堆的石子数,记为该次合并的得分。编一程序，读入石子堆数n及每堆的石子数(&lt;=20)。选择一种合并石子的方案,使得做n－1次合并,得分的总和最小； 比如有4堆石子：4 4 5 9 则最佳合并方案如下：<br>4 4 5 9 score: 0<br>8 5 9 score: 8<br>13 9 score: 8 + 13 = 21<br>22 score: 8 + 13 + 22 = 43</p><p><strong>输入</strong></p><p>可能有多组测试数据。 当输入n=0时结束! 第一行为石子堆数n(1&lt;=n&lt;=100)； 第二行为n堆的石子每堆的石子数,每两个数之间用一个空格分隔。</p><p><strong>输出</strong></p><p>合并的最小得分，每个结果一行。</p><p><strong>输入样例</strong></p><p>4 4 4 5 9 0</p><p><strong>输出样例</strong></p><p>43</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始以为这个题和合并果子一样是个贪心的题，拿着优先队列就开始一波贪心，WA了。才发现是合并相邻的石子。那这个题就和上一个<strong>计算矩阵连乘积</strong>的题几乎一样了。但是也有不一样的。这个题的序列是循环序列，并且为了记录每一次合并对答案的贡献我们还需要记录前缀和（这里求前缀和是为了优化时间复杂度，不求前缀和的话每次求贡献需要O(n)），由于这是<strong>循环数列</strong>，求前缀和时候需要求前2 <em> n的。数列大小是2 </em> n（a[1],a[2],…,a[n],a[1],a[2],…a[n]）.设sum[i]为数组a[i]前i个的和，那么要求l-r之间a[]之和，就可以O(1) 求得，即sum[r]-sum[l-1]。设dp[i][j]为合并i-j之间所有石子的最小代价，初始化为0x3f3f3f3f（即无穷大），dp[i][i]=0(i from 1 to n即所有的单堆石子合并代价都是0)。枚举长度len(len from 2 to n)，嵌套枚举左边界l（l from 1 to n），那么有边界r=l+len-1，由此可以更新dp[l][r],为了求dp[l][r]，还需要考虑是哪两段石子进行了合并，所以需要枚举l-r之间的mid(l&lt;=mid&lt;=r-1)，这样合并石子区段l-mid和mid+1 - r 。dp[l][r]=min{dp[l][r],dp[l][mid]+dp[mid+1][r]+sum[r]-sum[l-1]};(每一次合并除了那两个区段合并的代价，还需要注意合并当前这两个区段的代价是区段石子的总和：sum[r]-sum[l-1]).</p><p>最后需要枚举一遍答案求得最优解：ans=min(ans,dp[i][i+len-1]);(i from 1 to n 需要找到合并的起点)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200+50;int a[maxn],n,dp[maxn][maxn],sum[maxn];int min(int x,int y){    if(x&lt;=y)return x;    return y;}int main(){    while(1){        int i;        cin&gt;&gt;n;        if(n==0)break;        memset(dp,0x3f3f3f3f,sizeof(dp));        for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i],dp[i][i]=dp[i+n][i+n]=0;        for(i=1;i&lt;=n;i++)sum[i+n]=sum[i+n-1]+a[i];         for(int len=2;len&lt;=n;len++){            for(int l=1;l&lt;=2*n-len+1;l++){                int r=l+len-1;                for(int m=l;m&lt;=r-1;m++){                    dp[l][r]=min(dp[l][r],dp[l][m]+dp[m+1][r]+sum[r]-sum[l-1]);                }            }        }//len从2到n 更新         int ans=0x3f3f3f3f;        for(i=1;i&lt;=n;i++){            ans=min(ans,dp[i][i+n-1]);        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-hSXpntyA" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-hSXpntyA"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-计算矩阵连乘积</title>
    <link href="/2020/11/04/NOJ-%E8%AE%A1%E7%AE%97%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E7%A7%AF/"/>
    <url>/2020/11/04/NOJ-%E8%AE%A1%E7%AE%97%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算矩阵连乘积"><a href="#计算矩阵连乘积" class="headerlink" title="计算矩阵连乘积"></a>计算矩阵连乘积</h1><p><strong>描述</strong></p><p>在科学计算中经常要计算矩阵的乘积。矩阵A和B可乘的条件是矩阵A的列数等于矩阵B的行数。若A是一个p×q的矩阵，B是一个q×r的矩阵，则其乘积C=AB是一个p×r的矩阵。计算C=AB总共需要p×q×r次乘法。<br>现在的问题是，给定n个矩阵{A1,A2,…,An}。其中Ai与Ai+1是可乘的，i=1,2,…,n-1。<br>要求计算出这n个矩阵的连乘积A1A2…An最少需要多少次乘法。</p><p><strong>输入</strong></p><p>输入数据的第一行是一个整树n（0 &lt; n &lt;= 10），表示矩阵的个数。<br>接下来的n行每行两个整数p,q( 0 &lt; p,q &lt; 100)，分别表示一个矩阵的行数和列数。</p><p><strong>输出</strong></p><p>输出一个整数：计算连乘积最少需要乘法的次数。</p><p><strong>输入样例</strong></p><p>10<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>6 7<br>7 8<br>8 9<br>9 10<br>10 11</p><p><strong>输出样例</strong></p><p>438</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设dp[i][j]表示合并第i个矩阵到第j个矩阵所需要的最少的乘法次数。初始化dp为0x3f3f3f3f（即初始化为无穷大）。dp[i][i]=0(所有的i-i的合并的乘法次数为0).然后就开始考虑动态规划的转移方程：先枚举长度len （len from 2 to n），合并的长度最短为2，最长为n。然后嵌套枚举左边界l（l from 1 to n），与此同时由len和l就可以得到r=l+len-1.于是就可以考虑dp[l][r] 的转移方程了，要求<strong>l-r</strong>的合并耗费的乘法次数，就要考虑中间枚举一个点mid，那么合并<strong>l-r</strong>的乘法次数就是合并<strong>l-mid</strong>与合并<strong>mid+1 - r</strong>的乘法次数之和再加上合并新的左右两个矩阵，它们的乘法次数是p[l] <em> q[m] </em> q[r]。枚举l，r之间的一个矩阵mid(l&lt;=mid&lt;=mid-1)，dp[l][r]=min(dp[l][r],dp[l][mid+dp[mid+1][r]+ p[l] <em> q[m] </em> q[r] ).最终答案就是dp[1][n];</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,p[maxn],q[maxn],dp[maxn][maxn];int min(int x,int y){    if(x&lt;=y)return x;    return y;}int main(){    cin&gt;&gt;n;    memset(dp,0x3f3f3f3f,sizeof(dp));    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;p[i]&gt;&gt;q[i];        dp[i][i]=0;    }    for(int len=2;len&lt;=n;len++){        for(int l=1;l&lt;=n;l++){            int r=l+len-1;            for(int m=l;m&lt;=r-1;m++){                dp[l][r]=min(dp[l][r],dp[l][m]+dp[m+1][r]+p[l]*q[m]*q[r]);            }        }    }    cout&lt;&lt;dp[1][n]&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-rrGXkXYx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-rrGXkXYx"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-防卫导弹</title>
    <link href="/2020/11/04/NOJ-%E9%98%B2%E5%8D%AB%E5%AF%BC%E5%BC%B9/"/>
    <url>/2020/11/04/NOJ-%E9%98%B2%E5%8D%AB%E5%AF%BC%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="防卫导弹"><a href="#防卫导弹" class="headerlink" title="防卫导弹"></a>防卫导弹</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>一种新型的防卫导弹可截击多个攻击导弹。它可以向前飞行，也可以用很快的速度向下飞行，可以毫无损伤地截击进攻导弹，但不可以向后或向上飞行。但有一个缺点，尽管它发射时可以达到任意高度，但它只能截击比它上次截击导弹时所处高度低或者高度相同的导弹。现对这种新型防卫导弹进行测试，在每一次测试中，发射一系列的测试导弹（这些导弹发射的间隔时间固定，飞行速度相同），该防卫导弹所能获得的信息包括各进攻导弹的高度，以及它们发射次序。现要求编一程序，求在每次测试中，该防卫导弹最多能截击的进攻导弹数量，一个导弹能被截击应满足下列两个条件之一：<br>a)它是该次测试中第一个被防卫导弹截击的导弹；<br>b)它是在上一次被截击导弹的发射后发射，且高度不大于上一次被截击导弹的高度的导弹。</p><p>输入</p><p>多个测例。<br>每个测例第一行是一个整数n（n不超过100），第二行n个整数表示导弹的高度（数字的顺序即发射的顺序）。<br>n＝0表示输入结束。</p><p>输出</p><p>每个测例在单独的一行内输出截击导弹的最大数目。</p><p>输入样例：</p><p>5<br>5 6 100 6 61<br>0</p><p>输出样例：</p><p>2</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>枚举每一个导弹i（i from 1 to n），这个导弹一定是由之前更高的导弹击中（设未击中导弹的时候，拦截导弹的高度为0x3f3f3f3f）枚举之前的所有导弹，一旦h[j]&gt;=h[i]，那么dp[i]=max{dp[i],dp[j]+1},当然被拦截的导弹i也可以作为第一个被拦截的导弹，dp[i]=1。最后在线性查找一遍最大的数量,ans=max{ans,dp[i]};</p><p>这个方法特别简单，不粘贴代码了。时间复杂度 O(n^2)。</p><p>这个复杂度不够优秀，下面就介绍O(nlogn)的做法。</p><p>先介绍一下<strong>lower_bound,upper_bound函数的使用方法</strong>。</p><p>lower_bound(dp+1,dp+1+n,h[i])dp[]中第一个&gt;=h[i]的下标<br>upper_bound(dp+1,dp+1+n,h[i])dp[]中第一个&gt;h[i]的下标<br>lower_bound(dp+1,dp+1+n,h[i],greater&lt; int &gt;())dp[]中第一个&lt;=h[i]的下标 greater&lt; int &gt;() == cmp(int x,int y){return x&gt;y}<br>upper_bound(dp+1,dp+1+n,h[i],greater&lt; int &gt;())dp[]中第一个&lt;h[i]的下标 </p><p>greater&lt; int &gt;()表示内置类型从大到小排序，比如说原序列是1，2，4，7，15，34，在greater&lt; int &gt;()的表示下，<br>1&gt;2&gt;4&gt;7&gt;15&gt;34,lower_bound(num,num+6,7,greater&lt; int &gt;()) 返回greater&lt; int &gt;序列下第一个大于或等于被查数7的值，<br>即4；也就是返回的是原序列的中第一个小于或等于被查数7的值 </p><p>下面介绍二分+动态规划来解决最长不上升子序列问题：</p><p>我们在O(n^2)的做法是将导弹i(1-n)之前的导弹j(1-i)都枚举一遍，然后更新dp[i]的值，但实际上根本没有必要将导弹j全部枚举一遍。我们定义一个dp[]数组，dp[]数组储存的是答案所求的最长的不上升子序列。那么我们对于导弹i，如果它要加入到dp[]中，那么就要找到dp[]数组中第一个小于h[i]的导弹，然后把它替换成h[i].（dp[]初始化为0），当已加入的导弹均高于当前导弹，就直接加入该导弹（无需替换）。</p><p>思考这样做的正确性：因为将dp[j]替换成了h[i]，此时dp[]依旧是非递增序列，并且保证dp[]相较于之前是更加优化的（因为它整体要更大了）。</p><p>如何查找这个最先小于h[i]的dp[j]呢？显然dp[]是非递增序列，所以可以考虑用二分查找。对于很多单调性问题，首先考虑单调栈、单调队列、二分。尤其是这种带查找的最优化问题很有可能用二分。二分查找到最先小于的h[i]的进行替换。并且如果h[i]是直接假如dp[]，记得更新dp[]数组的大小。最后的dp[]数组的大小就是答案。</p><p><strong>PS</strong>：那如果问题是问，最少需要几枚导弹呢？这就是最长上升序列问题了。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,h[maxn],dp[maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}int cmp(int x,int y){    return x&gt;y;}int main(){    int i;    while(1){        cin&gt;&gt;n;        if(n==0)break;        for(i=1;i&lt;=n;i++)cin&gt;&gt;h[i],dp[i]=0;        int ans=0;        for(i=1;i&lt;=n;i++){            int t=upper_bound(dp+1,dp+1+n,h[i],cmp)-dp;            dp[t]=h[i];            ans=max(ans,t);        }        cout&lt;&lt;ans&lt;&lt;endl;            }    return 0;}</code></pre>        <div id="aplayer-moojJvIt" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-moojJvIt"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-最长公共子序列</title>
    <link href="/2020/11/04/NOJ-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/11/04/NOJ-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>描述</p><p>一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=<x1, x2,…, xm>，则另一序列Z=<z1, z2,…, zk>是X的子序列是指存在一个严格递增的下标序列 <i1, i2,…, ik>，使得对于所有j=1,2,…,k有：<br>Xij ＝ Zj<br>如果一个序列S即是A的子序列又是B的子序列，则称S是A、B的公共子序列。<br>求A、B所有公共子序列中最长的序列的长度。</p><p>输入</p><p>输入共两行，每行一个由字母和数字组成的字符串，代表序列A、B。A、B的长度不超过200个字符。</p><p>输出</p><p>一个整数，表示最长各个子序列的长度。</p><p>格式：printf(“%d\n”);</p><p>输入样例</p><p>programming<br>contest</p><p>输出样例</p><p>2</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>像LCS这样的问题，它具有重叠子问题的性质，因此：用递归来求解就太不划算了。因为采用递归，它重复地求解了子问题。采用动态规划时，并不需要去一 一 计算那些重叠了的子问题 。对于<strong>dp[i][j]</strong>表示 <strong>(s1,s2….si) 和 (t1,t2…tj) 的最长公共子序列的长度</strong> 。</p><p>当i==0||j==0 时,dp[i][j]=0;</p><p>当i,j&gt;0,si==tj时,  dp[i][j]=dp[i-1][j-1]+1;</p><p>当i,j&gt;0,si!=tj时，dp[i][j]=max{dp[i][j-1],dp[i-1][j]};</p><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a><strong>时间复杂度：</strong></h3><p>由于只需要填一个m行n列的二维数组，其中m代表第一个字符串长度，n代表第二个字符串长度</p><p>所以时间复杂度为O（m*n）</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;char s[maxn],t[maxn];int lens,lent,dp[maxn][maxn];int max(int x,int y){    if(x&gt;y)return x;    return y;}int main(){    scanf(&quot;%s%s&quot;,s+1,t+1);    lens=strlen(s+1);    lent=strlen(t+1);    for(int i=1;i&lt;=lens;i++){        for(int j=1;j&lt;=lent;j++){            if(s[i]==t[j]){                dp[i][j]=dp[i-1][j-1]+1;            }            else{                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);            }        }    }    printf(&quot;%d\n&quot;,dp[lens][lent]);    return 0;}</code></pre>        <div id="aplayer-qWKtTyop" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-qWKtTyop"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-test4</title>
    <link href="/2020/11/02/NOJ-test4/"/>
    <url>/2020/11/02/NOJ-test4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先补作业，再补题解。（有缘补题解QAQ）</p><h1 id="A-最长公共子序列"><a href="#A-最长公共子序列" class="headerlink" title="A-最长公共子序列"></a>A-最长公共子序列</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;char s[maxn],t[maxn];int lens,lent,dp[maxn][maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}int main(){    cin&gt;&gt;s+1&gt;&gt;t+1;    lens=strlen(s+1);lent=strlen(t+1);    for(int i=1;i&lt;=lens;i++){        for(int j=1;j&lt;=lent;j++){            if(s[i]==t[j]){                dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);            }            else{                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);            }        }    }    cout&lt;&lt;dp[lens][lent]&lt;&lt;endl;    return 0;}</code></pre><h1 id="B-防卫导弹"><a href="#B-防卫导弹" class="headerlink" title="B-防卫导弹"></a>B-防卫导弹</h1><p>lower_bound(dp+1,dp+1+n,h[i])dp[]中第一个&gt;=h[i]的下标<br>upper_bound(dp+1,dp+1+n,h[i])dp[]中第一个&gt;h[i]的下标<br>lower_bound(dp+1,dp+1+n,h[i],greater&lt; int &gt;())dp[]中第一个&lt;=h[i]的下标 greater&lt; int &gt;() == cmp(int x,int y){return x&gt;y}<br>upper_bound(dp+1,dp+1+n,h[i],greater&lt; int &gt;())dp[]中第一个&lt;h[i]的下标 </p><p>greater&lt; int &gt;()表示内置类型从大到小排序，比如说原序列是1，2，4，7，15，34，在greater&lt; int &gt;()的表示下，<br>1&gt;2&gt;4&gt;7&gt;15&gt;34,lower_bound(num,num+6,7,greater&lt; int &gt;()) 返回greater&lt; int &gt;序列下第一个大于或等于被查数7的值，<br>即4；也就是返回的是原序列的中第一个小于或等于被查数7的值</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,h[maxn],dp[maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}int cmp(int x,int y){    return x&gt;y;}int main(){    int i;    while(1){        cin&gt;&gt;n;        if(n==0)break;        for(i=1;i&lt;=n;i++)cin&gt;&gt;h[i],dp[i]=0;        int ans=0;        for(i=1;i&lt;=n;i++){            int t=upper_bound(dp+1,dp+1+n,h[i],cmp)-dp;            dp[t]=h[i];            ans=max(ans,t);        }        cout&lt;&lt;ans&lt;&lt;endl;            }    return 0;}</code></pre><h1 id="C-田忌赛马-tian-ji-racing"><a href="#C-田忌赛马-tian-ji-racing" class="headerlink" title="C-田忌赛马(tian ji racing)"></a>C-田忌赛马(tian ji racing)</h1><p>如果田忌最快的马快于齐王最快的马，就PK<br>如果田忌最快的马慢于齐王最快的马：<br>    如果田忌最慢的马快于齐王的最慢的马，PK<br>    否则就田忌最慢的马PK齐王最快的马（反正都是输） </p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,a[maxn],b[maxn];int main(){    int i;    while(1){        cin&gt;&gt;n;        if(n==0)break;        for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        for(i=1;i&lt;=n;i++)cin&gt;&gt;b[i];        sort(a+1,a+1+n);sort(b+1,b+1+n);        int opt1=1,opt2=1,up1=n,up2=n,win=0,lose=0;        while(up1&gt;=opt1){            if(a[up1]&gt;b[up2])win++,up1--,up2--;            else {                if(a[opt1]&gt;b[opt2])win++,opt1++,opt2++;                else if(a[opt1]&lt;b[up2])lose--,opt1++,up2--;                else opt1++,up2--;            }        }    //    cout&lt;&lt;win&lt;&lt;&#39; &#39;&lt;&lt;lose&lt;&lt;endl;        cout&lt;&lt;win+lose&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-计算矩阵连乘积"><a href="#D-计算矩阵连乘积" class="headerlink" title="D-计算矩阵连乘积"></a>D-计算矩阵连乘积</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,p[maxn],q[maxn],dp[maxn][maxn];int min(int x,int y){    if(x&lt;=y)return x;    return y;}int main(){    cin&gt;&gt;n;    memset(dp,0x3f3f3f3f,sizeof(dp));    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;p[i]&gt;&gt;q[i];        dp[i][i]=0;    }    for(int len=2;len&lt;=n;len++){        for(int l=1;l&lt;=n;l++){            int r=l+len-1;            for(int m=l;m&lt;=r-1;m++){                dp[l][r]=min(dp[l][r],dp[l][m]+dp[m+1][r]+p[l]*q[m]*q[r]);            }        }    }    cout&lt;&lt;dp[1][n]&lt;&lt;endl;    return 0;}</code></pre><h1 id="E-石子合并"><a href="#E-石子合并" class="headerlink" title="E-石子合并"></a>E-石子合并</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200+50;int a[maxn],n,dp[maxn][maxn],sum[maxn];int min(int x,int y){    if(x&lt;=y)return x;    return y;}int main(){    while(1){        int i;        cin&gt;&gt;n;        if(n==0)break;        memset(dp,0x3f3f3f3f,sizeof(dp));        for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i],dp[i][i]=dp[i+n][i+n]=0;        for(i=1;i&lt;=n;i++)sum[i+n]=sum[i+n-1]+a[i];         for(int len=2;len&lt;=n;len++){            for(int l=1;l&lt;=2*n-len+1;l++){                int r=l+len-1;                for(int m=l;m&lt;=r-1;m++){                    dp[l][r]=min(dp[l][r],dp[l][m]+dp[m+1][r]+sum[r]-sum[l-1]);                }            }        }//len从2到n 更新         int ans=0x3f3f3f3f;        for(i=1;i&lt;=n;i++){            ans=min(ans,dp[i][i+n-1]);        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="F-旅游预算"><a href="#F-旅游预算" class="headerlink" title="F-旅游预算"></a>F-旅游预算</h1><p><strong>ps：</strong>注意油量超过一半并且可以到达下一个点不加油！ </p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;struct Node{    double w,d;}a[maxn]; double s,v,p,dp[maxn];int n,pre[maxn],t[maxn];double min(double x,double y){    if(x&lt;=y)return x;    return y;}int main(){    int i,j;    cin&gt;&gt;s&gt;&gt;v&gt;&gt;p&gt;&gt;dp[0]&gt;&gt;n;    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i].d&gt;&gt;a[i].w,dp[i]=1e9;    double road=v*p;    for(i=1;i&lt;=n;i++){        for(j=0;j&lt;=i-1;j++){            if(a[i].d-a[j].d&gt;road||(a[i].d-a[j].d)*2&lt;road)continue;//注意油量超过一半并且可以到达下一个点不加油！             double ned=(a[i].d-a[j].d)/p;            if(dp[i]&gt;dp[j]+ned*a[i].w+2){                dp[i]=dp[j]+ned*a[i].w+2;                pre[i]=j;            }        }    }    double ans=0x3f3f3f3f;int last=0,tot=0;    for(i=0;i&lt;=n;i++){        if(road&lt;s-a[i].d)continue;        if(ans&gt;dp[i]){            ans=dp[i];            last=i;        }    }    while(last!=0){        t[++tot]=last;        last=pre[last];    }    printf(&quot;%.2lf %d\n&quot;,ans,tot);    for(i=tot;i&gt;=1;i--)cout&lt;&lt;t[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;    return 0;}</code></pre><h1 id="G-花生米（二）"><a href="#G-花生米（二）" class="headerlink" title="G-花生米（二）"></a>G-花生米（二）</h1><p>博弈论：<br>定义： jerry后手胜利 为必胜态。<br>10以内的必胜状态：1,3,5,7,9.<br>由于可以一次拿10个，我们需要考虑10周围的情况:11为必胜 。<br>什么才是必败态？<br>当前面i-1,i-5,i-10这10个状态都是必胜态的时候， i一定是必败态。<br>否则 i就有机会成为必胜态。<br>dp[i]=1表示i是必胜态。 </p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,dp[maxn];int main(){    dp[1]=1;dp[3]=1;dp[5]=1;dp[7]=1;dp[9]=1;dp[11]=1;    for(int i=12;i&lt;=1000;i++){        if(dp[i-1]&amp;&amp;dp[i-5]&amp;&amp;dp[i-10])dp[i]=0;        else dp[i]=1;    }    while(1){        cin&gt;&gt;n;        if(n==0)break;        if(dp[n])cout&lt;&lt;0&lt;&lt;endl;        else cout&lt;&lt;1&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="H-花生米（三）"><a href="#H-花生米（三）" class="headerlink" title="H-花生米（三）"></a>H-花生米（三）</h1><p>dp[i][j]==0：Jerry后手且此时剩余i个当前可取j个并且是必胜态 </p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,dp[maxn][maxn];int min(int x,int y){    if(x&lt;=y)return x;    return y;}int dfs(int res,int c){    int i;    if(res==1){        dp[res][c]=0;        return 0;    }    else if(dp[res][c]!=-1)return dp[res][c];    int sign=1;    for(i=1;i&lt;=min(res,c);i++){        sign=sign&amp;dfs(res-i,2*i);//下一个dfs就是Jerry先手的状态了，必须全部为1，才能使得当前dfs中的为后手必胜         if(sign==0)break;    }    dp[res][c]=0;    if(sign==0)    dp[res][c]=1;    return dp[res][c];}int main(){    int i,j;    while(1){        cin&gt;&gt;n;        if(n==0)break;        for(i=0;i&lt;=1000;i++){            for(j=0;j&lt;=1000;j++){                dp[i][j]=-1;            }        }        cout&lt;&lt;dfs(n,1)&lt;&lt;endl;    }}</code></pre><h1 id="I-花生米（四）"><a href="#I-花生米（四）" class="headerlink" title="I-花生米（四）"></a>I-花生米（四）</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;int n,a[maxn];int main(){    while(1){        cin&gt;&gt;n;        if(n==0)break;        int sum=0,cnt=0,tot=0;         for(int i=1;i&lt;=n;i++){            cin&gt;&gt;a[i],sum+=a[i];            if(a[i]==1)cnt++;        }        if(n==1){            cout&lt;&lt;0&lt;&lt;endl;        }        else if(cnt==n){            if(n%2==0)cout&lt;&lt;0&lt;&lt;endl;            else cout&lt;&lt;1&lt;&lt;endl;        }        else{            if(n==2){                if(a[1]==a[2])cout&lt;&lt;0&lt;&lt;endl;//对称取                 else cout&lt;&lt;1&lt;&lt;endl;//Tom先手先让a[1]==a[2]，Tom对称取，Jerry必败，所以Jerry必须先手             }            else{                int sign1=0,sign2=0;                    if(cnt&gt;0&amp;&amp;cnt%2==0)sign1=0;//只含1个花生米的堆数为偶数                 else sign1=1;                if((n-cnt)%2==0)sign2=0;//含&gt;1个花生米的堆数为偶数                 else sign2=1;                 if(sign1&amp;&amp;sign2)cout&lt;&lt;1&lt;&lt;endl;//全奇数堆先手必胜，所以Jerry必须先手：比如1 1 1 3 3 3--&gt;1 3 3 3先手必胜 （后手无法赢）                 else cout&lt;&lt;0&lt;&lt;endl;//如果存在偶数堆，则让对手取成全奇，在此之前，Jerry保持非全奇                 //如果1 1 1 1 3 3 3 3 .如果先手选3，后手跟着选3，直到3用完，先手选择1，后手到达必胜态                //如果 先手选3中的2，--&gt;1 1 1 1 1 3 3 3 后手选 1--&gt;1 1 1 1 3 3 3,直到3用完，先手选择1，后手到达必胜态。                //同理1 1 1 3 3 3 3类型和1 1 1 1 3 3 3类型。                 //注意 7 3 3 3 3 3 3 3 这种类型即cnt==0，这个时候sign1=1，sign2=1，就是指只存在奇数堆，先手必胜。             }        }    }    return 0;} /*73 3 3 3 3 3 3*///Jerry 后手必胜的条件：后手且吃掉最后的花生米，则Jerry无法后手胜利。</code></pre><h1 id="J-花生米（五）"><a href="#J-花生米（五）" class="headerlink" title="J-花生米（五）"></a>J-花生米（五）</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+50;int dp[maxn];int dfs(int res,int c){    int i;    if(res&lt;c){        dp[res]=0;        return dp[res];    }    if(dp[res]!=-1)return dp[res];    int sign=1;    for(i=c;i&lt;=3*c;i++){        if(res&lt;i)break;        sign&amp;=dfs(res-i,c+i);        if(sign==0)break;    }    dp[res]=0;    if(!sign)dp[res]=1;    return dp[res];}int main(){    int tot=0;    while(1){        int i;        double x;        cin&gt;&gt;x;        if(x&lt;0)break;        for(i=0;i&lt;=x*10;i++){            dp[i]=-1;        }        int w=x*10;        cout&lt;&lt;1-dfs(w-10,10)&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="K-装盘子"><a href="#K-装盘子" class="headerlink" title="K-装盘子"></a>K-装盘子</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+50;int n,m,dp[maxn][maxn];int dfs(int resn,int resm){    if(resn==1||resm==1||resm==0)return 1;    if(dp[resn][resm])return dp[resn][resm];    int ans=0;    if(resm&lt;resn)ans=dfs(resm,resm);    else ans=dfs(resn-1,resm)+dfs(resn,resm-resn);    dp[resn][resm]=ans;    return ans;}int main(){    cin&gt;&gt;m&gt;&gt;n;    cout&lt;&lt;dfs(n,m)&lt;&lt;endl;    return 0;}</code></pre><h1 id="L-滑雪"><a href="#L-滑雪" class="headerlink" title="L-滑雪"></a>L-滑雪</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200+50;int n,m,h[maxn][maxn],dp[maxn][maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};int dfs(int x,int y){    if(dp[x][y])return dp[x][y];    dp[x][y]=1;    int sign=0,ans=0,i;    for(i=0;i&lt;4;i++){        int nexx=x+d[i][0],nexy=y+d[i][1];        if(nexx&gt;=1&amp;&amp;nexx&lt;=n&amp;&amp;nexy&gt;=1&amp;&amp;nexy&lt;=m&amp;&amp;h[nexx][nexy]&gt;h[x][y])sign++,ans=max(ans,dfs(nexx,nexy)+1);    }    if(!sign)dp[x][y]=1;    else dp[x][y]=ans;    return dp[x][y];}int main(){    cin&gt;&gt;n&gt;&gt;m;    int i,j,k,maxx=0;    for(i=1;i&lt;=n;i++){        for(j=1;j&lt;=m;j++){            cin&gt;&gt;h[i][j];        }    }    int ans=0;    for(i=1;i&lt;=n;i++){        for(j=1;j&lt;=m;j++){            ans=max(ans,dfs(i,j));        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="I’-最大连续子序列和问题"><a href="#I’-最大连续子序列和问题" class="headerlink" title="I’-最大连续子序列和问题"></a>I’-最大连续子序列和问题</h1><p><strong>描述</strong>：</p><p>给定一整数序列A0，A1， A2，… An-1 （可能有负数），求A0~An-1的一个连续子序列Ai~Aj，使得Ai到Aj的和最大。</p><p><strong>输入</strong>：</p><p>先输入一个正整数n(1&lt;n&lt;1000)，再输入n个整数。</p><p><strong>输出</strong>：</p><p>输出最大连续子序列的和。</p><p><strong>输入样例</strong>：</p><pre><code>102 -1 5 -7 2 -1 4 -2 4 -5</code></pre><p><strong>输出样例</strong>：</p><pre><code>7</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>代码还没有AC，NOJ评测机炸了，但是这个O(n)的思路大概是对的：sum[i]为前i个数字的连续子序列的最大和。如果sum[i-1]<0，那对于sum[i]就没必要加上前i-1的总和了，因为这样对答案的贡献还不如0.如果sum[i-1]>0,则sum[i]=sum[i-1]+a[i].ans=max(ans,sum[i]);</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+50;int n,a[maxn],sum[maxn];int max(int x,int y){    if(x&gt;=y)return x;    return y;}int main(){    int i;    cin&gt;&gt;n;    for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    int ans=0;    for(i=1;i&lt;=n;i++){        if(sum[i-1]&gt;0)sum[i]=sum[i-1]+a[i];        else sum[i]=a[i];        ans=max(ans,sum[i]);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="J’-0-1背包问题"><a href="#J’-0-1背包问题" class="headerlink" title="J’-0-1背包问题"></a>J’-0-1背包问题</h1><p><strong>描述：</strong></p><p>一个背包容量为c ，现有n件物品，求能装入背包的最大重量是多少？</p><p><strong>输入：</strong></p><p>先输入两个正整数n、c（0&lt;n、c&lt;1000），表示物品的件数和背包容量，再输入n个正整数，分别是这n件物品的重量。</p><p><strong>输出：</strong></p><p>输出能装入背包的最大重量。</p><p><strong>输入样例：</strong></p><pre><code>5 5023 18 13 35 24</code></pre><p><strong>输出样例：</strong></p><pre><code>48</code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>0-1背包的裸题，那就可以直接写一个01背包的动态转移方程：dp[j]=max(dp[j],dp[j-w[i]]+p[i])。dp[j]的意思是：当背包已装j的重量的物品时的最大价值。那么它可以由背包已装j-w[i]时最大的价值进行转移，即由dp[j-w[i]]+p[i]得到。注意每一次要将dp[]设置为0，因为背包此时无价值。当状态方程枚举结束后，我们再从 dp[]数组中找一遍，求得答案maxx=max{dp[i]}(i from 0 to c)，输出答案maxx。这种动态规划的方法的时间复杂度为O(n^2).</p><p><strong>ps：</strong>0-1背包也可以写成二维dp[][]，只是这样写成滚动数组可以更加节省空间。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>除了直接写0-1背包的动态转移方程，还可以直接写dfs，每一个背包无非就是取和不取两个状态，如果要取则要求背包容量 res&gt;=w[now]。分别用ans1，ans2表示取当前物品，不取当前物品的最大价值，dfs返回max(ans1,ans2)，dfs的终止条件是now ==n+1。时间复杂度(2^n)。</p><p><strong>ps:</strong>方法二相较于方法一思维上更加简单，容易想到，但是代码就相对麻烦，并且时间复杂度不够优秀，当然如果加上记忆化搜索后时间复杂度和动态规划是相当的。我个人更喜欢方法一。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=    2000+50;int n,c,w[maxn],dp[maxn],p[maxn];int main(){    int i,j;    scanf(&quot;%d%d&quot;,&amp;n,&amp;c);    for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i],p[i]=w[i];    for(i=1;i&lt;=n;i++){        for(j=c;j&gt;=1;j--){            if(j-w[i]&gt;=0&amp;&amp;dp[j]&lt;dp[j-w[i]]+p[i]){                dp[j]=dp[j-w[i]]+p[i];            }        }    }    int maxx=0;    for(i=0;i&lt;=c;i++)        if(maxx&lt;dp[i])            maxx=dp[i];    cout&lt;&lt;maxx&lt;&lt;endl;    return 0;}</code></pre><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=    2000+50;int n,c,w[maxn],p[maxn];int dfs(int now,int res){    if(now==n+1)return 0;    int ans1=0,ans2=0;    if(res&gt;=w[now]){        ans1=dfs(now+1,res-w[now])+p[now];    }    ans2=dfs(now+1,res);    if(ans1&gt;=ans2)return ans1;    return ans2;}int main(){    int i,j;    scanf(&quot;%d%d&quot;,&amp;n,&amp;c);    for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i],p[i]=w[i];    cout&lt;&lt;dfs(1,c)&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-IOqZYszV" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-IOqZYszV"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1444</title>
    <link href="/2020/11/01/CodeForces-1444/"/>
    <url>/2020/11/01/CodeForces-1444/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-Division"><a href="#C-Division" class="headerlink" title="C. Division"></a>C. Division</h1><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>T组数据，每组给出pi和qi，其中 1≤pi≤10^18, 2≤qi≤10^9,求出最大的xi使得pi%xi==0，xi%qi!=0.</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>假设y=p/x，存在质数a，使得y%a==0&amp;&amp;a%q!=0,那么p%(a <em> x)==0&amp;&amp;(a </em> x)%q!=0</p><p>如果存在两个质数a和b，如果y%a==0&amp;&amp;y%b==0并且q%a==0&amp;&amp;q%b==0.因为x%q!=0，所以存在一个质数c（c可以等于a或者b），并且c在x中出现的次方数小于c在q中出现的次方数。a或b中的一个不等于c，因此将x‘=x * c，那么x‘%q!=0，因此答案要求的最大x不可能是a或者b。</p><p>所以x=p/（q中某个因数的幂次）。所以枚举q的所有因数，时间复杂度sqrt(q),注意因数一大一小对应枚举。然后设t=p，如果t%q==0，则t/=枚举的因数，直到t%q!=0，ans=max{t}.</p><p>以上是p%q==0的情况。</p><p>如果p%q！=0，显然答案就是p本身。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T, a, b;ll Div(ll x){    if(x==1)        return 1;    ll t = a;    while(t%b==0)        t /= x;    return t;}int main(){    cin &gt;&gt; T;    while(T--){        cin &gt;&gt; a &gt;&gt; b;        if(a%b==0){            ll ans = 1;            for (ll i = 1; i &lt;= sqrt(b);i++){                if(b%i)                    continue;                ans = max(ans, Div(i));                ans = max(ans, Div(b / i));            }            cout &lt;&lt; ans &lt;&lt; endl;        }        else{            cout &lt;&lt; a &lt;&lt; endl;        }    }    return 0;}</code></pre>        <div id="aplayer-GlTnyWrg" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-GlTnyWrg"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-算法设计理论作业</title>
    <link href="/2020/10/29/NOJ-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/"/>
    <url>/2020/10/29/NOJ-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h1><p>描述</p><p>给定一个单调递增的整数序列，问某个整数是否在序列中。</p><p>输入</p><p>第一行为一个整数n，表示序列中整数的个数；第二行为n（n不超过10000）个整数；第三行为一个整数m（m不超过50000），表示查询的个数；接下来m行每行一个整数k。</p><p>输出</p><p>每个查询的输出占一行，如果k在序列中，输出Yes，否则输出No。</p><p>输入样例</p><p>5<br>1 3 4 7 11<br>3<br>3<br>6<br>9</p><p>输出样例</p><p>Yes<br>No<br>No</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>按照题目要求进行二分查找，由于a[]是单增数列，所以对于每一个输入查询x，我们先设置左边界l=1，有边界r=n，ans储存可能的位置，进行二分查找，每一次二分查找时mid=(l+r)/2。如果a[mid]&gt;=x，说明如果存在x，那么x一定在左边界（包括mid），那么此时r=mid-1，ans=mid；如果a[mid]&lt;x，则说明x一定在有边界。二分查找完之后，要验证a[ans]是否等于x，因为二分只是由于它是有序序列进行二分，不断查找与x最接近的数字，但它不一定能够是x。</p><p>这个方法时间复杂度为O(nlogn).</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=50000+50;int n,a[maxn],m;int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    cin&gt;&gt;m;    while(m--){        int x;        cin&gt;&gt;x;        int l=1,r=n,ans=0;        while(l&lt;=r){            int mid=(l+r)/2;            if(a[mid]&gt;=x){                r=mid-1;                ans=mid;            }            else{                l=mid+1;            }        }        if(a[ans]==x){            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        }        else{            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603882322650.png" alt="1603882322650"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603882299481.png" alt="1603882299481"></p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>题目要求很明确，就是问x是否在a[]中存在，那就把a[]中出现过的数字进行标记就可以了，这里对 a[]中的每一个数字的范围解释不够清楚，所以我们可以用map进行映射处理。当然其实也可以vis[]数组进行标记，vis[]大小设置为5e5，这样让vis[a[i]]=1,然后查询vis[x]是否等于1就可以了，或者用map标记方法也一样。这种方法的时间复杂度O(n)(直接数组标记)或者O(nlogn)(map)。</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt; using namespace std;const int maxn=50000+50;map&lt;int,int&gt;mp;int n,a[maxn],m;int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],mp[a[i]]=1;    cin&gt;&gt;m;    while(m--){        int x;        cin&gt;&gt;x;        if(mp[x]==1){            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        }        else{            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        }    }}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603882725484.png" alt="1603882725484"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603882683549.png" alt="1603882683549"></p><h1 id="2-求解投骰子游戏问题"><a href="#2-求解投骰子游戏问题" class="headerlink" title="2.求解投骰子游戏问题"></a>2.求解投骰子游戏问题</h1><p><strong>[问题描述]</strong>玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。求玩家走到第n步（n≤骰子最大点数且投骰子方法唯一）时总共有多少种投骰子的方法。</p><p>输入描述：输入包括一个整数n（1≤n≤6）。</p><p>输出描述：输出一个整数，表示投骰子的方法数。</p><p>输入样例：6</p><p>输出样例：32</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h4><p>看到这个题的第一个思路是用递推/动态规划。很容易看出来对于状态i（当前走到第i步）可以由状态0，1，……,i-1得到（即走i步，走i-1步，……,走1步），设dp[0]=1（即处于原始位置的方式只有一种），那么dp[i]=dp[i-1]+dp[i-2]+…+dp[0].所以n^2枚举即可，当然为了时候的优化，我们还可以进行<strong>前缀和优化</strong>（即每一次得到dp[i-1]都在pre之中，对于dp[i+1]我们就可以O(1)求得），当然这里n&lt;=6，就不必这么复杂了。所以写了一个时间复杂度为O(n^2)的代码。</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20;int n,dp[maxn];int main(){    cin&gt;&gt;n;    dp[0]=1;    for(int i=1;i&lt;=n;i++){        for(int j=0;j&lt;=i-1;j++){            dp[i]+=dp[j];        }    }    cout&lt;&lt;dp[n]&lt;&lt;endl;    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603883072417.png" alt="1603883072417"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603883059224.png" alt="1603883059224"></p><h4 id="方法二：-1"><a href="#方法二：-1" class="headerlink" title="方法二："></a>方法二：</h4><p>老师出这个题应该是为了考察dfs，所以这样写一下dfs的方法：</p><p>对于x，与方法一的解释一样，它肯定是由0，1，…,x-1得到的，所以我们再dfs求走到第0,1,…,x-1步的方法，dfs的边界设置为 if(x==0)return 1;这样也是可以求得结果的，只是时间复杂度是指数级别。但是如果我们进行<strong>记忆化搜索</strong>，即用dp[]进行记录每一个状态的答案，一旦存在就不再dfs，这样的时间复杂度可以优化到O(n^2).</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n;int dfs(int x){    if(x==0)return 1;    int res=0;    for(int i=0;i&lt;=x-1;i++)res+=dfs(i);    return res;}int main(){    cin&gt;&gt;n;    cout&lt;&lt;dfs(n)&lt;&lt;endl;    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603883468240.png" alt="1603883468240"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603883460594.png" alt="1603883460594"></p><h1 id="3-0-1背包"><a href="#3-0-1背包" class="headerlink" title="3.0-1背包"></a>3.0-1背包</h1><p>描述</p><p>需对容量为c 的背包进行装载。从n 个物品中选取装入背包的物品，每件物品i 的重量为wi ，价值为pi 。对于可行的背包装载，背包中物品的总重量不能超过背包的容量，最佳装载是指所装入的物品价值最高。 </p><p>输入</p><p>多个测例，每个测例的输入占三行。第一行两个整数：n（n&lt;=10）和c，第二行n个整数分别是w1到wn，第三行n个整数分别是p1到pn。n 和 c 都等于零标志输入结束。</p><p> 输出</p><p>每个测例的输出占一行，输出一个整数，即最佳装载的总价值。</p><p>输入样例</p><p>1 2<br>1<br>1<br>2 3<br>2 2<br>3 4<br>0 0</p><p> 输出样例</p><p>1<br>4</p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一：-2"><a href="#方法一：-2" class="headerlink" title="方法一："></a>方法一：</h4><p>0-1背包的裸题，那就可以直接写一个01背包的动态转移方程：dp[j]=max(dp[j],dp[j-w[i]]+p[i])。dp[j]的意思是：当背包已装j的重量的物品时的最大价值。那么它可以由背包已装j-w[i]时最大的价值进行转移，即由dp[j-w[i]]+p[i]得到。注意每一次要将dp[]设置为0，因为背包此时无价值。当状态方程枚举结束后，我们再从 dp[]数组中找一遍，求得答案maxx=max{dp[i]}(i from 0 to c)，输出答案maxx。这种动态规划的方法的时间复杂度为O(n^2).</p><p><strong>ps：</strong>0-1背包也可以写成二维dp[][]，只是这样写成滚动数组可以更加节省空间。</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=    2000+50;int n,c,w[maxn],dp[maxn],p[maxn];int main(){    int i,j;    while(1){        scanf(&quot;%d%d&quot;,&amp;n,&amp;c);        if(n==0&amp;&amp;c==0)break;        for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i];        for(i=1;i&lt;=n;i++)cin&gt;&gt;p[i];        memset(dp,0,sizeof(dp));        for(i=1;i&lt;=n;i++){            for(j=c;j&gt;=1;j--){                if(j-w[i]&gt;=0&amp;&amp;dp[j]&lt;dp[j-w[i]]+p[i]){                    dp[j]=dp[j-w[i]]+p[i];                }            }        }        int maxx=0;        for(i=0;i&lt;=c;i++)            if(maxx&lt;dp[i])                maxx=dp[i];        cout&lt;&lt;maxx&lt;&lt;endl;    }    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603884301074.png" alt="1603884301074"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603884284377.png" alt="1603884284377"></p><h4 id="方法二：-2"><a href="#方法二：-2" class="headerlink" title="方法二："></a>方法二：</h4><p>除了直接写0-1背包的动态转移方程，还可以直接写dfs，每一个背包无非就是取和不取两个状态，如果要取则要求背包容量 res&gt;=w[now]。分别用ans1，ans2表示取当前物品，不取当前物品的最大价值，dfs返回max(ans1,ans2)，dfs的终止条件是now ==n+1。时间复杂度(2^n)。</p><p><strong>ps:</strong>方法二相较于方法一思维上更加简单，容易想到，但是代码就相对麻烦，并且时间复杂度不够优秀，当然如果加上记忆化搜索后时间复杂度和动态规划是相当的。我个人更喜欢方法一。</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=    2000+50;int n,c,w[maxn],p[maxn];int dfs(int now,int res){    if(now==n+1)return 0;    int ans1=0,ans2=0;    if(res&gt;=w[now]){        ans1=dfs(now+1,res-w[now])+p[now];    }    ans2=dfs(now+1,res);    if(ans1&gt;=ans2)return ans1;    return ans2;}int main(){    int i,j;    while(1){        scanf(&quot;%d%d&quot;,&amp;n,&amp;c);        if(n==0&amp;&amp;c==0)break;        for(i=1;i&lt;=n;i++)cin&gt;&gt;w[i];        for(i=1;i&lt;=n;i++)cin&gt;&gt;p[i];        cout&lt;&lt;dfs(1,c)&lt;&lt;endl;    }    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603885210798.png" alt="1603885210798"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603885191198.png" alt="1603885191198"></p><h1 id="4-求解组合问题"><a href="#4-求解组合问题" class="headerlink" title="4.求解组合问题"></a>4.求解组合问题</h1><p>编写一个实验程序,采用回溯法输出自然数1~n中任取r个数的所有组合。</p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>用回溯法求组合，n个数字选r个，每一个数字有两种选择，要么选，要么不选。dfs(int now)表示当前的决策数字是now，则dfs的边界条件是now==n+1。对于数字now，可以选择，也可以不选择。选择的话a[++a[0]]=now，a[0]记录当前选择的数的数量，回溯的时候记得a[0]—,再进行不选择now的dfs搜索。当now==n+1的时候表明当前已经选择完了，如果a[0]==r,则当前的选择组合刚好是满足条件的，输出即可。时间复杂度O(2^n)</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+50;int n,r,a[maxn];void dfs(int now){    if(now==n+1){        if(a[0]==r){            for(int i=1;i&lt;=a[0];i++)cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;        }        return ;    }    a[++a[0]]=now;    dfs(now+1);    a[0]--;    dfs(now+1);}int main(){    cin&gt;&gt;n&gt;&gt;r;    dfs(1);    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603886599309.png" alt="1603886599309"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603886613973.png" alt="1603886613973"></p><h1 id="5-最小重量机"><a href="#5-最小重量机" class="headerlink" title="5.最小重量机"></a>5.最小重量机</h1><p>设某一机器由n个部件组成，每一种部件都可以从m个不同的供应商处购得。设 wij  是从供应商j处购得的部件 i 的重量， cij 是相应的价格。试设计一个算法，给出总价格不超过 c 的最小重量机器设计。</p><p>输入：第一行3个整数n,m,cost，接下来n行输入wij  （每行m个整数），最后n行输入cij  （每行m个整数），这里n&gt;=1, m&lt;=100.</p><p>输出：第一行包括n个整数，表示每个对应的供应商编号，第2行为对应的重量。</p><p>输入样例：</p><p>337</p><p>123</p><p>321</p><p>232</p><p>123</p><p>542</p><p>212</p><p>输出样例：</p><p>131</p><p>4</p><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>这里用dfs进行搜索，每找到一个符合条件的情况，就更新bestw和x[]。bestw储存最小的重量，x[i]表示部件i所对应的供应商，nowx[i]表示dfs过程中部件i选择的供应商。w[i][j] 表示从供应商j处购得的部件i的重量 ，c[i][j]表示相应的价格。dfs(int now,int noww,int nowp)表示搜索第now个部件时的当前重量为noww，耗费nowp，对于第now个物品它有m个供应商可以选择，当nowp+c[now][i]&lt;=cost时则符合条件可以进行dfs(now+1,noww+w[now][i],nowp+c[now][i]);dfs的边界条件时now==n+1，此时如果bestw&gt;noww，则要更新bestw，以及x[]。最后输出bestw和x[].</p><p><strong>ps:</strong>如果PE的话，把最后的空格去掉（输出x[]的时候,x[n]后面不要跟空格），并且加上printf(“\n”).</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200+50;int n,m,cost,w[maxn][maxn],c[maxn][maxn],bestw=0x3f3f3f3f,nowx[maxn],x[maxn];void dfs(int now,int noww,int nowp){    int i,j;    if(now==n+1){        if(bestw&gt;noww){            bestw=noww;            for(i=1;i&lt;=n;i++)x[i]=nowx[i];        }        return ;    }    for(i=1;i&lt;=m;i++){        if(nowp+c[now][i]&lt;=cost){            nowx[now]=i;            dfs(now+1,noww+w[now][i],nowp+c[now][i]);        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;cost;    int i,j;    for(i=1;i&lt;=n;i++)        for(j=1;j&lt;=m;j++)                cin&gt;&gt;w[i][j];    for(i=1;i&lt;=n;i++)        for(j=1;j&lt;=m;j++)            cin&gt;&gt;c[i][j];    dfs(1,0,0);    for(i=1;i&lt;=n;i++){        cout&lt;&lt;x[i];        if(i!=n)cout&lt;&lt;&#39; &#39;;    }    cout&lt;&lt;endl;    cout&lt;&lt;bestw&lt;&lt;endl;    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603888641972.png" alt="1603888641972"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603888654371.png" alt="1603888654371"></p><h1 id="6-最长公共子序列"><a href="#6-最长公共子序列" class="headerlink" title="6.最长公共子序列"></a>6.最长公共子序列</h1><p>描述</p><p>一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=<x1, x2,…, xm>，则另一序列Z=<z1, z2,…, zk>是X的子序列是指存在一个严格递增的下标序列 <i1, i2,…, ik>，使得对于所有j=1,2,…,k有：<br>Xij ＝ Zj<br>如果一个序列S即是A的子序列又是B的子序列，则称S是A、B的公共子序列。<br>求A、B所有公共子序列中最长的序列的长度。</p><p>输入</p><p>输入共两行，每行一个由字母和数字组成的字符串，代表序列A、B。A、B的长度不超过200个字符。</p><p>输出</p><p>一个整数，表示最长各个子序列的长度。</p><p>格式：printf(“%d\n”);</p><p>输入样例</p><p>programming<br>contest</p><p>输出样例</p><p>2</p><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>像LCS这样的问题，它具有重叠子问题的性质，因此：用递归来求解就太不划算了。因为采用递归，它重复地求解了子问题。采用动态规划时，并不需要去一 一 计算那些重叠了的子问题 。对于<strong>dp[i][j]</strong>表示 <strong>(s1,s2….si) 和 (t1,t2…tj) 的最长公共子序列的长度</strong> 。</p><p>当i==0||j==0 时,dp[i][j]=0;</p><p>当i,j&gt;0,si==tj时,  dp[i][j]=dp[i-1][j-1]+1;</p><p>当i,j&gt;0,si!=tj时，dp[i][j]=max{dp[i][j-1],dp[i-1][j]};</p><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a><strong>时间复杂度：</strong></h3><p>由于只需要填一个m行n列的二维数组，其中m代表第一个字符串长度，n代表第二个字符串长度</p><p>所以时间复杂度为O（m*n）</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+50;char s[maxn],t[maxn];int lens,lent,dp[maxn][maxn];int max(int x,int y){    if(x&gt;y)return x;    return y;}int main(){    scanf(&quot;%s%s&quot;,s+1,t+1);    lens=strlen(s+1);    lent=strlen(t+1);    for(int i=1;i&lt;=lens;i++){        for(int j=1;j&lt;=lent;j++){            if(s[i]==t[j]){                dp[i][j]=dp[i-1][j-1]+1;            }            else{                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);            }        }    }    printf(&quot;%d\n&quot;,dp[lens][lent]);    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603899713319.png" alt="1603899713319"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603899700760.png" alt="1603899700760"></p><h1 id="7-活动安排问题"><a href="#7-活动安排问题" class="headerlink" title="7.活动安排问题"></a>7.活动安排问题</h1><p>问题：有n个活动的集合A={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。<br>求解：安排尽量多项活动在该场地进行，即求A的最大相容子集。<br>设待安排的11个活动的开始时间和结束时间按结束时间的升序排列如下：</p><p>将此表数据作为实现该算法的测试数据。</p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603896772164.png" alt="1603896772164"></p><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><h4 id="方法一：-3"><a href="#方法一：-3" class="headerlink" title="方法一："></a>方法一：</h4><p>题意很明显希望参加的活动数目尽量多。对于活动安排问题可以采取动态规划的策略：</p><p>首先将活动的结束时间按照第一关键字排序（由小到大），再将活动的开始时间作为第二关键字排序（由小到大）</p><p>定义<strong>dp[i]</strong>表示在前i场比赛中最多可以参加几场比赛，</p><p>由此得出方程：dp[i]=max(dp[i-1],dp[temp]+1);</p><p>temp指从dp[i-1]向前找到的第一个允许参加第i场活动的活动编号，由它推导出dp[i]=dp[temp]+1;</p><p>由于每次循环时都向前找一次temp会浪费太多时间，又因为活动开始或结束时间是单调递增的，</p><p>故可以令temp在循环时逐步递增，这样时间复杂度就降到了O(n).</p><p>这里只是讲解一下动态规划的想法。就不写代码了，动态规划的代码和下面的贪心方法相似。只是这种动态规划的思路是基于贪心的思想来实现的。</p><h4 id="方法二：-3"><a href="#方法二：-3" class="headerlink" title="方法二："></a>方法二：</h4><p>这个问题可以抽象为在一个数轴上有n条线段，现要选取其中k条线段使得这k条线段两两没有重合部分，问最大的k为多少。<br>最左边的线段放什么最好？<br>显然放右端点最靠左的线段最好，从左向右放，右端点越小妨碍越少。<br>其他线段放置按右端点排序，贪心放置线段，即能放就放。</p><p>以上两种方法的时间复杂度都是O(nlogn)，快速排序的时间复杂度是O(nlogn),而动态规划或者贪心执行更新策略的时间复杂度是O(n).</p><p><strong>代码：</strong></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2e3+50;int n;struct Node{    int s,f;}a[maxn];bool cmp(Node x,Node y){    if(x.f==y.f)return x.s&lt;y.s;    return x.f&lt;y.f;}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].s&gt;&gt;a[i].f;    sort(a+1,a+1+n,cmp);    int ans=1,now=1,opt=2;    while(opt&lt;=n){        if(a[opt].s&gt;=a[now].f){            ans++;            now=opt;        }        opt++;    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><p><strong>运行结果：</strong></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603897881797.png" alt="1603897881797"></p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1603896695091.png" alt="1603896695091"></p>        <div id="aplayer-ZrdVIvcm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ZrdVIvcm"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ-test3</title>
    <link href="/2020/10/23/NOJ-test3/"/>
    <url>/2020/10/23/NOJ-test3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先占个坑,等什么时候有空了,再补题解,先贴上代码.</p><p>代码都不长,就是简单bfs.vis标记注意状态.除了<strong>特殊的二阶魔方</strong>是真的恶心!</p><h1 id="A-加1乘2平方"><a href="#A-加1乘2平方" class="headerlink" title="A.加1乘2平方"></a>A.加1乘2平方</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int maxn=10000+50; int n,m,vis[maxn];int min(int x,int y){    return x&lt;=y?x:y;}int main(){    cin&gt;&gt;m&gt;&gt;n;    memset(vis,0x3f3f3f3f,sizeof(vis));    vis[m]=1;    for(int i=m+1;i&lt;=n;i++){        int t=sqrt(i);        if(vis[i-1])vis[i]=min(vis[i],vis[i-1]+1);        if(i%2==0&amp;&amp;vis[i/2])vis[i]=min(vis[i],vis[i/2]+1);        if(t*t==i&amp;&amp;vis[t])vis[i]=min(vis[i],vis[t]+1);    }    cout&lt;&lt;vis[n]-1&lt;&lt;endl;    return 0;}</code></pre><h1 id="B-电子老鼠闯迷宫"><a href="#B-电子老鼠闯迷宫" class="headerlink" title="B.电子老鼠闯迷宫"></a>B.电子老鼠闯迷宫</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=205;int n,m,sx,sy,tx,ty,a[maxn][maxn],vis[maxn][maxn];int dx[4]={0,0,1,-1};int dy[4]={1,-1,0,0};struct Point{    int x,y,cnt;};int min(int x,int y){    return x&lt;=y?x:y;}int main(){    cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;tx&gt;&gt;ty;m=n=12;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++){            char x;cin&gt;&gt;x;            if(x==&#39;.&#39;)a[i][j]=1;        }    queue&lt;Point&gt;q;    Point now;    now.x=sx;now.y=sy;now.cnt=0;    vis[sx][sy]=1;    q.push(now);    int ans=0x3f3f3f3f;    while(!q.empty()){        now=q.front();q.pop();        if(now.x==tx&amp;&amp;now.y==ty){            ans=min(ans,now.cnt);            continue;        }        if(now.cnt&gt;ans)continue;        for(int i=0;i&lt;4;i++){            if(now.x+dx[i]&gt;=1&amp;&amp;now.x+dx[i]&lt;=n&amp;&amp;now.y+dy[i]&gt;=1&amp;&amp;now.y+dy[i]&lt;=m&amp;&amp;!vis[now.x+dx[i]][now.y+dy[i]]&amp;&amp;a[now.x+dx[i]][now.y+dy[i]]){                Point nex;nex.x=now.x+dx[i];nex.y=now.y+dy[i];nex.cnt=now.cnt+1;                vis[nex.x][nex.y]=1;                q.push(nex);            }        }    }        cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="C-跳马"><a href="#C-跳马" class="headerlink" title="C.跳马"></a>C.跳马</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200+50;int T,xs,xt,ys,yt,vis[maxn][maxn];struct Node{    int x,y,s;};int d[8][2]={{1,2},{2,1},{2,-1},{1,-2},{-2,1},{-1,2},{-2,-1},{-1,-2}};int main(){    cin&gt;&gt;T;    while(T--){        int i;        memset(vis,0,sizeof(vis));        cin&gt;&gt;xs&gt;&gt;ys&gt;&gt;xt&gt;&gt;yt;        queue&lt;Node&gt;q;        Node now={xs,ys,0};        q.push(now);        int step=0,ans=0;        while(!q.empty()){            now=q.front();q.pop();            if(vis[now.x][now.y])continue;            if(now.x==xt&amp;&amp;now.y==yt){                ans=now.s;                break;            }            vis[now.x][now.y]=1;            for(i=0;i&lt;8;i++){                int x=now.x+d[i][0],y=now.y+d[i][1];                if(x&gt;=1&amp;&amp;x&lt;=200&amp;&amp;y&gt;=1&amp;&amp;y&lt;=200){                    Node nex={x,y,now.s+1};                    q.push(nex);                }            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-独轮车"><a href="#D-独轮车" class="headerlink" title="D.独轮车"></a>D.独轮车</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=20+5;const int maxm=5+5;struct Node{    int x,y,s,c,f;};int d[4][2]={{1,0},{-1,0},{0,-1},{0,1}};int vis[maxn][maxn][maxm][maxm];int xs,xt,ys,yt,F;char f,col1,col2,a[maxn][maxn];int main(){    cin&gt;&gt;xs&gt;&gt;ys&gt;&gt;col1&gt;&gt;f;    cin&gt;&gt;xt&gt;&gt;yt&gt;&gt;col2;    int n=20;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            cin&gt;&gt;a[i][j];        }    }    int c1,c2;    if(col1==&#39;R&#39;)c1=0;    else if(col1==&#39;Y&#39;)c1=1;    else if(col1==&#39;B&#39;)c1=2;    else if(col1==&#39;W&#39;)c1=3;    else if(col1==&#39;G&#39;)c1=4;    if(col2==&#39;R&#39;)c2=0;    else if(col2==&#39;Y&#39;)c2=1;    else if(col2==&#39;B&#39;)c2=2;    else if(col2==&#39;W&#39;)c2=3;    else if(col2==&#39;G&#39;)c2=4;    if(f==&#39;N&#39;)F=0;    else if(f==&#39;E&#39;)F=1;    else if(f==&#39;S&#39;)F=2;    else if(f==&#39;W&#39;)F=3;    Node now={xs,ys,0,c1,F};    queue&lt;Node&gt;q;q.push(now);    int ans=0;    while(!q.empty()){        now=q.front();q.pop();        if(!(now.x&gt;=1&amp;&amp;now.x&lt;=n&amp;&amp;now.y&gt;=1&amp;&amp;now.y&lt;=n)||a[now.x][now.y]==&#39;X&#39;)continue;        if(vis[now.x][now.y][now.c][now.f])continue;        vis[now.x][now.y][now.c][now.f]=1;        if(now.x==xt&amp;&amp;now.y==yt&amp;&amp;now.c==c2){            ans=now.s;            break;        }        Node nex;nex.x=now.x;nex.y=now.y;nex.s=now.s+1;nex.c=now.c;nex.f=(now.f+1)%4;        q.push(nex);    //    nex.x=now.x;nex.y=now.y;nex.s=now.s+1;nex.c=now.c;nex.f=(now.f+2)%4;    //    q.push(nex);//注意是旋转90°         nex.x=now.x;nex.y=now.y;nex.s=now.s+1;nex.c=now.c;nex.f=(now.f+3)%4;        q.push(nex);        if(now.f==0){            nex.x=now.x-1;nex.y=now.y;nex.s=now.s+1;nex.c=(now.c+1)%5;nex.f=now.f;            q.push(nex);        }        else if(now.f==1){            nex.x=now.x;nex.y=now.y+1;nex.s=now.s+1;nex.c=(now.c+1)%5;nex.f=now.f;            q.push(nex);        }        else if(now.f==2){            nex.x=now.x+1;nex.y=now.y;nex.s=now.s+1;nex.c=(now.c+1)%5;nex.f=now.f;            q.push(nex);        }        else if(now.f==3){            nex.x=now.x;nex.y=now.y-1;nex.s=now.s+1;nex.c=(now.c+1)%5;nex.f=now.f;            q.push(nex);        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="E-六数码问题"><a href="#E-六数码问题" class="headerlink" title="E.六数码问题"></a>E.六数码问题</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10+5;struct Node{    int a[10][10],s;};int a[10][10];int main(){    while(cin&gt;&gt;a[1][1]&gt;&gt;a[1][2]&gt;&gt;a[1][3]&gt;&gt;a[2][1]&gt;&gt;a[2][2]&gt;&gt;a[2][3]){        Node now;        for(int i=1;i&lt;=2;i++){            for(int j=1;j&lt;=3;j++){                now.a[i][j]=a[i][j];            }        }        queue&lt;Node&gt;q;        now.s=0;        q.push(now);        int ans=0x3f3f3f3f,cnt=0;        while(!q.empty()){            cnt++;            now=q.front();q.pop();            int sign=0;            for(int i=1;i&lt;=2;i++){                for(int j=1;j&lt;=3;j++){                    if(now.a[i][j]!=(i-1)*3+j){                        sign=1;                        break;                    }                }                if(sign)break;            }            if(!sign||cnt&gt;=1000){                if(sign==0)                ans=now.s;                break;            }            Node nex1=now,nex2=now;            int t=nex1.a[2][1];nex1.a[2][1]=nex1.a[2][2];nex1.a[2][2]=nex1.a[1][2];nex1.a[1][2]=nex1.a[1][1];nex1.a[1][1]=t;            t=nex2.a[2][2];nex2.a[2][2]=nex2.a[2][3];nex2.a[2][3]=nex2.a[1][3];nex2.a[1][3]=nex2.a[1][2];nex2.a[1][2]=t;            nex1.s++;nex2.s++;            q.push(nex1);            q.push(nex2);        }        if(ans==0x3f3f3f3f){            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        }        else{            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        }        }}</code></pre><h1 id="F-特殊的二阶魔方"><a href="#F-特殊的二阶魔方" class="headerlink" title="F.特殊的二阶魔方"></a>F.特殊的二阶魔方</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;struct Node{    int a[7][4][4],st,s;};map&lt;int,int&gt;mp;int main(){    Node now;now.st=0;    int i,j,k;    for(i=1;i&lt;=6;i++){        for(j=1;j&lt;=2;j++){            for(k=1;k&lt;=2;k++){                char x;cin&gt;&gt;x;                now.a[i][j][k]=x-&#39;0&#39;;                now.s=now.s*2+now.a[i][j][k];            }        }    }    queue&lt;Node&gt;q;    q.push(now);    int ans=0x3f3f3f3f;    while(!q.empty()){        now=q.front();q.pop();        if(mp[now.s])continue;        mp[now.s]=1;        for(i=1;i&lt;=6;i++){            int sign=0;            for(j=1;j&lt;=2;j++){                for(k=1;k&lt;=2;k++){                    if(now.a[i][j][k]==1){                        sign=1;                    }                }            }            if(!sign){                cout&lt;&lt;now.st&lt;&lt;endl;                return 0;            }        }        Node nex=now;nex.st++;nex.s=0;        //1-Up 2-Down 3-Lefe 4-Right 5-front 6-back        //DR         nex.a[6][2][1]=now.a[3][2][2];nex.a[6][2][2]=now.a[3][2][1];        nex.a[3][2][2]=now.a[5][2][2];nex.a[3][2][1]=now.a[5][2][1];        nex.a[5][2][1]=now.a[4][2][2];nex.a[5][2][2]=now.a[4][2][1];        nex.a[4][2][1]=now.a[6][2][1];nex.a[4][2][2]=now.a[6][2][2];        nex.a[2][1][1]=now.a[2][2][1];nex.a[2][1][2]=now.a[2][1][1];nex.a[2][2][2]=now.a[2][1][2];nex.a[2][2][1]=now.a[2][2][2];        for(i=1;i&lt;=6;i++){            for(j=1;j&lt;=2;j++){                for(k=1;k&lt;=2;k++){                    nex.s=nex.s*2+nex.a[i][j][k];                }            }        }        q.push(nex);        //DL        nex=now;nex.st++;nex.s=0;        nex.a[6][2][1]=now.a[4][2][1];nex.a[6][2][2]=now.a[4][2][2];        nex.a[3][2][1]=now.a[6][2][2];nex.a[3][2][2]=now.a[6][2][1];        nex.a[5][2][1]=now.a[3][2][1];nex.a[5][2][2]=now.a[3][2][2];        nex.a[4][2][1]=now.a[5][2][2];nex.a[4][2][2]=now.a[5][2][1];        nex.a[2][1][1]=now.a[2][1][2];nex.a[2][1][2]=now.a[2][2][2];nex.a[2][2][2]=now.a[2][2][1];nex.a[2][2][1]=now.a[2][1][1];        for(i=1;i&lt;=6;i++){            for(j=1;j&lt;=2;j++){                for(k=1;k&lt;=2;k++){                    nex.s=nex.s*2+nex.a[i][j][k];                }            }        }        q.push(nex);        //RU        nex=now;nex.st++;nex.s=0;        nex.a[1][1][2]=now.a[5][1][2];nex.a[1][2][2]=now.a[5][2][2];        nex.a[5][1][2]=now.a[2][2][2];nex.a[5][2][2]=now.a[2][1][2];        nex.a[2][1][2]=now.a[6][1][2];nex.a[2][2][2]=now.a[6][2][2];        nex.a[6][1][2]=now.a[1][2][2];nex.a[6][2][2]=now.a[1][1][2];         nex.a[4][1][1]=now.a[4][1][2];nex.a[4][1][2]=now.a[4][2][2];nex.a[4][2][2]=now.a[4][2][1];nex.a[4][2][1]=now.a[4][1][1];        for(i=1;i&lt;=6;i++){            for(j=1;j&lt;=2;j++){                for(k=1;k&lt;=2;k++){                    nex.s=nex.s*2+nex.a[i][j][k];                }            }        }        q.push(nex);        //RD        nex=now;nex.st++;nex.s=0;        nex.a[1][1][2]=now.a[6][2][2];nex.a[1][2][2]=now.a[6][1][2];        nex.a[6][1][2]=now.a[2][1][2];nex.a[6][2][2]=now.a[2][2][2];        nex.a[2][1][2]=now.a[5][2][2];nex.a[2][2][2]=now.a[5][1][2];        nex.a[5][1][2]=now.a[1][1][2];nex.a[5][2][2]=now.a[1][2][2];         nex.a[4][1][1]=now.a[4][2][1];nex.a[4][2][1]=now.a[4][2][2];nex.a[4][2][2]=now.a[4][1][2];nex.a[4][1][2]=now.a[4][1][1];        for(i=1;i&lt;=6;i++){            for(j=1;j&lt;=2;j++){                for(k=1;k&lt;=2;k++){                    nex.s=nex.s*2+nex.a[i][j][k];                }            }        }        q.push(nex);        //C        nex=now;nex.st++;nex.s=0;        nex.a[1][1][1]=now.a[3][2][1];nex.a[1][1][2]=now.a[3][1][1];        nex.a[3][1][1]=now.a[2][1][1];nex.a[3][2][1]=now.a[2][1][2];        nex.a[2][1][1]=now.a[4][2][1];nex.a[2][1][2]=now.a[4][1][1];        nex.a[4][1][1]=now.a[1][1][1];nex.a[4][2][1]=now.a[1][1][2];        nex.a[6][1][1]=now.a[6][2][1];nex.a[6][2][1]=now.a[6][2][2];nex.a[6][2][2]=now.a[6][1][2];nex.a[6][1][2]=now.a[6][1][1];        for(i=1;i&lt;=6;i++){            for(j=1;j&lt;=2;j++){                for(k=1;k&lt;=2;k++){                    nex.s=nex.s*2+nex.a[i][j][k];                }            }        }        q.push(nex);        //CC        nex=now;nex.st++;nex.s=0;        nex.a[1][1][1]=now.a[4][1][1];nex.a[1][1][2]=now.a[4][2][1];        nex.a[4][1][1]=now.a[2][1][2];nex.a[4][2][1]=now.a[2][1][1];        nex.a[2][1][1]=now.a[3][1][1];nex.a[2][1][2]=now.a[3][2][1];        nex.a[3][1][1]=now.a[1][1][2];nex.a[3][2][1]=now.a[1][1][1];        nex.a[6][1][1]=now.a[6][1][2];nex.a[6][1][2]=now.a[6][2][2];nex.a[6][2][2]=now.a[6][2][1];nex.a[6][2][1]=now.a[6][1][1];        for(i=1;i&lt;=6;i++){            for(j=1;j&lt;=2;j++){                for(k=1;k&lt;=2;k++){                    nex.s=nex.s*2+nex.a[i][j][k];                }            }        }        q.push(nex);    }    cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;    return 0;}</code></pre><h1 id="G-推箱子"><a href="#G-推箱子" class="headerlink" title="G.推箱子"></a>G.推箱子</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10+5;struct Node{    int xr,yr,x,y,s;};char a[maxn][maxn];int xt,yt;int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}},vis[maxn][maxn][maxn][maxn];int main(){    int i;    for(i=1;i&lt;=10;i++)cin&gt;&gt;a[i]+1;    queue&lt;Node&gt;q;    Node now;     for(i=1;i&lt;=10;i++){        for(int j=1;j&lt;=10;j++){            if(a[i][j]==&#39;2&#39;){                now.x=i;now.y=j;                }            else if(a[i][j]==&#39;3&#39;){                xt=i;yt=j;            }            else if(a[i][j]==&#39;4&#39;){                now.xr=i;now.yr=j;            }        }    }    now.s=0;    q.push(now);    int ans=0x3f3f3f3f;    while(!q.empty()){        now=q.front();q.pop();        if(vis[now.xr][now.yr][now.x][now.y])continue;        vis[now.xr][now.yr][now.x][now.y]=1;        if(now.xr&lt;1||now.xr&gt;10||now.yr&lt;1||now.yr&gt;10||now.x&lt;1||now.x&gt;10||now.y&lt;1||now.y&gt;10)continue;        if(a[now.xr][now.yr]==&#39;1&#39;||a[now.x][now.y]==&#39;1&#39;)continue;        if(now.x==xt&amp;&amp;now.y==yt){            ans=now.s;            break;        }        for(i=0;i&lt;4;i++){            Node nex=now;            nex.xr+=d[i][0],nex.yr+=d[i][1],nex.s++;            if(nex.xr==nex.x&amp;&amp;nex.yr==nex.y){                nex.x+=d[i][0];nex.y+=d[i][1];                q.push(nex);            }            else{                q.push(nex);            }        }    }    if(ans==0x3f3f3f3f)cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;    else cout&lt;&lt;ans&lt;&lt;endl;}</code></pre><h1 id="H-polygon"><a href="#H-polygon" class="headerlink" title="H.polygon"></a>H.polygon</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=2000+50;int n,m,vis[maxn];double len=10000.0,a[maxn],b[maxn];int main(){    cin&gt;&gt;n&gt;&gt;m;    int i,j;    for(i=1;i&lt;=n;i++){        a[i]=(i-1)*(len/n);    }    for(i=1;i&lt;=n+m;i++){        b[i]=(i-1)*(len/(n+m));    }    double ans=0;    for(i=1;i&lt;=n;i++){        int opt=0;double maxx=1e9;        for(j=1;j&lt;=n+m;j++){            if(!vis[j]&amp;&amp;fabs(a[i]-b[j])&lt;maxx){                maxx=fabs(a[i]-b[j]);                opt=j;            }        }            vis[opt]=1;        ans+=fabs(a[i]-b[opt]);    }    printf(&quot;%.4lf\n&quot;,ans);    return 0;}</code></pre><h1 id="I-木乃伊迷宫"><a href="#I-木乃伊迷宫" class="headerlink" title="I.木乃伊迷宫"></a>I.木乃伊迷宫</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10+5;struct Node{    int xr,yr,xm,ym;};int a[maxn][maxn][maxn],n,xt,yt,vis[maxn][maxn][maxn][maxn];int d[4][2]={{0,1},{0,-1},{1,0},{-1,0}};int main(){    cin&gt;&gt;n;    int i,j;    for(i=1;i&lt;=n;i++){        int s,x,y;        cin&gt;&gt;x&gt;&gt;y&gt;&gt;s;        if(s==0){            a[x][y][0]=a[x+1][y][3]=1;//下侧 上侧         }        else{            a[x][y][1]=a[x][y][2]=1;//右侧 左侧 ps: 我也不知道为什么这里错的可以AC，原本对的WA。         }    }    Node now;    cin&gt;&gt;now.xm&gt;&gt;now.ym&gt;&gt;now.xr&gt;&gt;now.yr&gt;&gt;xt&gt;&gt;yt;    queue&lt;Node&gt;q;    q.push(now);    while(!q.empty()){        now=q.front();q.pop();        if(vis[now.xr][now.yr][now.xm][now.ym])continue;        vis[now.xr][now.yr][now.xm][now.ym]=1;        Node nex;        if(now.xr==xt&amp;&amp;now.yr==yt){            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;            return 0;        }        for(int i=0;i&lt;4;i++){            Node nex;            if(i==0&amp;&amp;a[now.xr][now.yr][0])continue;            if(i==1&amp;&amp;a[now.xr][now.yr][3])continue;            if(i==2&amp;&amp;a[now.xr][now.yr][1])continue;            if(i==3&amp;&amp;a[now.xr][now.yr][2])continue;            nex.xr=now.xr+d[i][0];nex.yr=now.yr+d[i][1];            if(nex.xr&lt;0||nex.xr&gt;=6||nex.yr&lt;0||nex.yr&gt;=6)continue;            int res=2;            while(now.yr!=now.ym&amp;&amp;res){                if(now.ym&gt;now.yr&amp;&amp;!a[now.xm][now.ym][2])now.ym--;                else if(now.ym&lt;now.yr&amp;&amp;!a[now.xm][now.ym][1])now.ym++;                res--;            }            while(res){                if(now.xm&gt;now.xr&amp;&amp;!a[now.xm][now.ym][3])now.xm--;                else if(now.xm&lt;now.xr&amp;&amp;!a[now.xm][now.ym][0])now.xm++;                if(now.xm==now.xr&amp;&amp;now.ym==now.yr)break;                res--;            }            if(!res){                nex.xm=now.xm;nex.ym=now.ym;                q.push(nex);            }        }    }    cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    return 0;}</code></pre><h1 id="J-八数码"><a href="#J-八数码" class="headerlink" title="J.八数码"></a>J.八数码</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;const int maxn=20+5;struct Node{    int s,a[5][5],state;}; int a[maxn][maxn],t[maxn][maxn],state;map&lt;int,int&gt;mp;int main(){    int i,j;Node now;now.state=0;now.s=0;    for(i=1;i&lt;=3;i++){        for(j=1;j&lt;=3;j++){            cin&gt;&gt;now.a[i][j];            now.state=now.state*10+now.a[i][j];            t[i][j]=(i-1)*3+j;            state=state*10+t[i][j];        }    }    state-=9;    t[3][3]=0;    queue&lt;Node&gt;q;    int ans=0x3f3f3f3f;    q.push(now);    while(!q.empty()){        now=q.front();q.pop();        if(mp[now.state])continue;        mp[now.state]=1;        for(i=1;i&lt;=3;i++){            int sign=0;            for(j=1;j&lt;=3;j++){                if(now.a[i][j]==0){                    sign=1;break;                }            }            if(sign)break;        }        if(now.state==state){            ans=now.s;            break;        }        Node nex=now;        if(j&gt;=2){            swap(nex.a[i][j],nex.a[i][j-1]);            nex.state=0;            for(int i=1;i&lt;=3;i++){                for(int j=1;j&lt;=3;j++){                    nex.state=nex.state*10+nex.a[i][j];                }            }            nex.s++;            q.push(nex);        }        nex=now;        if(j&lt;=2){            swap(nex.a[i][j],nex.a[i][j+1]);            nex.state=0;            for(int i=1;i&lt;=3;i++){                for(int j=1;j&lt;=3;j++){                    nex.state=nex.state*10+nex.a[i][j];                }            }            nex.s++;            q.push(nex);        }        nex=now;        if(i&gt;=2){            swap(nex.a[i][j],nex.a[i-1][j]);            nex.state=0;            for(int i=1;i&lt;=3;i++){                for(int j=1;j&lt;=3;j++){                    nex.state=nex.state*10+nex.a[i][j];                }            }            nex.s++;            q.push(nex);        }        nex=now;        if(i&lt;=2){            swap(nex.a[i][j],nex.a[i+1][j]);            nex.state=0;            for(int i=1;i&lt;=3;i++){                for(int j=1;j&lt;=3;j++){                    nex.state=nex.state*10+nex.a[i][j];                }            }            nex.s++;            q.push(nex);        }    }    if(ans==0x3f3f3f3f)cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;    else cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-FniZHinQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-FniZHinQ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1407-D</title>
    <link href="/2020/09/09/CodeForces-1407-D/"/>
    <url>/2020/09/09/CodeForces-1407-D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h1><p>Discrete Centrifugal Jumps</p><h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>有n个楼房，给出n个楼房的高度，开始位于1号楼，最后需到达n号楼。当满足一下任一条件则可转移：</p><p>i + 1 = j；</p><p>max(hi+1,…,hj-1)&lt;min(hi,hj);</p><p>max(hi,hj)&lt;min(hi+1,…,hj-1);</p><p>求到达n号楼需要的最少步数。</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><p>根据条件有如下转移:</p><p>1.dp[i]=dp[i-1]+1;</p><p>2.i前面有一个下标假设为j，且这个j满足(a[j]&gt;max(a[j+1]……,a[i-1]); dp[i]=dp[j]+1;</p><p>3.i前面有一个下标假设为j,且这个j满足(a[j]&lt;min(a[j+1]…….a[i-1]);dp[i]=dp[j]+1;</p><p>那么找这个j的过程用单调栈优化。</p><p>具体是什么意思呢？</p><p>比如现在有</p><p>h[i]：4 3 2 5 这样的楼高度</p><p> i :  1 2 3 4</p><p>设一个down的单调栈，维护栈内的元素是单调递减的。当遍历到i=4的时候，由于h[4]&gt;h[down.top() =(3) ] ,那么此时down栈的单调递减性质破坏，需要不停down.pop(),使得栈里没有比h[4]更校的。让这个h[4]来当down栈此时的龙头。</p><p>于是在pop()的过程中，最开始的down.top=3,但是这个是和i=4相邻的，在转移最开始我们就进行了dp[i]=dp[i-1]+1；所以这里其实无所谓第一个top的转移。但是当第二个down.top()==2的时候,这时候进行dp[i]=min(dp[i],dp[down.top]+1)的转移。如此往复到i=n的时候就维护好了。优化了不停找j的过程。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=3e5+50;int h[maxn],dp[maxn],n,d[maxn],top1,u[maxn],top2;int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;h[i];        dp[i]=i;    }    dp[1]=0;    d[++top1]=1,u[++top2]=1;    for(int i=2;i&lt;=n;i++){        dp[i]=dp[i-1]+1;        while(h[i]&gt;=h[d[top1]]&amp;&amp;top1){            int x=h[d[top1]];            top1--;            if(h[i]&gt;x&amp;&amp;top1){                dp[i]=min(dp[i],dp[d[top1]]+1);            }        }        d[++top1]=i;        while(h[i]&lt;=h[u[top2]]&amp;&amp;top2){            int x=h[u[top2]];            top2--;            if(h[i]&lt;x&amp;&amp;top2){                dp[i]=min(dp[i],dp[u[top2]]+1);            }        }        u[++top2]=i;    }    cout&lt;&lt;dp[n]&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-SWZtfwZy" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-SWZtfwZy"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1409</title>
    <link href="/2020/09/05/CodeForces-1409/"/>
    <url>/2020/09/05/CodeForces-1409/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称"><a href="#A-题目名称" class="headerlink" title="A.题目名称:"></a>A.题目名称:</h1><p>Yet Another Two Integers Problem </p><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>每次选择一个k∈[1,10]，a可以a-=k或者a+=k，问需要的最小次数使得a变成b。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>尽量选大，则D=abs(a-b)，D=ceil(D/10)</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,a,b;int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;a&gt;&gt;b;        ll d=abs(a-b);        ll ans=ceil(d*1.0/10.0);        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B.题目名称："></a>B.题目名称：</h1><p>Minimum Product </p><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>每次可以对a-=1，或者b-=1，最多操作n次，并且保证a&gt;=x,b&gt;=y.求a * b的最小值。</p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>先将a变成最小，若有剩余再将b变小，求得minn1；先将b变成最小，若有剩余再将a变小，求得minn2。ans=min(minn1,minn2）。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,a,b,x,y,n;int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y&gt;&gt;n;        ll d1=min(a-x,n);        ll resn=n-d1;        ll d2=min(b-y,resn);        ll ans1=(a-d1)*(b-d2);        d2=min(b-y,n);        resn=n-d2;        d1=min(a-x,resn);        ll ans2=(a-d1)*(b-d2);        cout&lt;&lt;min(ans1,ans2)&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C.题目名称："></a>C.题目名称：</h1><p>Yet Another Array Restoration </p><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>一组数组有n个数，一定包含x，y，求得这组数组使得其中最大的尽量小。</p><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>枚举x与y之间得数字个数，进而得到差值，尽量让y作为最大值，如果中间不够填充，则先向左边扩展，再向右扩展。</p><p>特判：n==2，直接输出x，y。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,x,y,n;int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;        ll d=y-x,tot=0;        if(n==2){            cout&lt;&lt;x&lt;&lt;&#39; &#39;&lt;&lt;y&lt;&lt;endl;            continue;        }        for(int i=n-1;i;i--){            if(d%i==0){                ll D=d/i;                ll now=x;                while(now&lt;=y&amp;&amp;tot&lt;n){                    cout&lt;&lt;now&lt;&lt;&#39; &#39;;                    tot++;                    now+=D;                }                now=x-D;                while(now&gt;0&amp;&amp;tot&lt;n){                    cout&lt;&lt;now&lt;&lt;&#39; &#39;;                    tot++;                    now-=D;                }                now=y+D;                while(tot&lt;n){                    cout&lt;&lt;now&lt;&lt;&#39; &#39;;                    now+=D;                    tot++;                }                break;            }        }        cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-题目名称"><a href="#D-题目名称" class="headerlink" title="D.题目名称:"></a>D.题目名称:</h1><p>Decrease the Sum of Digits </p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给一个数n,每次可以让n+=1,使得n的各个位的数字之和&lt;=s.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>先分解出各个位上的数字,并求和得到sum,若sum&lt;=s则直接输出答案(0),然后从从左到右(从高位到低位)开始判断该位上的数字是否需要变化.如果s-a[opt]&gt;=1,则这一位不会变化,往下一位走.最后走到某一位opt发现s-a[opt]&lt;1,则从opt-1到个位都是要变化的,最小的变化次数是(a[opt-1]+1)*(10^(n-opt+1))-(opt-1位作为最高位的数字)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn=100+50;ll T,n,s,a[maxn],p[maxn];char t[maxn];int main(){    cin&gt;&gt;T;    while(T--){        p[0]=1;        for(ll i=1;i&lt;=19;i++)p[i]=p[i-1]*10ll;        cin&gt;&gt;t+1&gt;&gt;s;        ll sum=0,len=strlen(t+1);        for(ll i=1;i&lt;=len;i++)sum=sum+t[i]-&#39;0&#39;,a[i]=t[i]-&#39;0&#39;;        if(sum&lt;=s){            cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;            continue;        }        ll opt=1;        while(opt&lt;=len&amp;&amp;s&gt;a[opt])s-=a[opt],opt++;        ll res=p[len-opt+1]*(a[opt-1]+1);        ll tot=0;        for(ll i=opt-1;i&lt;=len;i++)tot=tot*10+a[i];        ll ans=res-tot;        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="E-题目名称"><a href="#E-题目名称" class="headerlink" title="E.题目名称:"></a>E.题目名称:</h1><p>Two Platforms </p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>有n个左边点,两块长度为k的木板条,只要球下降掉在木板范围以内,表示木板可以借住小球,求木板可以接住的最大数量.</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h2><p>先将球按照x轴的坐标从小到大排序,另开一个数组b来存在所有球的x轴坐标,对他进行去重.然后用map存每一个对应的x轴的值所对应的最大的下标值.然后对一个点求当前点作为木板的左边界可以接住的球的数量:有当前球的x轴坐标t[i].x可以求得木板的右边界t[i].x+k,如果这个有边界&gt;=t[i].n,则sum[i]=n-i+1;否则在b数组中二分求得第一个比t[i].x+k大的数字b[t],则b[t-1]就是木板所接住的最右边的球,由map反解出b[t-1]对应的x的值对应的最大的小标mp[b[t-1]],sum[i]=mp[b[t-1]]-i+1.这样求出每一个点作为左边界可以接住的球的数量,但是这只是针对一根木板,还需要在这基础上从右到左求得M数组,M[i]表示i之后的点(包括i)一根木板可以接到的最大的球的数量.这样每一次枚举最左边的木板的左边界点i,由此得到木板的右边第一个不在该木板范围内的点i+sum[i],则第二个木板可以接到的最大数量是M[i+sum[i]],这样得到的数量就是sum[i]+M[i+sum[i]],然后每次取最大即可.</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码:"></a>代码:</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;int T,n,k,sum[maxn],b[maxn],M[maxn];struct Point{    int x,y;}t[maxn];int cmp(Point a,Point b){    if(a.x==b.x)return a.y&lt;b.y;    return a.x&lt;b.x;}int main(){    cin&gt;&gt;T;    while(T--){        memset(M,0,sizeof(M));        map&lt;int,int&gt;mp;        cin&gt;&gt;n&gt;&gt;k;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;t[i].x,b[i]=t[i].x;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;t[i].y;        sort(t+1,t+1+n,cmp);        sort(b+1,b+1+n);        int len=unique(b+1,b+1+n)-b-1;        for(int i=1;i&lt;=n;i++){            mp[t[i].x]=i;        }        for(int i=1;i&lt;=n;i++){            int maxx=t[i].x+k;            if(maxx&gt;=t[n].x){                sum[i]=n-i+1;            }            else{                int t=upper_bound(b+1,b+1+n,maxx)-b;                int re=mp[b[t-1]];                sum[i]=re-i+1;            }        }        for(int i=n;i&gt;=1;i--){            M[i]=max(M[i+1],sum[i]);        }        int ans=0;        for(int i=1;i&lt;=n;i++){            ans=max(ans,sum[i]+M[i+sum[i]]);        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="F-题目名称"><a href="#F-题目名称" class="headerlink" title="F.题目名称:"></a>F.题目名称:</h1><p>Subsequences of Length Two </p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>对于字符串s可以将一个字母改成任意一个小写字母,可以操作不超过k次,求s中出现串t的最大数量.</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h2><p>设置dp[i][j][cnt0]表示枚举到i时改变了j次其中右cnt0个t[0]时出现的t的最大数量.则对于i+1来讲有三种状态:</p><p>ps:e0=s[i]==t[0];e1=s[i]==t[1];e01=t[0]==t[1].</p><p>第一种:直接不改变,则dp[i+1][j][l+e0]=max(dp[i+1][j][l+e0],dp[i][j][l]+(e1?l:0);</p><p>第二种:将它变成t[0],则dp[i+1][j+1][l+1]=max(dp[i+1][j+1][l+1],dp[i][j][l]+(e01?l:0));</p><p>第三种:将它变成t[1].则dp[i+1][j+1][l+e01]=max(dp[i+1][j+1][l+e01],dp[i][j][l]+l).</p><p>其中第二种和第三种状态中要保证j+1&lt;=k;三种情况都要保证dp[i][j][l]!=-0x3f3f3f3f</p><p>最后枚举改变次数和cnt0的数量,求max(dp[n][i][cnt0]);</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码:"></a>代码:</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+50;int n,k,dp[maxn][maxn][maxn];char s[maxn],t[maxn];int main(){    cin&gt;&gt;n&gt;&gt;k;    cin&gt;&gt;s&gt;&gt;t;    memset(dp,-0x3f3f3f3f,sizeof(dp));    dp[0][0][0]=0;    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;=k;j++){            for(int l=0;l&lt;=n;l++){                if(dp[i][j][l]==-0x3f3f3f3f)continue;                int e0=s[i]==t[0];                int e1=s[i]==t[1];                int e01=t[0]==t[1];                dp[i+1][j][l+e0]=max(dp[i+1][j][l+e0],dp[i][j][l]+(e1?l:0));                if(j+1&lt;=k){                    dp[i+1][j+1][l+1]=max(dp[i+1][j+1][l+1],dp[i][j][l]+(e01?l:0));                    dp[i+1][j+1][l+e01]=max(dp[i+1][j+1][l+e01],dp[i][j][l]+l);                    }            }        }    }    int ans=0;    for(int i=0;i&lt;=k;i++){        for(int j=0;j&lt;=n;j++){            ans=max(ans,dp[n][i][j]);        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-XoDnAShr" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-XoDnAShr"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1397</title>
    <link href="/2020/08/31/CodeForces-1397/"/>
    <url>/2020/08/31/CodeForces-1397/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A.题目名称："></a>A.题目名称：</h1><p> Juggling Letters </p><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>n个字符串，每次操作可以选择两个字符串（可以相同）选择其中一个字符串中某一字符插入到另一字符串。问：操作任意次，能否使得所有字符串都相同？ </p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>统计n个字符串中26个小写字母的数量是否是n的倍数，是则YES，否则NO</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e3+40;int T,n,cnt[100];char s[maxn][maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i]+1;        memset(cnt,0,sizeof(cnt));        for(int i=1;i&lt;=n;i++)        {            int len=strlen(s[i]+1);            for(int j=1;j&lt;=len;j++)            {                cnt[s[i][j]-&#39;a&#39;+1]++;                            }        }        int sign=0;        for(int i=1;i&lt;=26;i++)        {            if(cnt[i]==0)continue;            if(cnt[i]%n)            {                sign=1;                break;            }        }        if(sign)printf(&quot;NO\n&quot;);        else printf(&quot;YES\n&quot;);    }    return 0;}</code></pre><h1 id="B-题目名称"><a href="#B-题目名称" class="headerlink" title="B.题目名称:"></a>B.题目名称:</h1><p>Power Sequence </p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>n个数组成的数组，下标为0~n-1，首先对数组从小到大排序，然后有一操作：可以对任意数组中任意一个元素的值加一或者减一，代价为1；问最少需要多少代价可以使得数组a[i]=c^i.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>首先将a[]从小到大排序,然后枚举c(1-MAX),再枚举到最小代价之前,答案都在不断减小,所以一旦不再减小就应该终止枚举.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+50;typedef long long ll;ll n,a[maxn],ans;int check(ll x){    ll sum=0,now=1;    for(int i=1;i&lt;=n;i++)    {        sum+=abs(a[i]-now);        now*=x;        if(sum&gt;ans)return 0;    }    ans=sum;    return 1;}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],ans+=a[i];    sort(a+1,a+1+n);    ans-=n;    for(ll i=2;i&lt;=1000000;i++)    {        if(!check(i))break;    }        cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="C-题目名称"><a href="#C-题目名称" class="headerlink" title="C.题目名称:"></a>C.题目名称:</h1><p>Multiples of Length </p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>n个元素组成的数组，有一操作：对于某一段区间[l,r]，可以加上该区间长度len的任意倍数。题目说明：可以证明三次操作可以使得数组所有元素都变成0。 </p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h2><p>这是一个构造题:当n=1的时候,将[1,1]的数+1,再将[1,1]的数-1,最后[1,1]的数-a[1].当n&gt;1的时候,将[1,1]的数改成n,即加上(n-a[1]),再将[2,n]的数全加上a[i] <em> (n-1).最后再-(a[i] </em> n).</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码:"></a>代码:</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+50;typedef long long ll;ll n,a[maxn],y[maxn],t[maxn];int main(){    cin&gt;&gt;n;    for(ll i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    if(n==1)    {        printf(&quot;1 1\n1\n&quot;);        printf(&quot;1 1\n-1\n&quot;);        printf(&quot;1 1\n%d\n&quot;,-a[1]);        return 0;    }    cout&lt;&lt;&quot;1 1&quot;&lt;&lt;endl;    cout&lt;&lt;n-a[1]&lt;&lt;endl;    cout&lt;&lt;&quot;2 &quot;&lt;&lt;n&lt;&lt;endl;    t[1]=-n;    for(int i=2;i&lt;=n;i++)    {        y[i]=a[i]*(n-1);        t[i]=-a[i]*n;    }    for(int i=2;i&lt;=n;i++)cout&lt;&lt;y[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;    cout&lt;&lt;&quot;1 &quot;&lt;&lt;n&lt;&lt;endl;    for(int i=1;i&lt;=n;i++)cout&lt;&lt;t[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;    return 0;}</code></pre><h1 id="D-题目名称"><a href="#D-题目名称" class="headerlink" title="D.题目名称:"></a>D.题目名称:</h1><p>Stoned Game </p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>T和HL玩游戏,每人选择一个未被上一个玩家选择的堆中拿一个石头,一旦某一个人无法拿到石头,则另一个玩家获胜.</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h2><p>当一堆大于其余堆的总和的时候,T一定选择这个堆,则T获胜.<br>其余一般情况:假设最后一堆是x,则知道x的具体值,就知道了sum-x的奇偶性,若x=5,则当剩余9的时候,先手一定选择5这个堆,而后手再先手出手之前一定会阻止它,所以x=4.当x=4的时候,同理剩余7的时候也会出现上述情况,最后x=1,所以当sum为奇数T获胜,否则HL获胜.</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码:"></a>代码:</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+50;int T,n,a[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        int sum=0,maxx=0;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],sum+=a[i],maxx=max(maxx,a[i]);        if(maxx&gt;sum-maxx)printf(&quot;T\n&quot;);        else         {            if(sum%2==1)printf(&quot;T\n&quot;);            else printf(&quot;HL\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-VPlOVJDi" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-VPlOVJDi"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1400</title>
    <link href="/2020/08/26/CodeForces-1400/"/>
    <url>/2020/08/26/CodeForces-1400/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称"><a href="#A-题目名称" class="headerlink" title="A.题目名称"></a>A.题目名称</h1><p> String Similarity </p><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>定义两个字符串相似：两个字符串中至少有一个位置的值相同。</p><p>现在给出一个长度为<strong>2n−1</strong>的字符串s，现在让你构造一个长度为n的字符串，使得这个字符串与s的所有长度为n的子串都相似。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>直接将s[n]输出n次</p><p><strong>ps</strong>：一开始想复杂了，认为cnt0的个数&gt;=n就全输出0，否则全输出1.实际上全输出s[n]就可以了。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e3+50;int T,n;char s[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        cin&gt;&gt;s+1;        int opt0=0;        for(int i=1;i&lt;=2*n-1;i++)            if(s[i]==&#39;0&#39;)                opt0++;        if(opt0&gt;=n)        {            for(int i=1;i&lt;=n;i++)cout&lt;&lt;&#39;0&#39;;cout&lt;&lt;endl;        }        else         {            for(int i=1;i&lt;=n;i++)cout&lt;&lt;&#39;1&#39;;cout&lt;&lt;endl;        }    }    return 0;}</code></pre><h1 id="B-题目名称"><a href="#B-题目名称" class="headerlink" title="B.题目名称"></a>B.题目名称</h1><p> RPG Protagonist </p><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p> 有两个人，一个人可以带p单位的重量，另一个人可以带f单位的重量，现在有两种物品，给出两种物品单件的重量以及两种物品的数量，求这两个人最多一共带走多少物品（数量最多）。</p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>首先保证第一个物品的重量比第二个更小。然后枚举第一个人选择第一个物品的数量（从0到cnt1），然后计算第一个人选择第二个物品的数量（注意判断条件一定要小于等于cnt2），然后贪心求得第二个人选择第一个物品的数量和第二个物品的数量。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+50;long long T,n,w1,w2,cnt1,cnt2,p,f;int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;p&gt;&gt;f&gt;&gt;cnt1&gt;&gt;cnt2&gt;&gt;w1&gt;&gt;w2;        if(w1&gt;w2)        {            swap(w1,w2);swap(cnt1,cnt2);        }        long long ans=0;        for(long long i=cnt1;i&gt;=0;i--)        {            if(p&lt;i*w1)continue;            long long ned1=(p-i*w1)/w2;            long long tot1=i+min(ned1,cnt2);            long long res1=cnt1-i,tot2=0,res2=cnt2-min(ned1,cnt2);            if(f&lt;=res1*w1)            {                tot2=f/w1;            }            else             {                long long ned2=(f-res1*w1)/w2;                tot2=res1+min(ned2,res2);            }            ans=max(tot1+tot2,ans);        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="C-题目名称"><a href="#C-题目名称" class="headerlink" title="C.题目名称"></a>C.题目名称</h1><p>Binary String Reconstruction </p><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>对于一个字符串s，通过以下规则构建字符串t。对于一个位置i，如果s[i-x]存在且s[i-x]=1或者s[i+x]存在且s[i+x]=1，那么t[i]=1,否则t[i]=1.现在给出串t，求串s。</p><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>从头开始，判断t[1]是0还是1，还确定s[i+x]，并且vis[i+x]标记为1，然后从2开始线性遍历。</p><p>如果t[i]==1：</p><p>​        if s[i-x]存在且为1则可以跳过；</p><p>​        else if s[i-x]存在但未遍历，则s[i-x]=1,标记一下；</p><p>​        else if s[i+x]存在但未遍历，则s[i+x]=1，标记一下；</p><p>​        else 无答案存在；</p><p>如果t[i]==0:</p><p>​        if s[i-x]存在 则它必须为0；</p><p>​        if s[i+x]存在 则它必须为0；</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+50;int T,x,vis[maxn];char s[maxn],a[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        memset(vis,0,sizeof(vis));        cin&gt;&gt;s+1;        int n=strlen(s+1);        cin&gt;&gt;x;        if(s[1]==&#39;1&#39;)a[1+x]=&#39;1&#39;;        else a[1+x]=&#39;0&#39;;        vis[1+x]=1;        int sign=0;        for(int i=2;i&lt;=n;i++)        {            if(s[i]==&#39;1&#39;)            {                if(i-x&gt;=1&amp;&amp;vis[i-x]&amp;&amp;a[i-x]==&#39;1&#39;)continue;                else if(i-x&gt;=1&amp;&amp;!vis[i-x])                {                    vis[i-x]=1;                    a[i-x]=&#39;1&#39;;                }                else if(i+x&lt;=n&amp;&amp;!vis[i+x])                 {                    vis[i+x]=1;                    a[i+x]=&#39;1&#39;;                }                else                 {                    sign=1;                    break;                }            }            else             {                if(i+x&lt;=n&amp;&amp;!vis[i+x])                {                    vis[i+x]=1;                    a[i+x]=&#39;0&#39;;                }                if(i-x&gt;=1&amp;&amp;!vis[i-x])                {                    vis[i-x]=1;                    a[i-x]=&#39;0&#39;;                }                if((i+x&lt;=n&amp;&amp;a[i+x]==&#39;1&#39;)||(i-x&gt;=1&amp;&amp;a[i-x]==&#39;1&#39;))                {                    sign=1;                    break;                }            }        }        for(int i=1;i&lt;=n;i++)if(!vis[i])a[i]=&#39;0&#39;;        if(sign)        {            printf(&quot;-1\n&quot;);        }        else         {            for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i];cout&lt;&lt;endl;        }    }    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D.题目名称："></a>D.题目名称：</h1><p>Zigzags </p><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给出一个数组，求满足以下条件的四元组（i，j，k，l）的个数。1&lt;=i&lt;j&lt;k&lt;l&lt;=n ai=ak&amp;&amp;aj=al</p><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>先枚举i与l的位置，则j和k一定在i和l之间，然后求i到l之间与i相同的数目res1和与l相同的数目res2，ans+=res1 <em> res2，注意如果ai==al则可能存在重复，需要去重ans-=res1。然后发现这种情况下，存在j与k顺序相反的情况。需要枚举i和j，让k在i和j之间，l在j之后，然后求得i与j之间和ai相等的总数res1，j之后与aj相等的数目res2，ans-=res1 </em> res2</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=3000+50;int T,n,a[maxn],sum[maxn][maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(a[i]==j)                {                    sum[i][j]=sum[i-1][j]+1;                }                else                 {                    sum[i][j]=sum[i-1][j];                }            }        }        long long ans=0;        for(int i=1;i&lt;=n;i++)        {            for(int l=i+3;l&lt;=n;l++)            {                long long res1=sum[l-1][a[l]]-sum[i][a[l]];                long long res2=sum[l-1][a[i]]-sum[i][a[i]];                ans+=res1*res2;                if(a[i]==a[l])                ans-=res1;            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=i+2;j&lt;=n-1;j++)            {                long long res1=sum[j-1][a[i]]-sum[i][a[i]];                long long res2=sum[n][a[j]]-sum[j][a[j]];                ans-=res1*res2;            //    if(a[i]==a[j])            //    ans+=res1;            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-KtacGClv" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KtacGClv"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1392</title>
    <link href="/2020/08/17/CodeForces-1392/"/>
    <url>/2020/08/17/CodeForces-1392/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称"><a href="#A-题目名称" class="headerlink" title="A.题目名称"></a>A.题目名称</h1><p>Omkar and Password </p><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>将任意两个相邻的大小不同的数字合并，问数组长度最小可以为多少？</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>每次将最大的和别的合并。如果所有都相同，长度为n；否则长度为1.</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+60;int T,n,a[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        int sign=0;        for(int i=2;i&lt;=n;i++)        {            if(a[i]!=a[i-1])            {                sign=1;                break;            }        }        if(sign)printf(&quot;1\n&quot;);        else printf(&quot;%d\n&quot;,n);    }    return 0;}</code></pre><h1 id="B-题目名称"><a href="#B-题目名称" class="headerlink" title="B.题目名称"></a>B.题目名称</h1><p>Omkar and Infinity Clock </p><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>在一个长度为n的数组中操作k次。每次操作选择最大的数字ai为d，然后用d-ai（1&lt;=i&lt;=n）。问k次操作后数组的数字。</p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>首先操作一次，记录数组，注意每次取maxx的初始值为-1e18，因为-1e9&lt;=ai&lt;=1e9，然后判断k-1的奇偶性，如果为偶就是该数组，否则再取maxx，然后maxx-ai，就是所求数组。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn=2e5+50;LL n,T,a[maxn],k;int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n&gt;&gt;k;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        LL maxx=-1e18;        for(int i=1;i&lt;=n;i++)maxx=max(maxx,a[i]);        k--;        for(int i=1;i&lt;=n;i++)a[i]=maxx-a[i];        if(k%2==0)        {            for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;        }        else         {            maxx=-1e18;            for(int i=1;i&lt;=n;i++)maxx=max(maxx,a[i]);            for(int i=1;i&lt;=n;i++)a[i]=maxx-a[i];            for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;        }    }    return 0;}</code></pre><h1 id="C-题目名称"><a href="#C-题目名称" class="headerlink" title="C.题目名称"></a>C.题目名称</h1><p>Omkar and Waterslide </p><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>将一串数字变成非递减，每次操作可以将一串连续的非递减数列都+1，问最少需要多少次操作？</p><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>对于a[i]&lt;=a[i+1],  不需要对a[i+1]进行操作；</p><p>对于a[i]&gt;a[i+1],需要将a[i+1]加到a[i]，即ans+=a[i+1]-a[i];</p><p>现在把a[i+1]加到和a[i]一样大，a[i+1]就可以和a[i]一起操作，所以当a[i]&gt;=a[i-1]的时候，a[i+1]也会跟着加。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+50;long long T,n,a[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        long long ans=0;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        for(int i=1;i&lt;n;i++)        ans+=max(0ll,a[i]-a[i+1]);        cout&lt;&lt;ans&lt;&lt;endl;    }}</code></pre><h2 id="思路-2："><a href="#思路-2：" class="headerlink" title="思路-2："></a>思路-2：</h2><p>这是比赛时候的时候，写得特别麻烦，对于a[i]&gt;a[i+1]的直接将ans+=a[i]-a[i+1],记录一串不符合条件（非递减）的数列的最大值maxx，一旦遇到a[i]&gt;a[i-1],ans+=a[i]-maxx，因为之前的已经非递减了，只要加到a[i]就好了，最后这一串数列结束，ans+=a[opt-1]-maxx，即加到刚好非递减</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=2e5+50;long long T,n,a[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        long long opt=2,ans=0;        while(opt&lt;=n)        {            if(a[opt-1]&gt;a[opt])            {                long long now=opt,maxx=a[opt],minn=a[opt];                if(a[now+1]&gt;a[opt-1])                {                    ans+=a[opt-1]-a[opt];                    opt=now+1;                }                else                 {                    now=opt+1;                    while(now&lt;=n&amp;&amp;a[now]&lt;a[opt-1])                    {                        if(a[now-1]&gt;a[now])                        {                            ans+=a[now-1]-a[now];                        }                        else if(a[now]&gt;a[now-1])                        {                            if(a[now]&gt;maxx)                            {                                ans+=a[now]-maxx;                                maxx=a[now];                            }                        }                        now++;                    }                    ans+=a[opt-1]-maxx;                    opt=now;                }            }            else opt++;        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-题目名称"><a href="#D-题目名称" class="headerlink" title="D.题目名称"></a>D.题目名称</h1><p>Omkar and Bed Wars</p><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p> 一个人同时被左右两两边的人攻击，或者左右两边的人都没攻击他，那他可随便攻击一个人。一个人若只被一个人攻击，他就要攻击回去。问如何该边人的攻击，使得用最少的改变次数，使得攻击符合条件。</p><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>当a[j-1]=R,a[j]=R,a[j+1]=R的时候对于a[j]的攻击就不符合条件；当a[j-1]=L,a[j]=L,a[j+1]=L的时候对于a[j]的攻击也是不符合条件。因此要时候没有&gt;=3的连续L/R出现。</p><p>当全是L/R的时候答案就是(n+2)/3;</p><p>然后将所有的连续子串加入数组中，判断s[1]与s[n],如果s[1]=s[n]，就要就首尾合并，最后ans+=a[i]/3;</p><h2 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+50;int n,T;char s[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        vector&lt;int&gt;a;        cin&gt;&gt;n;        cin&gt;&gt;s+1;        int sign=0;        for(int i=2;i&lt;=n;i++)        {            if(s[i-1]!=s[i])            {                sign=1;                break;            }        }        if(sign==0)        {            cout&lt;&lt;(n+2)/3&lt;&lt;endl;            continue;        }        sign=1;        for(int i=2;i&lt;=n+1;i++)        {            if(s[i]!=s[i-1])            {                a.push_back(sign);                sign=1;            }            else                 sign++;        }        if(s[1]==s[n])        {            a[0]+=a[a.size()-1];            a.pop_back();        }        int ans=0;        for(int i=0;i&lt;a.size();i++)ans+=a[i]/3;        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-arOBufDj" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-arOBufDj"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1394</title>
    <link href="/2020/08/13/CodeForces-1394/"/>
    <url>/2020/08/13/CodeForces-1394/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称"><a href="#A-题目名称" class="headerlink" title="A.题目名称"></a>A.题目名称</h1><p> Boboniu Likes to Color Balls </p><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>r个红球，g个绿球，b个蓝球，w个白球。可以任意次将一个红球和一个绿球和一个蓝球都转化成白球。是否可以组成回文色？</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>当偶数色的数目&gt;=3则一定可以。若只有一个偶数色，则红绿蓝都至少有一个就可以。其余的都是不可以的。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;long long T,a,b,c,d;int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;        int tot=0;        if(a%2==0)tot++;        if(b%2==0)tot++;        if(c%2==0)tot++;        if(d%2==0)tot++;        if(tot&gt;=3||tot==0)        {            printf(&quot;Yes\n&quot;);        }        else         {            if(tot==1)            {                if(a&gt;=1&amp;&amp;b&gt;=1&amp;&amp;c&gt;=1)printf(&quot;Yes\n&quot;);                else printf(&quot;No\n&quot;);            }            else printf(&quot;No\n&quot;);        }    }    return 0;}</code></pre><h1 id="B-题目名称"><a href="#B-题目名称" class="headerlink" title="B.题目名称"></a>B.题目名称</h1><p>Boboniu Plays Chess </p><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>n*m的棋盘，初始位置在非边界处，每次可以移动到同一行或者同一列未到过的位置上。请输出符合情况的答案。</p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>先左平移到边界，在从初始位置的右边开始右平移到边界，然后列下标依次减小，对于行下标一开始是由小到大，再由大到小，交替进行，类似于S线。注意开始的初始位置所在的行不可以经过。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,si,sj;int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;si&gt;&gt;sj;    int j=sj;    while(sj!=0)    {        printf(&quot;%d %d\n&quot;,si,sj);        sj--;    }    sj=j+1;    while(sj&lt;=m)    {        printf(&quot;%d %d\n&quot;,si,sj);        sj++;    }    sj=m;    int now=1;    for(j=m;j&gt;=1;j--)    {        if(now%2==1)        {            for(int i=1;i&lt;=n;i++)            {                if(i==si)continue;                printf(&quot;%d %d\n&quot;,i,j);            }                now++;        }        else         {            for(int i=n;i&gt;=1;i--)            {                if(i==si)continue;                printf(&quot;%d %d\n&quot;,i,j);            }            now++;        }    }    return 0;}</code></pre><h1 id="C-题目名称"><a href="#C-题目名称" class="headerlink" title="C.题目名称"></a>C.题目名称</h1><p>Boboniu and Bit Operations </p><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>a[]（长度为n）,b[]（长度为m），对于每一个ai（1&lt;=i&lt;=n）选择一个bj，ci=ai&amp;bj。求能得到的最小的c1|c2|…|cn。</p><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>观察到0&lt;=ai&lt;2^9,所以最大的答案就是2^10 - 1.直接从小到大枚举答案，能符合的最小的就是所求答案。接下来就是如何进行判定了：对于所枚举的答案，需要让a[]与所有b[]进行操作，一旦存在ci|mid&lt;=mid说明当前ai是符合的，如果不存在就说明枚举的答案是不对的。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+5;int n,m,a[maxn],b[maxn],c[maxn];bool check(int mid){    memset(c,0,sizeof(c));    for(int i=1;i&lt;=n;i++)    {        int sign=0;        for(int j=1;j&lt;=m;j++)        {            c[i]=a[i]&amp;b[j];            if((c[i]|mid)&lt;=mid)            {                sign=1;                break;            }        }        if(!sign)return 0;    }    return 1;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    for(int i=1;i&lt;=m;i++)cin&gt;&gt;b[i];    sort(a+1,a+1+n);sort(b+1,b+1+m);    int l=0,r=pow(2,10),ans=0;    for(int i=0;i&lt;=pow(2,10);i++)    {        if(check(i))        {            cout&lt;&lt;i&lt;&lt;endl;            return 0;        }    }}</code></pre><h1 id="D-题目名称"><a href="#D-题目名称" class="headerlink" title="D.题目名称"></a>D.题目名称</h1><p>Boboniu Chats with Du </p><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>Du可以在群里聊天n天，如果Du当前选择ai&gt;m（Boboniu的恒定心情值），则Du会被禁言d天，问最大的ai的和。</p><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>将a[]由小到大排序，可以枚举ai&lt;=m的个数，然后利用前缀和得到ai&lt;=m的和（肯定优先选择大的），剩下的天数就是发一次言就会被禁言，一次发言的耗费就是d+1天，注意求次数时候向上取整，这里也是前缀和。</p><p><strong>ps</strong>：千万别忘了枚举天数别忘了枚举0天的情况！</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=1e5+50;long long n,d,m,a[maxn],sum[maxn],sum2[maxn];int main(){    cin&gt;&gt;n&gt;&gt;d&gt;&gt;m;    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    sort(a+1,a+1+n);    long long opt=n+1;    for(long long i=1;i&lt;=n;i++)    {        if(a[i]&lt;=m)continue;        else         {            opt=i;            break;        }    }    for(long long i=1;i&lt;=opt-1;i++)sum[i]=sum[i-1]+a[i];    long long t=0;    for(long long i=n;i&gt;=opt;i--)sum2[++t]=sum2[t-1]+a[i];    long long ans=0;    for(long long i=min(n,opt-1);i&gt;=0;i--)    {        long long tot=sum[opt-1]-sum[opt-1-i];        long long res=n-i;        long long c=ceil(res*1.0/(1+d)*1.0);        tot+=sum2[c];        ans=max(ans,tot);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-sGWpmzsg" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-sGWpmzsg"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1391</title>
    <link href="/2020/08/10/CodeForces-1391/"/>
    <url>/2020/08/10/CodeForces-1391/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A.题目名称："></a>A.题目名称：</h1><p>Suborrays</p><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求一个长度为n的序列，保证任意区间[i,j]之间a[i]|a[i+1]|…|a[j]&gt;=i-j+1.</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>直接按序输出1 - n一定是符合的。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int T,n;int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++)cout&lt;&lt;i&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B.题目名称："></a>B.题目名称：</h1><p> Fix You </p><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>一个(n,m)的矩阵，每一个单位格上有‘D’，‘R’，‘D’：向下移动一格，‘R’：向右移动一格。对于任意位置上的物品需要保证它可以运动到(n,m)，一旦出界就失败了。问至少要改变几个单位格？</p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>真正有影响的是最后一行和最后一列。若最后一行还有‘D’一定不符合条件，必须改成‘R’；若最后一列还有‘R’一定不符合条件，必须改成‘D’。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+50;int T,n,m;char s[maxn][maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i]+1;        int ans=0;        for(int i=1;i&lt;=m;i++)            if(s[n][i]==&#39;D&#39;)ans++;        for(int i=1;i&lt;=n;i++)            if(s[i][m]==&#39;R&#39;)ans++;        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C.题目名称："></a>C.题目名称：</h1><p> Cyclic Permutations </p><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>长度为n的序列中的数字各不相同。<br>对于每一个i，找到一个最大的j(j<i)使得pj>pi，i与j之间连一条无向边；<br>对于每一个i，找到一个最小的(j&gt;i)使得pj&gt;pi，i与j之间连一条无向边。<br>问当一个序列n存在环的时候，一共有多少种排列组合。</p><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>根据所给的例子知：只要存在一个i，若左边依次递增，右边依次递减，则不符合要求。可以考虑全排列组合的总数-不符合条件的总数。现在求不符合要求的：最大的数字n有n个可选择位置，总数之之和为</p><script type="math/tex; mode=display">C_n^0+C_n^1+C_n^2+....+C_n^{n-1}</script><p>实际上就是2^(n-1)。答案就是：n！-2^(n-1)</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+50;const int Mod=1e9+7;int n;long long p[maxn];int main(){    cin&gt;&gt;n;    long long ans=1;    for(long long i=1;i&lt;=n;i++)        {        ans=ans*i%Mod;    }    long long ans1=1;    for(int i=1;i&lt;=n-1;i++)ans1=(ans1*2)%Mod;    ans=(ans-ans1+Mod)%Mod;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D.题目名称："></a>D.题目名称：</h1><p> 505 </p><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>对于一个二进制矩阵，使得它是一个  <strong>good</strong>  <strong>matrix</strong> （任意的偶数边的正方形内有奇数个1）.问使得它成为<strong>good matrix</strong>需要该边多少次？如果无法称为<strong>good matrix</strong>则输出-1</p><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>保证n&lt;=m.若n&gt;=4一定不符合，4 <em> 4的方阵包含4个2 </em> 2，4个奇数相加一定是偶数。所以不符合。n==1的一定是0，即始终符合。现在主要讨论n==2，n==3的情况。</p><p>n==2：看每一列的1个数%2，统计奇偶性与列下标不对应的总数，答案就是min（ans，m-ans）</p><p>n==3：dp[l][i][j][k]表示第l列的三行数字依次为k、j、i的时候需要改变的总数。先初始化为1e9，第一列的每种情况进行列举。然后从第二列开始枚举，依次枚举当前列的三行数字，和上一列的三行数字，并且保证任意2*2的都是奇数个1（即((j+k+jj+kk)&amp;1)&amp;&amp;((i+ii+j+jj)&amp;1)），得到当前列数字为i，j，k需要改变的次数，更新方程。</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+50;int n,m;int dp[maxn][2][2][2],a[4][maxn];int main(){    cin&gt;&gt;n&gt;&gt;m;    if(n&gt;m)swap(n,m);    if(n&gt;=4)    {        printf(&quot;-1\n&quot;);        return 0;    }    if(n==1)    {        printf(&quot;0\n&quot;);        return 0;    }    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=m;j++)        {            char c;cin&gt;&gt;c;            a[i][j]=c-&#39;0&#39;;        }    }    if(n==2)    {        int ans=0;        for(int i=1;i&lt;=m;i++)        {            int tot=0;            if(a[1][i]==1)tot++;            if(a[2][i]==1)tot++;            tot%=2;            if(tot!=i%2)ans++;        }        cout&lt;&lt;min(ans,m-ans)&lt;&lt;endl;    }    if(n==3)    {        for(int i=0;i&lt;=1;i++)        {            for(int j=0;j&lt;=1;j++)            {                for(int k=0;k&lt;=1;k++)                {                    dp[1][i][j][k]=3-(a[3][1]==i)-(a[2][1]==j)-(a[1][1]==k);                    for(int l=2;l&lt;=m;l++)dp[l][i][j][k]=1e9;                }            }        }        for(int l=2;l&lt;=m;l++)        {            for(int i=0;i&lt;=1;i++)            {                for(int j=0;j&lt;=1;j++)                {                    for(int k=0;k&lt;=1;k++)                    {                        for(int ii=0;ii&lt;=1;ii++)                        {                            for(int jj=0;jj&lt;=1;jj++)                            {                                for(int kk=0;kk&lt;=1;kk++)                                {                                    if(((j+k+jj+kk)&amp;1)&amp;&amp;((i+ii+j+jj)&amp;1))                                    {                                        int ans=3-(a[3][l]==i)-(a[2][l]==j)-(a[1][l]==k);                                        dp[l][i][j][k]=min(dp[l][i][j][k],dp[l-1][ii][jj][kk]+ans);                                    }                                }                            }                        }                    }                }            }        }        int ans=1e9;        for(int i=0;i&lt;=1;i++)        {            for(int j=0;j&lt;=1;j++)            {                for(int k=0;k&lt;=1;k++)                {                    ans=min(ans,dp[m][i][j][k]);                }            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-KbGqJKuz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KbGqJKuz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1393</title>
    <link href="/2020/08/08/CodeForces-1393/"/>
    <url>/2020/08/08/CodeForces-1393/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称"><a href="#A-题目名称" class="headerlink" title="A.题目名称"></a>A.题目名称</h1><p>Rainbow Dash, Fluttershy and Chess Coloring</p><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个正方形区域上色，要求上色的块相邻之间不能相同，也就是我们会在每回合上不同的颜色，要求上色的块邻边是边界或是上一个以上色的块。求至少要多少个回合才能把这个正方形区域完。 </p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>第一个回合，我们只能在边界的块上上色，且 要间隔开一格子上色，那么我们至少可以把边界的一半给上完，那么在下个回合，我们用不同的颜色上色自然可以把最外面的边界给上完。依次这样， 所以我们还是按着之前的块相邻来填，我们发现，进行完这个回合我们的区域和上个回合的是一样的，只不过长度减了2，我们每次进行这种回合都会这样子，那么我们对边长n/2即可，最后再加1.</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;long long T,n;int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        long long ans=n/2+1;        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="B-题目名称"><a href="#B-题目名称" class="headerlink" title="B.题目名称"></a>B.题目名称</h1><p>Applejack and Storages</p><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>小马们想做一个方形的和矩形的马厩，每个马厩需要四块木板。现在家具场有一些木板，每次回增加或者减少一个木板。问每次增加或者减少的时候能不能符合要求早出一个方形和一个矩形的马厩。</p><h2 id="比赛思路："><a href="#比赛思路：" class="headerlink" title="比赛思路："></a>比赛思路：</h2><p>tot[]记录a[i]的个数，cnt[]记录tot[x]的数量。在q个查询中，依次更新tot[],cnt[]。如果cnt[2]和cnt[3]的数量&gt;=2&amp;&amp;cnt[4],cnt[5],cnt[6],cnt[7]任意存在一个，则符合条件。如果cnt[2],cnt[3]任意存在一个&amp;&amp;cnt[6],cnt[7]任意存在一个，则符合条件。如果cnt[4]+cnt[5]+cnt[6]+cnt[7]的数量&gt;=2则符合条件，如果存在一个tot[x]&gt;=8则符合条件。其余都不符合。</p><h2 id="比赛代码："><a href="#比赛代码：" class="headerlink" title="比赛代码："></a>比赛代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int a[maxn],n,tot[maxn],q,cnt[maxn],t,vis[maxn];int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],tot[a[i]]++;    for(int i=1;i&lt;=1e5;i++)    {        if(tot[i]==0)continue;        cnt[tot[i]]++;        if(tot[i]&gt;=8)t++;    }    cin&gt;&gt;q;    for(int i=1;i&lt;=q;i++)    {        char c;int x;        cin&gt;&gt;c&gt;&gt;x;        if(c==&#39;+&#39;)        {            cnt[tot[x]]--;            tot[x]++;            cnt[tot[x]]++;            if(tot[x]==8)t++;        }        else         {            if(tot[x]==8)t--;            cnt[tot[x]]--;            tot[x]--;            cnt[tot[x]]++;        }        if((cnt[2]+cnt[3]&gt;=2)&amp;&amp;(cnt[4]||cnt[5]||cnt[6]||cnt[7]))        {            printf(&quot;YES\n&quot;);            continue;        }        if((cnt[2]||cnt[3])&amp;&amp;(cnt[6]||cnt[7]))        {            printf(&quot;YES\n&quot;);            continue;        }        if(cnt[4]+cnt[5]+cnt[6]+cnt[7]&gt;=2)        {            printf(&quot;YES\n&quot;);            continue;        }        if(t)        {            printf(&quot;YES\n&quot;);            continue;        }        printf(&quot;NO\n&quot;);        continue;    }    return 0;}</code></pre><h2 id="优化思路："><a href="#优化思路：" class="headerlink" title="优化思路："></a>优化思路：</h2><p>维护一个fangnum和一个junum，然后当木板增加减少到了边界的时候，就进行一次判断，更新fangnum和junum的数量，最后通过fangnum和junum判断是否能够成功搭建。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+50;int n,a[maxn],q,fangnum,junum,tot[maxn];int main(){    cin&gt;&gt;n;    int maxx=0;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],maxx=max(maxx,a[i]),tot[a[i]]++;    for(int i=1;i&lt;=maxx;i++)    {        fangnum+=tot[i]/4;        junum+=tot[i]/2;    }    cin&gt;&gt;q;    for(int i=1;i&lt;=q;i++)    {        char c;int x;        cin&gt;&gt;c&gt;&gt;x;        if(c==&#39;+&#39;)        {            tot[x]++;            if(tot[x]%4==2)            {                junum++;            }            if(tot[x]%4==0)            {                fangnum++;                junum++;            }        }        else         {            if(tot[x]%4==2)            {                junum--;            }            if(tot[x]%4==0)            {                fangnum--;                junum--;            }            tot[x]--;        }        if(fangnum&gt;=2||(fangnum&gt;=1&amp;&amp;(junum-fangnum*2)&gt;=2))        {            printf(&quot;YES\n&quot;);        }        else         {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre><h1 id="C-题目名称"><a href="#C-题目名称" class="headerlink" title="C.题目名称"></a>C.题目名称</h1><p>Pinkie Pie Eats Patty-cakes</p><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给你一些数字，让你把这些数字尽可能的分散开来，问两个相同数字的最小间距的最大值是多少。 </p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>用tot[]统计a[i]的数量，并且将a[i]重新排序，相同的排一起，数量多的排在前面。然后就是二分，判断条件就是x=x+mid+1，x&gt;n就不符合。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn],T,n,vis[maxn];struct node{    int t,id;}tot[maxn];int maxx=0;bool check(int mid){    for(int i=1;i&lt;=maxx;i++)    {        if(tot[i].t==0)break;        int x=i;        for(int j=2;j&lt;=tot[i].t;j++)        {            x=x+mid+1;            if(x&gt;n)return 0;        }    }    return 1;}int cmp(node x,node y){    return x.t&gt;y.t;}int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        maxx=0;        memset(tot,0,sizeof(tot));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],tot[a[i]].t++,tot[a[i]].id=a[i],maxx=max(maxx,a[i]);        sort(tot+1,tot+1+maxx,cmp);        int now=0;        for(int i=1;i&lt;=maxx;i++)        {            if(tot[i].t==0)break;            for(int j=1;j&lt;=tot[i].t;j++)            {                a[++now]=tot[i].id;            }        }        int l=0,r=n,ans=0;        while(l&lt;=r)        {            int mid=(l+r)/2;            if(check(mid))            {                l=mid+1;                ans=mid;            }            else             {                r=mid-1;            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-题目名称"><a href="#D-题目名称" class="headerlink" title="D.题目名称"></a>D.题目名称</h1><p> Rarity and New Dress </p><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>小红有强迫症，她必须要方形的裙子，但是必须是旋转45度的那种方形，并且裙子的颜色必须一样。 </p><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>对于每一个位置我们设dp[i][j]为位置[i][j]向上能最多”延申“的”斜正方形边长“，那么总的答案就是所有位置的dp值之和。转移分为当前位置[i][j]与上面四个位置（[i-1][j]、[i-1][j-1]、[i-1][j+1]、[i-2][j]）能否形成“斜正方形”：  若能，则取min（dp[i-1][j-1]、dp[i-1][j+1]、dp[i-2][j]）+1，这里可以简单画个图理解一下当前[i][j]高度的“延申”只是依赖于这三个位置的dp值， 若不能则dp[i][j]=1.</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=2000+50;long long n,m,dp[maxn][maxn];char a[maxn][maxn];int main(){    cin&gt;&gt;n&gt;&gt;m;    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i]+1;    long long ans=0;    for(long long i=1;i&lt;=n;i++)    {        for(long long j=1;j&lt;=m;j++)        {            if(i-1&lt;1||i-2&lt;1||j-1&lt;1|j+1&gt;m||a[i-1][j]!=a[i][j]||a[i-1][j-1]!=a[i][j]||a[i-1][j+1]!=a[i][j]||a[i-2][j]!=a[i][j])                dp[i][j]=1;            else                 dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),min(dp[i-1][j+1],dp[i-2][j]))+1;            ans+=dp[i][j];        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-LqWaCrAK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LqWaCrAK"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1388</title>
    <link href="/2020/07/31/CodeForces-1388/"/>
    <url>/2020/07/31/CodeForces-1388/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A.题目名称："></a>A.题目名称：</h1><p> Captain Flint and Crew Recruitment </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>如果一个数 x能够表示成两个不同质数的乘积，那我们就称 x是 <strong>nearly prime</strong> 。给出n，求n能否分成4个不同正整数的和，其中至少三个是 <strong>nearly prime</strong> </p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先可以取得最小的三个 <strong>nearly prime</strong>：6，10，14。如果n&lt;=30那么肯定无法得到符合要求的组合。如果n&gt;=45则至少都有6，10，14，所以一定可以得到符合要求的组合。问题就是30&lt;n&lt;45之间的情况，只需要单独分析x=6/10/14（x=n-30）的情况。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int T,n;int main(){    cin&gt;&gt;T;    while(T--){        cin&gt;&gt;n;        if(n&lt;=30)        {            printf(&quot;NO\n&quot;);            continue;        }        if(n&gt;=45)        {            printf(&quot;YES\n&quot;);            printf(&quot;6 10 14 %d\n&quot;,n-30);            continue;        }        else         {            int a=6,b=10,c=14,x=n-30;            if(x==6)            {                a=5,b=6,c=10,x=15;            }            if(x==10)            {                c=21;x=3;            }            if(x==14)            {                c=21;x=7;            }            printf(&quot;YES\n&quot;);            printf(&quot;%d %d %d %d\n&quot;,a,b,c,x);        }    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B.题目名称："></a>B.题目名称：</h1><p> Captain Flint and a Long Voyage </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个n，求得一个n位的十进制数x，将x转换成二进制数，并且去掉最后n位，要求这个去掉n位的二进制的数最大，问x的最小可能值。</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>所有数字都为9，4个二进制位为一组，若一组中全为0则十进制写为8，其余正常转换。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500000+1000;int T,n,a[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        int tot=0;        for(int i=1;i&lt;=n;i++)        {            a[++tot]=1;a[++tot]=0;a[++tot]=0;a[++tot]=1;        }        for(int i=tot;i&gt;=tot-n+1;i--)        {            a[i]=0;        }        for(int i=1;i&lt;=tot;i+=4)        {            int x=a[i];            x*=2;x+=a[i+1];            x*=2;x+=a[i+2];            x*=2;x+=a[i+3];            if(x==0)x=8;            cout&lt;&lt;x;        }        cout&lt;&lt;endl;    }}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C.题目名称："></a>C.题目名称：</h1><p> Uncle Bogdan and Country Happiness </p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出一棵树，每个节点给出最终的人数、最终的心情值。每个人从1号节点出发，在路上可能有些人心情会从good变成bad。每个人沿着最短路径回到自己的节点，求每个节点给出的心情值是否可能都是准确的。（心情值=good人数-bad人数） </p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>先dfs求得每一个结点经过的总的人数。再dfs求每一个结点所有经过这个结点的人中good的人数和bad的人数。即：good[]+bad[]=p[]，good[]-bad[]=h[]。所以good[]=（p[]+h[])/2,bad[]=(p[]-good[]).如果一个结点的good[]+bad[]!=p[]||good[]-bad[]!=h[]||good[]<0|bad[]<0那么这个结点的心情值就是错误的。然后更新子节点，注意要统计子节点的总的bad的人数。如果当前结点的bad[]-t[] (最终节点的人数)>tot(子节点的bad总数)说明这个组合是错的。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+50;struct node{    int to,next;}edge[maxn*2];int k=1,head[maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int p[maxn],h[maxn],p1[maxn],p2[maxn],T,t[maxn];void dfs1(int u,int f){    for(int i=head[u];i;i=edge[i].next)    {        if(edge[i].to==f)continue;        dfs1(edge[i].to,u);        p[u]+=p[edge[i].to];    }}int sign=0;void dfs2(int u,int f){    p1[u]=(p[u]+h[u])/2,p2[u]=p[u]-p1[u];    if(p1[u]+p2[u]!=p[u]||p1[u]-p2[u]!=h[u]||p1[u]&lt;0||p2[u]&lt;0)sign=1;    int tot=0,son=0;    for(int i=head[u];i;i=edge[i].next)    {        if(edge[i].to==f)continue;        dfs2(edge[i].to,u);        tot+=p2[edge[i].to];        son=1;    }    if(p2[u]-t[u]&gt;tot&amp;&amp;son)sign=1;}int main(){    cin&gt;&gt;T;    while(T--)    {        int n,m;        cin&gt;&gt;n&gt;&gt;m;        sign=0;k=1;memset(head,0,sizeof(head));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;p[i],t[i]=p[i];        for(int i=1;i&lt;=n;i++)cin&gt;&gt;h[i];        for(int i=1;i&lt;n;i++)        {            int u,v;            cin&gt;&gt;u&gt;&gt;v;            add(u,v);add(v,u);        }        dfs1(1,1);        dfs2(1,1);        if(sign)printf(&quot;NO\n&quot;);        else printf(&quot;YES\n&quot;);    }}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D.题目名称："></a>D.题目名称：</h1><p> Captain Flint and Treasure </p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出长度为n的a数组和b数组，一共操作n次（每个位置必须操作一次），若第i次选定位置i，则<code>ans+=a[i]</code>，并且如果<code>b[i]!=-1</code> <code>a[b[i]]+=a[i]</code>，确定一个操作顺序使得取出的ans最大，并输出操作顺序。 </p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>对于b[i]!=-1的则可以i—-&gt;b[i]引一条边。然后进行拓扑排序，如果当前节点的值大于0，则加到下一个节点中，否则就不加入（加了反而使得答案更小），最后按照拓扑排序的顺序输出。（节点值&lt;0的倒序输出防止叠加）</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt; using namespace std;const int maxn=2e5+50;struct node{    long long to,next;}edge[maxn];long long k=1,head[maxn];void add(long long u,long long v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}long long n,a[maxn],b[maxn],rd[maxn],f[maxn],opt,ans,dp[maxn];void Topsort(){    queue&lt;long long&gt;q;    for(long long i=1;i&lt;=n;i++)    dp[i]=a[i];    for(long long i=1;i&lt;=n;i++)        if(!rd[i])            q.push(i);    while(!q.empty())    {        long long x=q.front();q.pop();        f[++opt]=x;ans+=dp[x];        for(long long i=head[x];i;i=edge[i].next)        {            rd[edge[i].to]--;            dp[edge[i].to]+=max(0ll,dp[x]);            if(!rd[edge[i].to])            q.push(edge[i].to);        }    }}int main(){    cin&gt;&gt;n;    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;b[i];    for(long long i=1;i&lt;=n;i++)    {        if(b[i]==-1)continue;        add(i,b[i]);        rd[b[i]]++;    }    opt=0;    Topsort();    cout&lt;&lt;ans&lt;&lt;endl;    for(long long i=1;i&lt;=n;i++)if(dp[f[i]]&gt;0)cout&lt;&lt;f[i]&lt;&lt;&#39; &#39;;    for(long long i=n;i&gt;=1;i--)if(dp[f[i]]&lt;=0)cout&lt;&lt;f[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;}</code></pre>        <div id="aplayer-neWvzxWP" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-neWvzxWP"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kuangbin专题14-数论基础</title>
    <link href="/2020/07/29/kuangbin%E4%B8%93%E9%A2%9814-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/29/kuangbin%E4%B8%93%E9%A2%9814-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-题目名称："><a href="#1-题目名称：" class="headerlink" title="1.题目名称："></a>1.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1370" target="_blank" rel="noopener"><strong>LightOJ 1370</strong></a> Bi-shoe and Phi-shoe</p><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给出n个数字的序列a[]，对于每个数字ai找到一个欧拉函数值大于等于ai的数bi，求找到的所有数bi的最小值之和sum </p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>已知a[]&lt;=1000000,要求得phi[]，则应当线性求phi。</p><p>1.phi(p) == p-1 因为素数p除了1以外的因子只有p，所以与 p 互素的个数是 p - 1个 </p><p>2.phi(p^k) == p^k - p^(k-1) == (p-1) * p^(k-1) </p><p>3.如果i mod p == 0, 那么 phi(i <em> p) == p </em> phi(i)  </p><p>4.如果i mod p != 0, 那么 phi(i <em> p) == phi(i) </em> (p-1)  </p><p>求得phi[]之后，就寻找大于等于a[i]的最小的phi[]的下标，求和。</p><p><strong>PS</strong>：WA了很多次：a[]&lt;=1000000,但是phi[]可能&gt;1000000</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000+100;int vis_prime[maxn],prime[maxn],phi[maxn],T,n,a[maxn],tot;void get_phi(){    phi[1]=0;    for(long long i=2;i&lt;=1000020;i++)//WA了无数次，a[]&lt;=1000000,phi[]则可能&gt;1000000     {        if(!vis_prime[i])        {            prime[++tot]=i;            phi[i]=i-1;        }        for(long long j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=1000020;j++)        {            vis_prime[i*prime[j]]=1;            if(i%prime[j]==0)            {                phi[i*prime[j]]=phi[i]*j;                break;            }            else             {                phi[i*prime[j]]=phi[i]*phi[prime[j]];            }        }    }}int main(){    cin&gt;&gt;T;    get_phi();    long long cnt=0;    while(T--)    {        cnt++;        cin&gt;&gt;n;        for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        long long ans=0;        sort(a+1,a+1+n);        long long opt=1;        for(long long i=1;i&lt;=n;i++)        {            while(phi[opt]&lt;a[i])opt++;            ans+=opt;        }        printf(&quot;Case %lld: %lld Xukha\n&quot;,cnt,ans);    }    return 0;}</code></pre><h1 id="2-题目名称："><a href="#2-题目名称：" class="headerlink" title="2.题目名称："></a>2.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1356" target="_blank" rel="noopener"><strong>LightOJ 1356</strong></a> Prime Independence</p><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给出n个数，找出一个最大素数独立子集，如果a=b*一个素数，那么认为a是b的一个素数乘级，如果一个集合不存在一个数是另一个数的素数乘级，那么这就是素数独立子集。 </p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>预处理出500000内的素数，对于a[i]可以得到a[i]*prime[j]对应的a[]的下标pos[]，这样i与pos[]就是存在关系：二者不可能在一个集合中。因此可以用二分图的做法，若两个数字之间存在素数倍数，则相连接，注意这里应该双向连接，因为两个互相有关系。最后n-最大匹配，求出最大独立集合。</p><p><strong>ps</strong>：匈牙利算法过不了，需要<strong>hopcroft-karp</strong>，但是我的板子好像错了QAQ</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=40000+50;const int maxm=500000+50;int a[maxn],T,n,dis;vector&lt;int&gt;G[maxn];int k=1,um[maxn],vm[maxn],dx[maxn],dy[maxn],prime_tot,prime[maxm],vis_prime[maxm],pos[maxm],vis[maxm];void isprime(){    for(int i=2;i&lt;=500000;i++)    {        if(!vis_prime[i])        {            prime[++prime_tot]=i;        }        for(int j=1;j&lt;=prime_tot&amp;&amp;prime[j]*i&lt;=500000;j++)        {            vis_prime[prime[j]*i]=1;            if(i%prime[j]==0)            break;        }    }}bool searchP() {    queue&lt;int&gt; q;    dis=0x3f3f3f3f;    memset(dx,-1,sizeof(dx));    memset(dy,-1,sizeof(dy));    unsigned short Head=0,Tail=0;    for(int i=1; i&lt;=n; i++)        if(um[i]==-1) {            q.push(i);            dx[i]=0;        }    while(!q.empty()) {        int u=q.front();        q.pop();        if(dx[u]&gt;dis)  break;        for(int i=0; i&lt;G[u].size(); i++) {            int v = G[u][i];            if(dy[v]==-1) {                dy[v]=dx[u]+1;                if(vm[v]==-1)  dis=dy[v];                else {                    dx[vm[v]]=dy[v]+1;                    q.push(vm[v]);                }            }        }    }    return dis!=0x3f3f3f3f;}bool dfs(int u) {    for(int i=0; i&lt;G[u].size(); i++) {        int v = G[u][i];        if(!vis[v]&amp;&amp;dy[v]==dx[u]+1) {            vis[v]=1;            if(vm[v]!=-1&amp;&amp;dy[v]==dis) continue;            if(vm[v]==-1||dfs(vm[v])) {                vm[v]=u;                um[u]=v;                return 1;            }        }    }    return 0;}int maxMatch() {    int res=0;    memset(um,-1,sizeof(um));    memset(vm,-1,sizeof(vm));    while(searchP()) {        memset(vis,0,sizeof(vis));        for(int i=1; i&lt;=n; i++)            if(um[i]==-1&amp;&amp;dfs(i))  res++;    }    return res;}int main(){    cin&gt;&gt;T;    isprime();    int opt=0;    while(T--)    {        opt++;        k=1;        scanf(&quot;%d&quot;,&amp;n);        memset(pos,0,sizeof(pos));        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            pos[a[i]]=i;            G[i].clear();        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=prime_tot&amp;&amp;(long long)prime[j]*a[i]&lt;=500000;j++)            {                if(pos[a[i]*prime[j]])                {                    G[i].push_back(pos[a[i]*prime[j]]);G[pos[a[i]*prime[j]]].push_back(i);                }            }        }        printf(&quot;Case %d: %d\n&quot;,opt,n-maxMatch()/2);    }    return 0;}</code></pre><h1 id="3-题目名称："><a href="#3-题目名称：" class="headerlink" title="3.题目名称："></a>3.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1341" target="_blank" rel="noopener"><strong>LightOJ 1341</strong></a> Aladdin and the Flying Carpet</p><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一对数字 a，b 。其中，a表示一个矩形的面积，想知道有多少种整数的边的组合可以组成面积为a的矩形，而且要求矩形的最短的边不得小于b </p><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>一个大于1的正整数N，如果它的标准分解式为：   <img src="http://h.hiphotos.baidu.com/baike/s%3D124/sign=ae84eec8b4fd5266a32b38169f189799/f703738da97739129c546742fa198618367ae2a7.jpg" alt="img"> ， 那么它的正因数个数为   <img src="http://b.hiphotos.baidu.com/baike/s%3D238/sign=d7c6a19a9c510fb37c197094e133c893/b151f8198618367aebbf90fe2c738bd4b31ce5db.jpg" alt="img"> </p><p> 它的全体正因数之和为  <img src="http://h.hiphotos.baidu.com/baike/s%3D550/sign=86d9618aab014c081d3b28a03a7a025b/f7246b600c3387448405c35f530fd9f9d62aa0d5.jpg" alt="img"> </p><p>而a&lt;=10^12,可以线性筛素数预处理10^6内的素数，则a可以做唯一分解定理，注意：可能最后a&gt;1，即不一定可以完全分解。所以在计算因数的时候a&gt;1时候，要ans<em>=2，记得最后求的是对数，所以ans/=2。由于b </em> b&gt;a，不可能有符合要求的答案，所以此时答案为0，因此b&lt;=10^6，所以只要找到[1,b）中的总对数sum，用ans-sum就是最后的答案。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=1e6+50;const long long N=1e6+47;long long a,b;long long T;long long prime[maxn],vis_prime[maxn],prime_tot;void isprime(){    for(long long i=2;i&lt;=N;i++)    {        if(!vis_prime[i])            prime[++prime_tot]=i;        for(long long j=1;j&lt;=prime_tot&amp;prime[j]*i&lt;=N;j++)        {            vis_prime[i*prime[j]]=1;            if(i%prime[j]==0)                break;        }    }}int main(){    isprime();    scanf(&quot;%lld&quot;,&amp;T);    long long opt=0;    while(T--)    {        opt++;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        long long p=a;        if(b*b&gt;a)        {            printf(&quot;Case %lld: %lld\n&quot;,opt,0);            continue;        }        long long ans=1;        for(long long i=1;i&lt;=prime_tot;i++)        {            if(a%prime[i]==0)            {                long long tot=0;                while(a%prime[i]==0)                {                    a/=prime[i];                    tot++;                }                ans=ans*(tot+1);            }            if(a==1)break;        }        if(a&gt;1)ans*=2;        ans/=2;        for(long long i=1;i&lt;b;i++)            if(p%i==0)                ans--;        printf(&quot;Case %lld: %lld\n&quot;,opt,ans);    }    return 0;    }</code></pre><h1 id="4-题目名称："><a href="#4-题目名称：" class="headerlink" title="4.题目名称："></a>4.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1336" target="_blank" rel="noopener"><strong>LightOJ 1336</strong></a> Sigma Function</p><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求和运算是一种有趣的操作，它来源于古希腊字母σ，现在我们来求一个数字的所有因子之和。例如σ(24)=1+2+3+4+6+8+12+24=60.对于小的数字求和是非常的简单，但是对于大数字求和就比较困难了。现在给你一个n，你需要求出有多少个[ 1 , n ]区间内的数字σ是偶数。<br>注：一个数字的σ指这个数的所有因子之和 </p><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>显然给的公式， <img src="https://vj.z180.cn/1510021ce5adea20ba5ebd2baa22e212?v=1596100178" alt="img"> </p><p>是没办法直接用的，对解题本身作用不大。</p><p>由唯一分解定律可以知道： <img src="http://h.hiphotos.baidu.com/baike/s%3D124/sign=ae84eec8b4fd5266a32b38169f189799/f703738da97739129c546742fa198618367ae2a7.jpg" alt="img">，则因数之和为<img src="http://h.hiphotos.baidu.com/baike/s%3D550/sign=86d9618aab014c081d3b28a03a7a025b/f7246b600c3387448405c35f530fd9f9d62aa0d5.jpg" alt="img"></p><p><strong>规律1：</strong>偶数 <em> 偶数=偶数；偶数 </em> 奇数=偶数；奇数 * 奇数=奇数。可以先求得因数之和为奇数的个数，然后总数减去它，就是偶数的个数。要让因数之和为奇数，必须让上面的各项均为奇数。</p><p><strong>规律2：</strong>所有的素数中只有2是偶数，其余的素数都是奇数。</p><p><strong>规律3：</strong>要让因数之和为奇数，就要让 (1+pi+pi^2+……+pi^ai)这个东西都是奇数 。根据<strong>规律2</strong>，需要分成两种情况来考虑：<br>1）pi=2，则 (1+pi+pi^2+……+pi^ai)一定是奇数。<br>2）pi是奇数，pi^ai一定也是奇数，则需要考虑ai的奇偶。<br>      如果ai是奇数，则1+pi+pi^2+……+pi^ai就是偶数个奇数相加为偶数；<br>      如果ai是偶数，则1+pi+pi^2+……+pi^ai就是奇数个奇数相加为奇数。<br>因此ai是偶数才能使得pi为奇数时，因数之和为奇数。</p><p>①当ai是偶数且pi为奇数时（不存在素数2），<img src="http://h.hiphotos.baidu.com/baike/s%3D124/sign=ae84eec8b4fd5266a32b38169f189799/f703738da97739129c546742fa198618367ae2a7.jpg" alt="img">，则也可以表示成</p><script type="math/tex; mode=display">N=P_1^{a_1'^{2}}P_2^{a_2'^{2}}...P_n^{a_n'^{2}}即N=(P_1^{a_1'}P_2^{a_2'}...P_n^{a_n'})^{2}</script><p>所以此时N一定是完全平方数。</p><p>②当ai是偶数且pi为奇数时（存在素数2），N就相当于一个完全平方数 <em> 2^x。<br>综上所述，N的因数和要为奇数，则N要么是完全平方数，要么是2</em>完全平方数。</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;long long T,n;int main(){    cin&gt;&gt;T;    int opt=0;    while(T--)    {        opt++;        scanf(&quot;%lld&quot;,&amp;n);        long long ans=0;        for(long long i=1;i*i&lt;=n;i++)ans++;        for(long long i=1;i*i*2&lt;=n;i++)ans++;        printf(&quot;Case %d: %lld\n&quot;,opt,n-ans);    }    return 0; }</code></pre><h1 id="5-题目名称："><a href="#5-题目名称：" class="headerlink" title="5.题目名称："></a>5.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1282" target="_blank" rel="noopener"><strong>LightOJ 1282</strong></a> Leading and Trailing</p><h2 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定两个数n,k 求n^k的前三位和最后三位 </p><h2 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h2><p>对于后三位：直接快速幂取模，但是需要注意最后如果小于100，就需要补前缀0，小于10补2个，小于100补1个。</p><p>对于前三位：</p><script type="math/tex; mode=display">n^{k}=A==>klog_{10}n=log_{10}A==>A=10^{klog_{10}n}</script><script type="math/tex; mode=display">假设A=10^{a+b},其中a是整数部分，b是小数部分，并且a+b=klog_{10}n</script><p>所以可以得到整数a，和小数b，10^a控制A的位数，而10^b控制A的每一位的实际数字，即10^b就是X.xxxxxxx，要求A的前三位，那么就是10^(2+b)。</p><h2 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int T,n,k;int fastpow(int x,int p){    int ans=1;    while(p)    {        if(p&amp;1)ans=(ans*x)%1000;        p&gt;&gt;=1;        x=(x*x)%1000;    }    return ans;}int main(){    cin&gt;&gt;T;    int opt=0;    while(T--)    {        opt++;        cin&gt;&gt;n&gt;&gt;k;        double y=k*log10(n);        int y1=y;        double b=y-y1;        int ans=pow(10,2+b);        printf(&quot;Case %d: %d &quot;,opt,ans);        int x=n%1000;        x=fastpow(x,k);        if(x&lt;100)printf(&quot;0&quot;);        if(x&lt;10)printf(&quot;0&quot;);        printf(&quot;%d\n&quot;,x);    }    return 0;}</code></pre><h1 id="6-题目名称："><a href="#6-题目名称：" class="headerlink" title="6.题目名称："></a>6.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1245" target="_blank" rel="noopener"><strong>LightOJ 1245</strong></a> Harmonic Number (II)</p><h2 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求解：F(n)的值 （<strong>1 ≤ n &lt; 2147483648</strong> ）</p><pre><code class="lang-cpp">long long F(int n) {    long long res = 0;    for (int i = 1; i &lt;= n; i++) {        res += n / i;    }    return res;}</code></pre><h2 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h2><p>如果保证n&lt;=500000就可以避免超时。对于一个大于500000的数，可以将n/i=1，n/i=2…分别作为一组，这样再大的数，再10000次操作也可以减小到500000，时间复杂度也降低了。每一次操作res+=(i-1)*(pre-next+1).</p><h2 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;long long T,n;int main(){    cin&gt;&gt;T;    long long opt=0;    while(T--)    {        opt++;        cin&gt;&gt;n;        long long res=0;        if(n&gt;=500000)        {            long long pre=n;            for(long long i=2;i&lt;=10000;i++)            {                long long next=n/i;next++;                res+=(i-1)*(pre-next+1);                pre=next-1;            }            for(long long i=1;i&lt;=pre;i++)            res+=n/i;        }        else         {            for(long long i=1;i&lt;=n;i++)            res+=n/i;        }        printf(&quot;Case %lld: %lld\n&quot;,opt,res);    }    return 0;}</code></pre><h1 id="7-题目名称："><a href="#7-题目名称：" class="headerlink" title="7.题目名称："></a>7.题目名称：</h1><p><a href="https://vjudge.net/problem/LightOJ-1236" target="_blank" rel="noopener"><strong>LightOJ 1236</strong></a> Pairs Forming LCM</p><h2 id="题目大意：-6"><a href="#题目大意：-6" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求解res： <strong>n (1 ≤ n ≤ 10^14)</strong></p><pre><code class="lang-cpp">long long pairsFormLCM( int n ) {    long long res = 0;    for( int i = 1; i &lt;= n; i++ )        for( int j = i; j &lt;= n; j++ )           if( lcm(i, j) == n ) res++; // lcm means least common multiple    return res;}</code></pre><h2 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h2><p>假设n是a，b的最小公倍数。<br>对a，b进行质因数分解：</p><script type="math/tex; mode=display">a=p_1^{a_1}*p_2^{a_2}*...*p_n^{a_n}</script><script type="math/tex; mode=display">b=p_1^{b_1}*p_2^{b_2}*...*p_n^{b_n}</script><p>因此：</p><script type="math/tex; mode=display">gcd(a,b)=p_1^{min(a_1,b_1)}*p_2^{min(a_2,b_2)}*...*p_n^{min(a_n,b_n)}</script><script type="math/tex; mode=display">lcm(a,b)=p_1^{max(a_1,b_1)}*p_2^{max(a_2,b_2)}*...*p_n^{max(a_n,b_n)}</script><p>根据题意得：lcm(a,b)=n.<br>                       假设max(ai,bi)=ei</p><p>所以：</p><script type="math/tex; mode=display">n=p_1^{e_1}*p_2^{e_2}*...*p_n^{e_n}</script><p><strong>接下来就是计算方案数：</strong></p><p>对于每一项质因数的幂pi^ei,需要a，b中至少有一个pi^ei，另一个随机。当ai=bi=ei时，方案只有一个。总数为2*(ei+1)-1</p><p><strong>计算总方案：</strong></p><p>将上述的结果叠乘，然后将总方案数/2+1， 加一是因为如果直接除以2，其中有一种方案ai=bi=ei是a等于b的，所以除多了，需要加上1 </p><h2 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e7+50;const int N=1e7;typedef long long ll;ll T,n,prime_tot;bool vis_prime[maxn];int prime[1000010];void isprime(){    for(ll i=2;i&lt;=N;i++)    {        if(!vis_prime[i])            prime[++prime_tot]=i;        for(ll j=1;j&lt;=prime_tot&amp;&amp;prime[j]*i&lt;=N;j++)        {            vis_prime[i*prime[j]]=1;            if(i%prime[j]==0)                break;        }    }}int main(){    cin&gt;&gt;T;    isprime();    int opt=0;    while(T--)    {        opt++;        cin&gt;&gt;n;        ll ans=1;        for(ll i=1;i&lt;=prime_tot&amp;&amp;prime[i]&lt;=n;i++)        {            if(n%prime[i]==0)            {                ll tot=0;                while(n%prime[i]==0)                {                    tot++;                    n/=prime[i];                    }                ans=ans*(2*(tot+1)-1);            }        }        if(n&gt;1)ans=ans*(2*2-1);        ans=ans/2+1;        printf(&quot;Case %lld: %lld\n&quot;,opt,ans);    }    return 0;}</code></pre>        <div id="aplayer-fAbzliUi" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-fAbzliUi"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>线性筛素数</tag>
      
      <tag>欧拉函数</tag>
      
      <tag>hopcroft-karp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NWPU-线段树</title>
    <link href="/2020/07/24/NWPU-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2020/07/24/NWPU-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-综述"><a href="#一-综述" class="headerlink" title="一.综述"></a>一.综述</h1><p>假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。<br>线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是O(log2(n)).</p><p>线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为<br>少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。</p><p>由此看出，用线段树统计的东西，必须符合区间加法，否则，不可能通过分成的子区间来得到[L,R]的统计结果。</p><p><strong>符合区间加法的例子：</strong><br>1.数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和<br>2.最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );<br>3.最大值——总最大值=max(左区间最大值，右区间最大值)<br><strong>不符合区间加法的例子：</strong><br>1.众数——只知道左右区间的众数，没法求总区间的众数<br>2.01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零</p><p>一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来解决了，具体怎么转化在第六节会讲。<br>由于点的信息可以千变万化，所以线段树是一种非常灵活的数据结构，可以做的题的类型特别多，只要会转化。<br>线段树当然是可以维护线段信息的，因为线段信息也是可以转换成用点来表达的（每个点代表一条线段）。</p><h1 id="二-原理"><a href="#二-原理" class="headerlink" title="二.原理"></a>二.原理</h1><p>线段树本质上是维护下标为1,2,..,n的n个按顺序排列的数的信息，所以，其实是“点树”，是维护n的点的信息，至于每个点的数据的含义可以有很多，<br>在对线段操作的线段树中，每个点代表一条线段，在用线段树维护数列信息的时候，每个点代表一个数，但本质上都是每个点代表一个数。以下，在讨论线段树的时候，区间[L,R]指的是下标从L到R的这(R-L+1)个数，而不是指一条连续的线段。只是有时候这些数代表实际上一条线段的统计结果而已。</p><p>线段树是将每个区间[L,R]分解成[L,M]和[M+1,R] (其中M=(L+R)/2 这里的除法是整数除法，即对结果下取整)直到 L==R 为止。<br>开始时是区间[1,n] ,通过递归来逐步分解，假设根的高度为1的话，树的最大高度为（n&gt;1）。<br>线段树对于每个n的分解是唯一的，所以n相同的线段树结构相同，这也是实现可持久化线段树的基础。<br>下图展示了区间[1,13]的分解过程： <img src="https://img-blog.csdn.net/20150908231214395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p> 1）储存方式：</p><pre><code class="lang-cpp">struct Tree{    long long l,r,w,lazy;}tree[maxn*4];</code></pre><p>2）递归建树：</p><pre><code class="lang-cpp">void build(long long id,long long l,long long r){    tree[id].l=l;tree[id].r=r;    if(l==r)    {        tree[id].lazy=0;        tree[id].w=a[l];        return ;    }    long long mid=(l+r)/2;    build(id*2,l,mid);build(id*2+1,mid+1,r);    tree[id].w=tree[id*2].w+tree[id*2+1].w;}</code></pre><p>3）更新：</p><pre><code class="lang-cpp">void update(long long id,long long l,long long r,long long w){    if(tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)    {        tree[id].w+=(tree[id].r-tree[id].l+1)*w;        tree[id].lazy+=w;        return ;    }    if(tree[id].lazy)spread(id);    long long mid=(tree[id].l+tree[id].r)/2;    if(r&gt;mid)update(id*2+1,l,r,w);    if(l&lt;=mid)update(id*2,l,r,w);    tree[id].w=tree[id*2].w+tree[id*2+1].w;}</code></pre><pre><code class="lang-cpp">void spread(long long id){    tree[id*2].w+=(tree[id*2].r-tree[id*2].l+1)*tree[id].lazy;    tree[id*2+1].w+=(tree[id*2+1].r-tree[id*2+1].l+1)*tree[id].lazy;    tree[id*2].lazy+=tree[id].lazy;tree[id*2+1].lazy+=tree[id].lazy;    tree[id].lazy=0;}</code></pre><p>线段树的区间修改也是将区间分成子区间，但是要加一个标记，称作懒惰标记。<br>标记的含义：<br>本节点的统计信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。<br>即，如果要给一个区间的所有值都加上1，那么，实际上并没有给这个区间的所有值都加上1，而是打个标记，记下来，这个节点所包含的区间需要加1.打上标记后，要根据标记更新本节点的统计信息，比如，如果本节点维护的是区间和，而本节点包含5个数，那么，打上+1的标记之后，要给本节点维护的和+5。这是向下延迟修改，但是向上显示的信息是修改以后的信息，所以查询的时候可以得到正确的结果。有的标记之间会相互影响，所以比较简单的做法是，每递归到一个区间，首先下推标记（若本节点有标记，就下推标记），然后再打上新的标记，这样仍然每个区间操作的复杂度是O(log2(n))。</p><p>标记有相对标记和绝对标记之分：<br>相对标记是将区间的所有数+a之类的操作，标记之间可以共存，跟打标记的顺序无关（跟顺序无关才是重点）。<br>所以，可以在区间修改的时候不下推标记，留到查询的时候再下推。<br>      注意：如果区间修改时不下推标记，那么Spread函数中，必须考虑本节点的标记。<br>                 而如果所有操作都下推标记，那么Spread函数可以不考虑本节点的标记，因为本节点的标记一定已经被下推了（也就是对本节点无效了）<br>绝对标记是将区间的所有数变成a之类的操作，打标记的顺序直接影响结果，<br>所以这种标记在区间修改的时候必须下推旧标记，不然会出错。</p><p>注意，有多个标记的时候，标记下推的顺序也很重要，错误的下推顺序可能会导致错误。</p><p>之所以要区分两种标记，是因为非递归线段树只能维护相对标记。<br>因为非递归线段树是自底向上直接修改分成的每个子区间，所以根本做不到在区间修改的时候下推标记。<br>非递归线段树一般不下推标记，而是自下而上求答案的过程中，根据标记更新答案。</p><p>4）查询：</p><pre><code class="lang-cpp">long long query(long long id,long long l,long long r){    if(tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)return tree[id].w;    if(tree[id].lazy)spread(id);    long long mid=(tree[id].l+tree[id].r)/2,sum=0;    if(r&gt;mid)sum+=query(id*2+1,l,r);    if(l&lt;=mid)sum+=query(id*2,l,r);    return sum;}</code></pre><h1 id="三-题单"><a href="#三-题单" class="headerlink" title="三.题单"></a>三.题单</h1><h2 id="①线段树入门"><a href="#①线段树入门" class="headerlink" title="①线段树入门"></a>①线段树入门</h2><h3 id="1-题目名称："><a href="#1-题目名称：" class="headerlink" title="1.题目名称："></a>1.题目名称：</h3><p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener">P3372 【模板】线段树 1</a> </p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 k。</li><li>求出某区间每一个数的和。</li></ol><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>线段树入门，建树，更新，lazy标记自上而下传递，查询区间和。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=100000+10; struct Tree{    long long l,r,w,lazy;}tree[maxn*4];long long n,m,a[maxn];void build(long long id,long long l,long long r){    tree[id].l=l;tree[id].r=r;    if(l==r)    {        tree[id].lazy=0;        tree[id].w=a[l];        return ;    }    long long mid=(l+r)/2;    build(id*2,l,mid);build(id*2+1,mid+1,r);    tree[id].w=tree[id*2].w+tree[id*2+1].w;}void spread(long long id){    tree[id*2].w+=(tree[id*2].r-tree[id*2].l+1)*tree[id].lazy;    tree[id*2+1].w+=(tree[id*2+1].r-tree[id*2+1].l+1)*tree[id].lazy;    tree[id*2].lazy+=tree[id].lazy;tree[id*2+1].lazy+=tree[id].lazy;    tree[id].lazy=0;}void update(long long id,long long l,long long r,long long w){    if(tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)    {        tree[id].w+=(tree[id].r-tree[id].l+1)*w;        tree[id].lazy+=w;        return ;    }    if(tree[id].lazy)spread(id);    long long mid=(tree[id].l+tree[id].r)/2;    if(r&gt;mid)update(id*2+1,l,r,w);    if(l&lt;=mid)update(id*2,l,r,w);    tree[id].w=tree[id*2].w+tree[id*2+1].w;}long long query(long long id,long long l,long long r){    if(tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)return tree[id].w;    if(tree[id].lazy)spread(id);    long long mid=(tree[id].l+tree[id].r)/2,sum=0;    if(r&gt;mid)sum+=query(id*2+1,l,r);    if(l&lt;=mid)sum+=query(id*2,l,r);    return sum;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    build(1,1,n);    for(long long i=1;i&lt;=m;i++)    {        long long z,x,y,k;        cin&gt;&gt;z;        if(z==1)        {            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            update(1,x,y,k);        }        else         {            cin&gt;&gt;x&gt;&gt;y;            cout&lt;&lt;query(1,x,y)&lt;&lt;endl;        }    }}</code></pre><h3 id="2-题目名称："><a href="#2-题目名称：" class="headerlink" title="2.题目名称："></a>2.题目名称：</h3><p> <a href="https://www.luogu.com.cn/problem/P3373" target="_blank" rel="noopener">P3373 【模板】线段树 2</a> </p><h3 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h3><p>如题，已知一个数列，你需要进行下面三种操作：</p><ul><li>将某区间每一个数乘上x</li><li>将某区间每一个数加上x</li><li>求出某区间每一个数的和x</li></ul><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>线段树中做两个lazy标记，一个lazy1是表示相加的传递标记，另一个lazy2是表示相乘的传递标记。注意要先乘法后加法，  <strong>加法和乘法顺序不一样会导致不同的结果</strong> 。比如：  (a+b)c 不等于 a<em>c + b  而在记录懒标记的时候，加法和乘法两种标记放到一起，并不知道哪个先，哪个后。 所以要确定一个优先级<br>我们分析一下两种顺序：</em><br>(1) 先加后乘 : (a+b)c = ac + bc<br>(2) 先乘后加：ac + b<br>比较一下，发现，上面的先加后乘相当于下面的式子，在加法上面多乘了一个c 所以，我们只要是先加后乘的式子，只要加一个<em>c就可以转化为先乘后加的式子具体的操作就是在添加乘法标记的时候，把加法标记c </em> c就好了 所以，我们就定了一个总顺序：先乘后加 。 然后在标记传递Spread的时候，儿子的加法标记传递完也要保持先乘后加的顺序 </p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+10;struct Tree{    long long l,r,w,lazy1,lazy2;}tree[maxn*4];long long n,m,p,a[maxn];void build(long long id,long long l,long long r){    tree[id].l=l;tree[id].r=r;    if(l==r)    {        tree[id].w=a[l]%p;        return ;    }    long long mid=(l+r)/2;    build(id*2,l,mid);build(id*2+1,mid+1,r);    tree[id].w=(tree[id*2].w+tree[id*2+1].w)%p;    return;}void Spread(long long id){    tree[id*2].w=((tree[id*2].w*tree[id].lazy2)%p+(tree[id*2].r-tree[id*2].l+1)*tree[id].lazy1%p)%p;    tree[id*2+1].w=((tree[id*2+1].w*tree[id].lazy2)%p+(tree[id*2+1].r-tree[id*2+1].l+1)*tree[id].lazy1%p)%p;    tree[id*2].lazy1=(tree[id*2].lazy1*tree[id].lazy2%p+tree[id].lazy1)%p;    tree[id*2+1].lazy1=(tree[id*2+1].lazy1*tree[id].lazy2%p+tree[id].lazy1)%p;    tree[id*2].lazy2=(tree[id*2].lazy2*tree[id].lazy2)%p;    tree[id*2+1].lazy2=(tree[id*2+1].lazy2*tree[id].lazy2)%p;    tree[id].lazy1=0;tree[id].lazy2=1;}void MulUpdate(long long id,long long l,long long r,long long k){    if(tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)    {        tree[id].w=(tree[id].w*k)%p;        tree[id].lazy1=(tree[id].lazy1*k)%p;        tree[id].lazy2=(tree[id].lazy2*k)%p;        return ;    }    Spread(id);    long long mid=(tree[id].l+tree[id].r)/2;    if(r&gt;mid)MulUpdate(id*2+1,l,r,k);    if(l&lt;=mid)MulUpdate(id*2,l,r,k);    tree[id].w=(tree[id*2].w+tree[id*2+1].w)%p;    return ;}void AddUpdate(long long id,long long l,long long r,long long k){    if(tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)    {        tree[id].w=((tree[id].r-tree[id].l+1)*k+tree[id].w)%p;        tree[id].lazy1=(tree[id].lazy1+k)%p;        return ;    }    Spread(id);    long long mid=(tree[id].l+tree[id].r)/2;    if(r&gt;mid)AddUpdate(id*2+1,l,r,k);    if(l&lt;=mid)AddUpdate(id*2,l,r,k);    tree[id].w=(tree[id*2].w+tree[id*2+1].w)%p;    return ;}long long query(long long id,long long l,long long r){    if(tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)return tree[id].w%p;    Spread(id);    long long mid=(tree[id].l+tree[id].r)/2,sum=0;    if(mid&gt;=l)sum=(sum+query(id*2,l,r))%p;    if(mid&lt;r)sum=(sum+query(id*2+1,l,r))%p;    return sum%p;}int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    for(int i=1;i&lt;=4*n;i++)tree[i].lazy2=1;    build(1,1,n);    for(long long i=1;i&lt;=m;i++)    {        long long z,x,y,k;        cin&gt;&gt;z;        if(z==1)        {            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            MulUpdate(1,x,y,k);        }        else if(z==2)        {            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            AddUpdate(1,x,y,k);        }        else         {            cin&gt;&gt;x&gt;&gt;y;            cout&lt;&lt;query(1,x,y)%p&lt;&lt;endl;        }    }    return 0;}</code></pre><h3 id="3-题目名称："><a href="#3-题目名称：" class="headerlink" title="3.题目名称："></a>3.题目名称：</h3><p><a href="https://www.luogu.com.cn/problem/P4588" target="_blank" rel="noopener">TJOI2018]数学计算</a> </p><h3 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h3><p> 你有一个数x，初始为 1。你有两种操作，分别为：<br>1 m：x=x * m 输出x % mod;<br>2 pos：x=x/ 第pos次操作所乘的数   (保证第pos次操作一定为类型1,对于每一个类型1的操作至多会被除一次）输出x%mod;</p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>一开始以为可以模拟，但发现由于x一直增大，会爆longlong，即使取模，但是除的时候需要逆元。所以直接模拟是错的。但是第一种操作就可以多一种类型的x，假设有n个第一种类型，就有n个数字，不妨让这n个当作区间，构造线段树，对于第二种操作就是将第pos次的结点数改成1 。全部都是点修改，每次区间查询。</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=100000+10;long long T,x,q,mod;struct Tree{    long long l,r,w,lazy;}tree[maxn*4];long long a[maxn],op[maxn],m[maxn];void build(long long id,long long l,long long r){    tree[id].l=l;tree[id].r=r;    if(l==r)    {        tree[id].w=1;        return ;    }    long long mid=(l+r)/2;    build(id*2,l,mid);build(id*2+1,mid+1,r);    tree[id].w=tree[id*2].w*tree[id*2+1].w%mod;}void update(long long id,long long End,long long num){    if(tree[id].l==End&amp;&amp;tree[id].r==End)    {        tree[id].w=num;        return ;    }    long long mid=(tree[id].l+tree[id].r)/2;    if(End&lt;=mid)update(id*2,End,num);    if(End&gt;mid)update(id*2+1,End,num);    tree[id].w=tree[id*2].w*tree[id*2+1].w%mod;    return ;}long long query(long long id,long long l,long long r){    if(tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)return tree[id].w%mod;    long long mid=(tree[id].l+tree[id].r)/2,sum=0;    if(r&gt;mid)sum+=query(id*2+1,l,r),sum%=mod;    if(l&lt;=mid)sum+=query(id*2,l,r),sum%=mod;    return sum%mod;}int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;q&gt;&gt;mod;        long long n=0;        for(long long i=1;i&lt;=q;i++)        {            cin&gt;&gt;op[i]&gt;&gt;m[i];            if(op[i]==1)n++,a[i]=n;        }        build(1,1,n);        long long cnt=0;        for(long long i=1;i&lt;=q;i++)        {            if(op[i]==1)            {                update(1,++cnt,m[i]);                cout&lt;&lt;tree[1].w&lt;&lt;endl;            }            else             {                update(1,a[m[i]],1);                cout&lt;&lt;tree[1].w&lt;&lt;endl;            }        }    }    return 0;}</code></pre><h2 id="②扫描线"><a href="#②扫描线" class="headerlink" title="②扫描线"></a>②扫描线</h2><h3 id="1-题目名称：-1"><a href="#1-题目名称：-1" class="headerlink" title="1.题目名称："></a>1.题目名称：</h3><p> <a href="https://www.luogu.com.cn/problem/P5490" target="_blank" rel="noopener">P5490 【模板】扫描线</a> </p><h3 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h3><p> 求 n个矩形的面积并。 </p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p> 由于都是矩形，因此运用扫描线以后，面积的求法其实可以简化为 </p><script type="math/tex; mode=display">∑截线段长度×扫过的高度</script><p> 这也是扫描线算法最基础的应用。 </p><p> <img src="https://img.ffis.me/images/2019/08/10/image.png" alt="image.png"> </p><p>问题在于如何才能模拟扫描线从下向上扫过图形，并且快速计算出当前扫描线被截得的长度。</p><p>现在假设，扫描线每次会在碰到横边的时候停下来，如图。<br> <img src="https://img.ffis.me/images/2019/08/10/image1cba39d5beb42edc.png" alt="image1cba39d5beb42edc.png"> </p><p>简单来说，可对图形面积产生影响的元素，也就是这些横边左右端点的坐标。</p><p>为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其下边权值为1，上边权值为-1。 <img src="https://img.ffis.me/images/2019/08/10/image805e198e60891448.png" alt="image805e198e60891448.png"> </p><p>然后把所有的横边按照y坐标升序排序。这样，对于每个矩形，扫描线总是会<strong>先碰到下边，然后再碰到上边</strong>。那么就能保证扫描线所截的长度永远非负了。 这样操作以后，就可以和线段树扯上关系。先把所有端点在x轴上离散化（其实就是把所有点的横坐标存到X[里，然后升序排个序，最后去重）。 <img src="https://img.ffis.me/images/2019/08/10/imagec6ca891e8480bea8.png" alt="imagec6ca891e8480bea8.png">  </p><p> 在这个例子中，4个端点的纵投影总共把x轴切割成了5部分。取中间的3部分线段，建立一棵线段树，其每个端点维护<strong>一条线段</strong>（也就是一个区间）的信息： </p><ol><li>该线段被覆盖了多少次（被多少个矩形所覆盖）。</li><li>该线段内被整个图形所截的长度是多少。 <img src="https://img.ffis.me/images/2019/08/10/image0a03aa15aca4877e.png" alt="image0a03aa15aca4877e.png"> </li></ol><p>显然，只要一条线段被覆盖，那么它肯定被图形所截。所以，整个问题就转化为了一个<strong>区间查询问题</strong>，即：每次将 当前扫描线扫到的边 对应的信息 按照之前赋上的权值更新，然后再查询线段树根节点的信息，最后得到当前扫描线扫过的面积。这就可以用线段树来实现了.</p><p>这棵线段树的每个节点都对应了一条线段。考虑将线段树上节点对应的区间和横边建立<strong>映射关系</strong> 。 先看对于一个叶子节点x，建树时保证了tree[x].l=tree[x].r， 但其保存的信息很显然不可能只是某条线段的一个端点（如果一条线段的两个端点重合，那么它实质上仅是一个点）   再看一个节点的左右儿子，同样地，建树的时候已经保证了左右儿子的区间不会重合（交集为空），但是看这样两条相邻线段  ：[1,2],[2,3],发现[1,2]∩[2,3]={2}  也就是说左儿子的右端点和右儿子的左端点其实是重合的。  考虑把线段树每个节点x<em>x</em>对应的区间（tree[x].l,tree[x].r不变，改变区间和横边的映射关系，具体为：  节点x对应X[tree[x].r+1],X[tree[x].r+1]这条横边 </p><h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000+10;struct Tree{    long long l,r,lazy,w;}tree[maxn*4];long long x[maxn],y[maxn],x2[maxn],y2[maxn],X[maxn*2];struct N{    long long l,r,h,m;    bool operator &lt; (N &amp;x)const{return x.h&gt;h;}    }line[maxn*2];void build(long long id,long long l,long long r){    tree[id].l=l;tree[id].r=r;    if(l==r)return ;    long long mid=(l+r)/2;    build(id*2,l,mid);build(id*2+1,mid+1,r);}void Spread(long long id){    if(tree[id].lazy)    {        tree[id].w=X[tree[id].r+1]-X[tree[id].l];    }    else     {        tree[id].w=tree[id*2].w+tree[id*2+1].w;    }}void update(long long id,long long l,long long r,long long num){    if(X[tree[id].l]&gt;=l&amp;&amp;X[tree[id].r+1]&lt;=r)    {        tree[id].lazy+=num;        Spread(id);        return ;    }    long long mid=X[(tree[id].l+tree[id].r+1)/2];    if(mid==0)return ;    if(r&gt;mid)update(id*2+1,l,r,num);    if(l&lt;=mid)update(id*2,l,r,num);    Spread(id);}int main(){    long long n;    cin&gt;&gt;n;    long long tot=0;    for(long long i=1;i&lt;=n;i++)    {        cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;x2[i]&gt;&gt;y2[i];        X[2*i-1]=x[i];X[2*i]=x2[i];        line[2*i-1]=(N){x[i],x2[i],y[i],1};        line[2*i]=(N){x[i],x2[i],y2[i],-1};    }    n*=2;    sort(X+1,X+1+n);    sort(line+1,line+1+n);    tot=unique(X+1,X+1+n)-X-1;    build(1,1,tot-1);    long long ans=0;    for(long long i=1;i&lt;n;i++)    {        update(1,line[i].l,line[i].r,line[i].m);        ans+=tree[1].w*(line[i+1].h-line[i].h);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-ZDMqfmvn" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ZDMqfmvn"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NWPU-DP</title>
    <link href="/2020/07/22/NWPU-DP/"/>
    <url>/2020/07/22/NWPU-DP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-题目："><a href="#1-题目：" class="headerlink" title="1.题目："></a>1.题目：</h1><h4 id="D-Proud-Merchants"><a href="#D-Proud-Merchants" class="headerlink" title="D - Proud Merchants"></a>D - Proud Merchants</h4><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>n种商品，m元钱，每种商品都有p,q,v属性，p价格，q表示买这种商品你需要带q元老板才愿意和你交易，v这种商品的实际价值。求问最多可以获得多少价值 。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>如果p=q，那么就是01背包。但是如果p！=q， 如果A:p1 q1, B:p2 q2 ， 假设单独买A或者B的话，都是可以买到的 。 若先买A，则你至少需要p1+q2的钱；若先买B，则至少需要p2+q1的钱。  那肯定是花最少的钱 ，所以如果先买A再买B ， 那么p1+q2<p2+q1  转换一下，就是q1-p1>q2-p2  也就是说qi-pi大的先买。注意：排序的时候，得按照qi-pi从小到大排序，因为你买第n件商品的时候，是在比较你是否要先买第n件商品。 </p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5000+10;struct N{    int p,q,v;}a[maxn];int n,m;int cmp(N x,N y){    return x.q-x.p&lt;y.q-y.p;}int dp[maxn];int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        memset(dp,0,sizeof(dp));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].p&gt;&gt;a[i].q&gt;&gt;a[i].v;        sort(a+1,a+1+n,cmp);        for(int i=1;i&lt;=n;i++)        {            for(int j=m;j&gt;=a[i].q;j--)            {                dp[j]=max(dp[j],dp[j-a[i].p]+a[i].v);            }        }        cout&lt;&lt;dp[m]&lt;&lt;endl;            }    return 0;}//Phoenix-ZH</code></pre><h1 id="2-题目："><a href="#2-题目：" class="headerlink" title="2.题目："></a>2.题目：</h1><h4 id="G-Knapsack-2"><a href="#G-Knapsack-2" class="headerlink" title="G - Knapsack 2"></a><strong>G - Knapsack 2</strong></h4><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>现有 <strong>N</strong> 个物品，序号分别为 <strong>1, 2, … , N</strong>。对于每个 <strong>i</strong> (<strong>1 ≤ i ≤ N</strong>)，物品 <strong>i</strong> 有一个体积 <strong>wi</strong> 和一个价值 <strong>vi</strong>。小明想在这 <strong>N</strong> 个物品中选取一些放到背包里带回家。已知背包的容积为 <strong>W</strong>，这意味着所带物品的总体积不能超过 <strong>W</strong>。求出小明可以带回家的物品总价值可能的最大值。</p><ul><li>输入的所有数值均为整数。</li><li><strong>1 ≤ N ≤ 100</strong></li><li><strong>1 ≤ W ≤ 10^9</strong></li><li><strong>1 ≤ wi ≤ W</strong></li><li><strong>1 ≤ vi ≤ 10^3</strong></li></ul><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>01背包问题，<strong>Knapsack 1</strong>是一个裸的01背包，但是这个题发现<strong>W</strong>的值特别大，直接<strong>N*W</strong>根本跑不掉。所以枚举W是不合理的。在<strong>Knapsack 1</strong>中设dp[i]：i为容量，dp[i]为容量为i时的最大价值。那么在<strong>Knapsack 2</strong>中，不妨反着来，设dp[i]:i指背包的价值为i，dp[i]指背包的价值为i时的最小容量。注意枚举价值（&lt;=100000）时要倒着枚举（01背包）。将dp数组初始化为无限大，dp[0]是下界。当dp[j-v[i]]是可达的或者j-v[i]==0(即下界)时，可以更新dp[j]=min(dp[j],dp[j-v[i]]+w[i])。然后倒着求出最大的可达价值（要保证dp[i]&lt;=m）。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=100000+50;long long n,m,w[maxn],v[maxn],dp[maxn];int main(){    cin&gt;&gt;n&gt;&gt;m;    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;w[i]&gt;&gt;v[i];    memset(dp,0x7f7f7f7f,sizeof(dp));    dp[0]=0;    for(int i=1;i&lt;=n;i++)    {        for(int j=100000;j&gt;=v[i];j--)        {            if(dp[j-v[i]]||j-v[i]==0)            {                dp[j]=min(dp[j],dp[j-v[i]]+w[i]);            }        }    }    for(int j=100000;j&gt;=1;j--)    {        if(dp[j]&amp;&amp;dp[j]&lt;=m)        {            cout&lt;&lt;j&lt;&lt;endl;            return 0;        }    }    return 0;}//Phoenix-ZH</code></pre><h1 id="3-题目："><a href="#3-题目：" class="headerlink" title="3.题目："></a>3.题目：</h1><h4 id="I-Longest-Path"><a href="#I-Longest-Path" class="headerlink" title="I - Longest Path"></a>I - Longest Path</h4><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有一个有向图 G ，有 N 个顶点和 M 条边。顶点被编号为 1, 2, … , N，第 i 条有向边是从顶点xi 到顶点 yi (1 ≤ i ≤ M)。有向图 G 中 <strong>不包含有向环</strong>。<br>请找出G中最长有向路径的长度。最长有向路径的长度为它包含的边数量。</p><ul><li>所有的输入都是整数</li><li>2 ≤ N ≤ 10^5</li><li>1 ≤ M ≤ 10^5</li><li>1 ≤ xi, yi ≤ N</li><li>每一对 (xi, yi) 都保证不相同</li><li>G <strong>不包含有向环</strong>.</li></ul><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>直接用拓扑排序求最长路，先让所有入度为0的进队列，然后每次更新下一节点的路径长度，若入度减为0就入队列。最后线性地查一下最大地路径长度。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+10;struct node{    int to,next,w;}edge[maxn];int k=1,head[maxn],ind[maxn],n,m,dp[maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void Topsort(){    queue&lt;int&gt;q;    for(int i=1;i&lt;=n;i++)        if(!ind[i])            q.push(i);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            dp[edge[i].to]=max(dp[edge[i].to],dp[x]+edge[i].w);            ind[edge[i].to]--;            if(!ind[edge[i].to])                q.push(edge[i].to);        }    }}int  main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)    {        int u,v;        cin&gt;&gt;u&gt;&gt;v;        add(u,v,1);        ind[v]++;    }    Topsort();    int ans=0;    for(int i=1;i&lt;=n;i++)        ans=max(ans,dp[i]);    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}//Phoenix-ZH</code></pre><h1 id="4-题目："><a href="#4-题目：" class="headerlink" title="4.题目："></a>4.题目：</h1><h4 id="K-任务安排-1"><a href="#K-任务安排-1" class="headerlink" title="K - 任务安排 1"></a>K - 任务安排 1</h4><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有N个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。机器会把这N个任务分成若干批，每一批包含连续的若干个任务。从时刻0开始，任务被分批加工，执行第i个任务所需的时间是 Ti。另外，在每批任务开始前，机器需要S的启动时间，故执行一批任务所需的时间是启动时间S加上每个任务所需时间之和。<br>一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。也就是说，同一批任务将在同一时刻完成。每个任务的费用是它的完成时刻乘以一个费用系数Ci。<br>请为机器规划一个分组方案，使得总费用最小。</p><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>首先任务的顺序是不变的，变的是分组的数量，新的批次开始的时候回导致有启动时间。先考虑简单一点的方法设dp[i][j]：前个任务分成j组。那么对于第j组的第一个任务是哪一个是未知的，所以要枚举第j组的左边界，显然这个时间复杂度是O(n^3)，但是可以先写出来，再考虑优化。求出t[i]和c[i]的前缀和sumt[i]和sumc[i].dp[i][j]=min(dp[i][j],dp[k][j-1]+(s<em>j+sumt[i]) </em> (sumc[i]-sumc[k])).<br>即：</p><pre><code class="lang-cpp">for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=i;j++)        {            for(int k=0;k&lt;=i-1;k++)            {                dp[i][j]=min(dp[i][j],dp[k][j-1]+(j*s+sumt[i])*(sumc[i]-sumc[k]));            }        }    }</code></pre><p>然后我们再考虑对它进行优化：对于组数j它影响的始终是式子中的 (j<em>s+sumt[i]) </em> (sumc[i]-sumc[k])，如果我们每增加一组新的批次，都对后面的所有任务的代价都加上s<em>c[i]就可以规避这个问题。所以可以优化成一维的：dp[i]表示第i个任务需要的代价，同时枚举最后一组的第一个任务，那么<br>dp[i]=min(dp[i],dp[k-1]+s </em> (sumc[n]-sumc[k-1])+sumt[i] * (sumc[i]-sumc[k-1])).即：</p><pre><code class="lang-cpp">for(int i=1;i&lt;=n;i++)    {        for(int k=1;k&lt;=i;k++)        {            dp[i]=min(dp[i],dp[k-1]+s*(sumc[n]-sumc[k-1])+sumt[i]*(sumc[i]-sumc[k-1]));        }    }</code></pre><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5000+10;int n,s,t[maxn],c[maxn],dp[maxn],sumc[maxn],sumt[maxn];int main(){    cin&gt;&gt;n&gt;&gt;s;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;t[i]&gt;&gt;c[i],sumc[i]=sumc[i-1]+c[i],sumt[i]=sumt[i-1]+t[i];    memset(dp,0x3f3f3f3f,sizeof(dp));    dp[0]=0;/*    dp[0][0]=dp[0][1]=0;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=i;j++)        {            for(int k=0;k&lt;=i-1;k++)            {                dp[i][j]=min(dp[i][j],dp[k][j-1]+(j*s+sumt[i])*(sumc[i]-sumc[k]));            }        }    }*/    for(int i=1;i&lt;=n;i++)    {        for(int k=1;k&lt;=i;k++)        {            dp[i]=min(dp[i],dp[k-1]+s*(sumc[n]-sumc[k-1])+sumt[i]*(sumc[i]-sumc[k-1]));        }    }/*    int ans=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)        ans=min(ans,dp[n][i]);*/    cout&lt;&lt;dp[n]&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-uStPSPXH" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-uStPSPXH"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kuangbin专题-二十四</title>
    <link href="/2020/07/20/kuangbin%E4%B8%93%E9%A2%98-%E4%BA%8C%E5%8D%81%E5%9B%9B/"/>
    <url>/2020/07/20/kuangbin%E4%B8%93%E9%A2%98-%E4%BA%8C%E5%8D%81%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-题目："><a href="#1-题目：" class="headerlink" title="1.题目："></a>1.题目：</h1><h4 id="CodeForces-371C-A-Hamburgers"><a href="#CodeForces-371C-A-Hamburgers" class="headerlink" title="CodeForces - 371C  A-Hamburgers"></a><a href="https://vjudge.net/problem/CodeForces-371C/origin" target="_blank" rel="noopener">CodeForces - 371C </a> A-Hamburgers</h4><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>做汉堡包，需要的材料用字符串给出了。</p><p>已有的材料数在第二行。（顺序：B,S,C）</p><p>商店卖的材料的需要的钱数在第三行。（顺序：B,S,C）</p><p>第四行是你有的钱数。</p><p>问最多做多少汉堡。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>看到（1&lt;=r&lt;=10^12)和“最多”就觉得是二分。二分汉堡的数量，已知已经拥有的汉堡B，S，C材料的数量，也可以得到需要的总数量，由此知道需要购买的数量。然后计算总钱数，就可以进行判断了。<br>ps：WA了两次：<br>第一次：注意ans1，ans2，ans3，可能是负的，一旦为负就要定为0，不然结果偏大。<br>第二次：注意最多数量可能比10^12更大，所以右边界要大一点。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10000+10;long long n1,n2,n3,h1,h2,h3,m1,m2,m3,r;bool check(long long mid){    long long N1=n1*mid-h1,N2=n2*mid-h2,N3=n3*mid-h3;    long long ans1=N1*m1,ans2=N2*m2,ans3=N3*m3;    if(ans1&lt;0)ans1=0;    if(ans2&lt;0)ans2=0;    if(ans3&lt;0)ans3=0;    long long ans=ans1+ans2+ans3;    if(ans&lt;=r)return 1;    return 0;}int main(){    string s;    cin&gt;&gt;s;    cin&gt;&gt;h1&gt;&gt;h2&gt;&gt;h3&gt;&gt;m1&gt;&gt;m2&gt;&gt;m3&gt;&gt;r;    for(int i=0;i&lt;s.length();i++)    {        if(s[i]==&#39;B&#39;)n1++;        else if(s[i]==&#39;S&#39;)n2++;        else n3++;    }    long long l=0,ans=0,r=1100000000000;    while(l&lt;=r)    {        long long mid=(l+r)/2;        if(check(mid))        {            l=mid+1;            ans=mid;        }        else         {            r=mid-1;        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="2-题目："><a href="#2-题目：" class="headerlink" title="2.题目："></a>2.题目：</h1><h4 id="CodeForces-343C-B-Read-Time"><a href="#CodeForces-343C-B-Read-Time" class="headerlink" title="CodeForces - 343C  B-Read Time"></a><a href="https://vjudge.net/problem/CodeForces-343C/origin" target="_blank" rel="noopener">CodeForces - 343C </a> B-Read Time</h4><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p> 给你n个探头，m个要读的轨道，n个探头的初始位置是h1—-hn（从小到大），m个轨道的位置为p1———pn(也是从小到大)，探头可以左移或右移，这些探头可以一起动，每移动一格的时间为1，探头读轨道不计时间，如果要读的轨道上就有探头那么就不需要时间，找最小的时间来读完这些轨道。 </p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>二分需要的时间。判断条件：<br>从左到右，对每一个探头进行操作：<br>1.如果该探头左边没有待读取的区域，则将探头移到右边可达的最远处；<br>2.如果该探头左边有带读取区域，这就需要分两种情况：<br>    1）先左移到带读取区域，再右移到可达的最远处；<br>    2）先右移到最远的区域（ps：这个区域需要让探头能够到左边的带读取区域）<br>ps：如果探头到左边待读取区域的时间大于了所给时间，直接返回0；<br>3.然后就得到了右边可达的最远处，这样在它左边的所有区域都是已读取的区域<br>4.如果所有区域可读取则返回1，否则返回0；</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=100000+10;long long n,m,h[maxn],p[maxn],vis[maxn];bool check(long long mid){    memset(vis,0,sizeof(vis));    long long opt=1;    for(long long i=1;i&lt;=n;i++)    {        long long r;        if(p[opt]&gt;=h[i])        {            r=h[i]+mid;        }        else         {            r=max(p[opt]+(mid-(h[i]-p[opt])),(mid+p[opt]-h[i])/2+h[i]);            if(h[i]-p[opt]&gt;mid)return 0;        }        while(opt&lt;=m&amp;&amp;p[opt]&lt;=r)        {            vis[opt]=1;            opt++;        }        if(opt==m+1)break;    }    for(long long i=1;i&lt;=m;i++)        if(!vis[i])            return 0;    return 1;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;h[i];    for(long long i=1;i&lt;=m;i++)cin&gt;&gt;p[i];    long long l=0,r=21000000000,ans=0;    while(l&lt;=r)    {        long long mid=(l+r)/2;        if(check(mid))        {            ans=mid;            r=mid-1;        }        else        {            l=mid+1;        }    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-SpDahzjy" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-SpDahzjy"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>尺取</tag>
      
      <tag>单调栈队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOJ</title>
    <link href="/2020/06/21/NOJ/"/>
    <url>/2020/06/21/NOJ/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="实验4-1：求赋权图中一个结点到所有结点的最短路径的长度"><a href="#实验4-1：求赋权图中一个结点到所有结点的最短路径的长度" class="headerlink" title="实验4.1：求赋权图中一个结点到所有结点的最短路径的长度"></a>实验4.1：求赋权图中一个结点到所有结点的最短路径的长度</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+10;//---------------------------------------------邻接矩阵-------------------------------------------------------------------------------//struct AdjMatrix{    int V,E;    char Vexs[maxn];    int Edge[maxn][maxn];};int vis[maxn],path[maxn],dist[maxn];//----------创建、初始化图----引用图G，节点数V，边数E---------------//void CreateAdjMatrix(AdjMatrix &amp;G,int V,int E){    G.E=E;G.V=V;    for(int i=1;i&lt;=G.V;i++)    {        for(int j=1;j&lt;=G.V;j++)        {            if(i==j)continue;            G.Edge[i][j]=10000;        }    }    for(int i=1;i&lt;=V;i++)    {        for(int j=1;j&lt;=V;j++)        {            int w;            cin&gt;&gt;w;//输入权值             G.Edge[i][j]=w;            }    }}void Dijkstra(AdjMatrix &amp;G){    int s=1;    for(int i=1;i&lt;=G.V;i++)    {        dist[i]=10000;//初始化起点1到别的所有点的距离，设置为10000     }    for(int i=1;i&lt;=G.V;i++)    {        dist[i]=G.Edge[s][i];//初步更新起点1到别的结点的距离         if(G.Edge[s][i]&lt;10000)        {            path[i]=s;//如果起点s与结点i之间存在边，则i的上一个结点就是s         }        else         {            path[i]=-1;//如果起点s与结点i之间不存在边，则i的上一个结点就是-1，即不存在         }    }    vis[s]=1;path[s]=-1;//起点s标记掉，并且它的上一个结点为-1，即不存在     for(int i=1;i&lt;=G.V-1;i++)    {        int minn=10000,now=0;//每一次要选择一个最优的点作为松弛的中间结点，minn为权值的中间结点到起点s的最近点         for(int j=1;j&lt;=G.V;j++)        {            if(!vis[j]&amp;&amp;dist[j]&lt;minn)            {                now=j;                minn=dist[j];//如果j未被标记，并且离起点s更近，则更新minn和now             }        }        vis[now]=1;//now就是 松弛的中间结点，标记掉它         for(int j=1;j&lt;=G.V;j++)        {            if(!vis[j]&amp;&amp;dist[now]+G.Edge[now][j]&lt;dist[j])            {                dist[j]=dist[now]+G.Edge[now][j];                path[j]=now;//松弛所有未被标记的结点，并且被松弛过的点，它的上一个点就是now             }        }    }}//---------------------------------------------邻接矩阵-------------------------------------------------------------------------------//int n;AdjMatrix G;int main(){    cin&gt;&gt;n;//邻接矩阵的图的结点数    CreateAdjMatrix(G,n,n);//建图，n*n的方针     Dijkstra(G);//Dijkstra跑最短路     for(int i=1;i&lt;=G.V;i++)    {        cout&lt;&lt;dist[i]&lt;&lt;endl;//输出结点0-(i-1)的最短路     }    return 0;}</code></pre><h1 id="实验4-2：用迪杰斯特拉算法求赋权图中的最短路径"><a href="#实验4-2：用迪杰斯特拉算法求赋权图中的最短路径" class="headerlink" title="实验4.2：用迪杰斯特拉算法求赋权图中的最短路径"></a>实验4.2：用迪杰斯特拉算法求赋权图中的最短路径</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+10;//---------------------------------------------邻接矩阵-------------------------------------------------------------------------------//struct AdjMatrix{    int V,E;    char Vexs[maxn];    int Edge[maxn][maxn];};int vis[maxn],path[maxn],dist[maxn];//----------创建、初始化图----引用图G，节点数V，边数E---------------//void CreateAdjMatrix(AdjMatrix &amp;G,int V,int E){    G.E=E;G.V=V;    for(int i=1;i&lt;=G.V;i++)    {        for(int j=1;j&lt;=G.V;j++)        {            if(i==j)continue;            G.Edge[i][j]=10000;        }    }    for(int i=1;i&lt;=V;i++)    {        for(int j=1;j&lt;=V;j++)        {            int w;            cin&gt;&gt;w;//输入权值             G.Edge[i][j]=w;            }    }}void Dijkstra(AdjMatrix &amp;G,int s){    for(int i=1;i&lt;=G.V;i++)    {        dist[i]=10000;//初始化起点1到别的所有点的距离，设置为10000     }    for(int i=1;i&lt;=G.V;i++)    {        dist[i]=G.Edge[s][i];//初步更新起点1到别的结点的距离         if(G.Edge[s][i]&lt;10000)        {            path[i]=s;//如果起点s与结点i之间存在边，则i的上一个结点就是s         }        else         {            path[i]=-1;//如果起点s与结点i之间不存在边，则i的上一个结点就是-1，即不存在         }    }    vis[s]=1;path[s]=-1;//起点s标记掉，并且它的上一个结点为-1，即不存在     for(int i=1;i&lt;=G.V-1;i++)    {        int minn=10000,now=0;//每一次要选择一个最优的点作为松弛的中间结点，minn为权值的中间结点到起点s的最近点         for(int j=1;j&lt;=G.V;j++)        {            if(!vis[j]&amp;&amp;dist[j]&lt;minn)            {                now=j;                minn=dist[j];//如果j未被标记，并且离起点s更近，则更新minn和now             }        }        vis[now]=1;//now就是 松弛的中间结点，标记掉它         for(int j=1;j&lt;=G.V;j++)        {            if(!vis[j]&amp;&amp;dist[now]+G.Edge[now][j]&lt;dist[j])            {                dist[j]=dist[now]+G.Edge[now][j];                path[j]=now;//松弛所有未被标记的结点，并且被松弛过的点，它的上一个点就是now             }        }    }}//---------------------------------------------邻接矩阵-------------------------------------------------------------------------------//int n;AdjMatrix G;int road[maxn];int main(){    cin&gt;&gt;n;//邻接矩阵的图的结点数    CreateAdjMatrix(G,n,n);//建图，n*n的方针     int s,t;//接下来要求解的最短路径的起点s，终点v    cin&gt;&gt;s&gt;&gt;t;//输入 起点s，终点v    s++;t++; //由于起始点为1    Dijkstra(G,s);//Dijkstra跑最短路     int opt=0;//road数组中的数量     while(t!=-1)//停止信号是t==-1     {        road[++opt]=t-1;//road用于记录路径中的结点编号，注意输出的要求0为起始点，所以这里要-1         t=path[t];//终点回溯至上一个点     }    while(opt)//倒序输出road    {        cout&lt;&lt;road[opt]&lt;&lt;endl;//输出路径结点号         opt--;    }    return 0;}</code></pre><h1 id="实验4-3：用弗洛伊德算法求赋权图的两点间的最短路径的长度"><a href="#实验4-3：用弗洛伊德算法求赋权图的两点间的最短路径的长度" class="headerlink" title="实验4.3：用弗洛伊德算法求赋权图的两点间的最短路径的长度"></a>实验4.3：用弗洛伊德算法求赋权图的两点间的最短路径的长度</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+10;//---------------------------------------------邻接矩阵-------------------------------------------------------------------------------//struct AdjMatrix{    int V,E;    char Vexs[maxn];    int Edge[maxn][maxn];};//----------创建、初始化图----引用图G，节点数V，边数E---------------//void CreateAdjMatrix(AdjMatrix &amp;G,int V,int E){    G.E=E;G.V=V;    for(int i=1;i&lt;=G.V;i++)    {        for(int j=1;j&lt;=G.V;j++)        {            if(i==j)continue;            G.Edge[i][j]=10000;        }    }    for(int i=1;i&lt;=V;i++)    {        for(int j=1;j&lt;=V;j++)        {            int w;            cin&gt;&gt;w;//输入权值             G.Edge[i][j]=w;            }    }}void Floyd(AdjMatrix &amp;G){    for(int k=1;k&lt;=G.V;k++)//枚举中间松弛点     {        for(int i=1;i&lt;=G.V;i++)//枚举起点         {            for(int j=1;j&lt;=G.V;j++)//枚举终点             {                G.Edge[i][j]=min(G.Edge[i][j],G.Edge[i][k]+G.Edge[k][j]);//权值松弛             }        }    }}//---------------------------------------------邻接矩阵-------------------------------------------------------------------------------//int n,m;AdjMatrix G;int main(){    cin&gt;&gt;n;//邻接矩阵的图的结点数    CreateAdjMatrix(G,n,n);//建图，n*n的方针     Floyd(G);//Floyd跑最短路     cin&gt;&gt;m;//测试最短路的组数    for(int i=1;i&lt;=m;i++)    {        int u,v;        cin&gt;&gt;u&gt;&gt;v;//输入起点和终点        u++;v++;//注意这里0对应的是1（计数从1开始）         cout&lt;&lt;G.Edge[u][v]&lt;&lt;endl;//输出u--&gt;v的最短路的权值     }     return 0;}</code></pre><h1 id="实验4-4：用弗洛伊德算法求赋权图中任意两点间的最短路径"><a href="#实验4-4：用弗洛伊德算法求赋权图中任意两点间的最短路径" class="headerlink" title="实验4.4：用弗洛伊德算法求赋权图中任意两点间的最短路径"></a>实验4.4：用弗洛伊德算法求赋权图中任意两点间的最短路径</h1><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+10;//---------------------------------------------邻接矩阵-------------------------------------------------------------------------------//struct AdjMatrix{    int V,E;    char Vexs[maxn];    int Edge[maxn][maxn];};int path[maxn][maxn];//----------创建、初始化图----引用图G，节点数V，边数E---------------//void CreateAdjMatrix(AdjMatrix &amp;G,int V,int E){    G.E=E;G.V=V;    for(int i=1;i&lt;=G.V;i++)    {        for(int j=1;j&lt;=G.V;j++)        {            if(i==j)continue;            G.Edge[i][j]=10000;        }    }    for(int i=1;i&lt;=V;i++)    {        for(int j=1;j&lt;=V;j++)        {            int w;            cin&gt;&gt;w;//输入权值             G.Edge[i][j]=w;            }    }}void Floyd(AdjMatrix &amp;G){    for(int i=1;i&lt;=G.V;i++)    {        for(int j=1;j&lt;=G.V;j++)        {            if(G.Edge[i][j]&lt;10000&amp;&amp;i!=j)//当i j两节点存在路径时            {                path[i][j]=i;//初始化            }            else             {                path[i][j]=-1;//否则记为-1            }        }    }    for(int k=1;k&lt;=G.V;k++)//枚举中间松弛点     {        for(int i=1;i&lt;=G.V;i++)//枚举起点         {            for(int j=1;j&lt;=G.V;j++)//枚举终点             {                if(G.Edge[i][k]+G.Edge[k][j]&lt;G.Edge[i][j])                 {                    G.Edge[i][j]=G.Edge[i][k]+G.Edge[k][j];//权值松弛                     path[i][j]=path[k][j];                }            }        }    }}//---------------------------------------------邻接矩阵-------------------------------------------------------------------------------//int n,m;AdjMatrix G;int road[maxn];int main(){    cin&gt;&gt;n;//邻接矩阵的图的结点数    CreateAdjMatrix(G,n,n);//建图，n*n的方针     Floyd(G);//Floyd跑最短路     cin&gt;&gt;m;//测试需要输出最短路径的组数    for(int i=1;i&lt;=m;i++)    {        int u,v;        cin&gt;&gt;u&gt;&gt;v;//输入起点和终点        u++;v++;//注意这里0对应的是1（计数从1开始）         int opt=0;//road数组中的数量         road[++opt]=v-1;        while(path[u][v]!=-1)//停止信号是path[u][v]==-1         {            road[++opt]=path[u][v]-1;//road用于记录路径中的结点编号，注意输出的要求0为起始点，所以这里要-1             v=path[u][v];//终点回溯至上一个点         }        while(opt)//倒序输出road        {            cout&lt;&lt;road[opt]&lt;&lt;endl;//输出路径结点号             opt--;        }    }     return 0;}</code></pre>        <div id="aplayer-ldMErcae" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ldMErcae"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>NOJ-数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1328</title>
    <link href="/2020/03/28/CodeForces-1328/"/>
    <url>/2020/03/28/CodeForces-1328/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A 题目名称："></a>A 题目名称：</h1><p>Divisibility Problem</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定正整数 a,b，求至少把 a加上多少才能让 a为 b的倍数。</p><p>多组数据，T≤10^4，a,b≤10^9。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>如果a%b==0，说明a就是b的倍数，那么答案为0；<br>否则找到最近的a使得a%b==0，显然a=((a/b)+1)*b;答案就是a‘-a；</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;long long a,b,T;int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;a&gt;&gt;b;        if(a%b==0)printf(&quot;0\n&quot;);        else         {            long long x=a/b+1;            long long ans=b*x;            long long tot=ans-a;            cout&lt;&lt;tot&lt;&lt;endl;        }    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B 题目名称："></a>B 题目名称：</h1><p>K-th Beautiful String</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定正整数 n,k，考虑所有由 n-2个 <code>a</code> 和 2 个 <code>b</code> 构成的字符串，输出其中字典序第 k小的。 </p><script type="math/tex; mode=display">T≤10^4,3<=n<=10^5,k<=min(2*10^9,n*(n-1)/2),∑n<=10^5;</script><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>找规律：设b1，b2，b1更靠左。当b1在第二个位置上(从右开始)，共有1，当b1在第三个位置上,共有2个，当b1在第x个位置上，共有x-1个。由此就可以找到规律了。可以通过排名确定b1的位置，然后k-之前的所有数，就是b2所处的位置。</p><p>如何确定b1的位置呢？<br>假设b1处在第x位，b2处在第1位，那么在这之前的所有数量就是1+2+…+(x-2),即<br>(x-1)<em>(x-2)/2;设tot=x-1.那么就要满足tot </em> (tot-1)/2&lt;=k.解方程即可。那么x=tot+1，b2的位置就是k-(x-1)*(x-2)/2;</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;long long T,n,k;int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n&gt;&gt;k;        if(k==1)        {            for(long long i=1;i&lt;=n-2;i++)printf(&quot;a&quot;);            printf(&quot;bb\n&quot;);            continue;        }        double delta=1+sqrt(1+8*k);        long long tot=delta/2.0;        //while(tot*(tot-1)/2&lt;k)tot++;        //tot--;        long long x1=tot+1,y1=k-tot*(tot-1)/2;        if(tot*(tot-1)/2==k)        {            x1--;y1=k-(tot-1)*(tot-2)/2;        }        for(long long i=n;i&gt;=1;i--)        {            if(i!=x1&amp;&amp;i!=y1)printf(&quot;a&quot;);            else printf(&quot;b&quot;);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C 题目名称："></a>C 题目名称：</h1><p>Ternary XOR</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，每组数据给一个n，表示数字长度为n， 要求 a,b 的异或值为 x且 max(<em>a</em>,<em>b</em>) 尽可能的小 .</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>若x[i]==0，则a[i]=b[i]=0;若x[i]=1,如果此情况第一次出现，那么随便让a[i],b[i]其中一个为1都可以，这里假设a[i]=1；如果这不是第一次出现，那么都让b[i]=1。因为之前a数组的高位已经比b更大了，所以a数组是最大的，但是要让a尽量小，所以后面就将数字让给b。如果x[i]==2,如果此前a，b数组的大小还未确定，那就让a[i]=b[i]=1,如果a数组已经更大了，就让b[i]=2.</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=50000+5;int T,n,len,a[maxn],b[maxn];char s[maxn];int main(){    cin&gt;&gt;T;    while(T--)    {        memset(a,0,sizeof(a));        memset(b,0,sizeof(b));        cin&gt;&gt;len;        int sign=0;        cin&gt;&gt;s+1;        for(int i=1;i&lt;=len;i++)        {            int x;x=s[i]-&#39;0&#39;;            if(x==1&amp;&amp;sign==0)            {                a[i]=1;b[i]=0;sign=1;            }            else if(x==1&amp;&amp;sign==1)            {                a[i]=0;b[i]=1;            }            else if(x==2&amp;&amp;sign==1)            {                a[i]=0;b[i]=2;            }            else if(x==2&amp;&amp;sign==0)            {                a[i]=b[i]=1;            }            else             a[i]=b[i]=0;        }        for(int i=1;i&lt;=len;i++)cout&lt;&lt;a[i];        cout&lt;&lt;endl;        for(int i=1;i&lt;=len;i++)cout&lt;&lt;b[i];        cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D 题目名称："></a>D 题目名称：</h1><p>Carousel</p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有q组询问,每组询问如下:</p><p>已知一个有n(3≤n≤2*10^5)个点的环,点i的类型为ai,现在需要给每个点进行染色,要求相邻不同类型的点的颜色不同且所用颜色数最小.输出颜色数及一种染色方案即可.(颜色从1开始)</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>先线性跑一遍，设定a[1]=1,然后1，2，1，2…交替出现，若判断数组a都是同一个数字，说明一种颜色就够了，然后全部输出1；否则就说明，至少需要两种情况，第n个数字，由于与a[n-1]和a[1]相接，这时候就有四种情况：</p><p>1.当a[n]!=a[1]&amp;&amp;a[n]!=a[n-1],如果c[n-1]==c[1]，那么c[n]只要不与它们相同就好了，如果c[n-1]!=c[1]，这时候需要知道中间是否存在有相邻的数字相同(这个在之前的线性运行中就可以得到结果)，由前面可以得到最后一对相等数字对应的下标，从它开始所以颜色1与2对换，那么c[n-1]就可以与c[1]相同了。如果都不行，就说明至少要三种颜色了， c[n]=3；</p><p>2.a[n]==a[n-1]&amp;&amp;a[n]!=a[1],只需要两种颜色，c[n]不与c[1]相同即可。</p><p>3.a[n]!=a[n-1]&amp;&amp;a[n]==a[1]，只需要两种颜色，c[n]不与c[n-1]相同即可。</p><p>4.a[n]==a[n-1]&amp;&amp;a[n]==a[1]，只需要两种颜色，c[n]两种都可。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int T,n,a[maxn],c[maxn]; int main(){    cin&gt;&gt;T;    while(T--)    {        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];        int sign=1,e=0;c[1]=1;        for(int i=2;i&lt;=n;i++)        {            if(c[i-1]==1)c[i]=2;            else c[i]=1;            if(a[i]==a[i-1])e=i-1;            else sign=2;        }        if(sign==1)        {            cout&lt;&lt;&#39;1&#39;&lt;&lt;endl;            for(int i=1;i&lt;=n;i++)cout&lt;&lt;&#39;1&#39;&lt;&lt;&#39; &#39;;            cout&lt;&lt;endl;            continue;        }        if(a[n]!=a[n-1]&amp;&amp;a[n]!=a[1])        {            if(c[n-1]==c[1])            {                if(c[1]==1)c[n]=2;                else c[n]=1;            }            else if(e)            {                c[e+1]=3-c[e+1];                for(int i=e+2;i&lt;=n-1;i++)c[i]=3-c[i];                if(c[n-1]==c[1])                {                    if(c[1]==1)c[n]=2;                    else c[n]=1;                }            }            else             {                sign=3;c[n]=3;            }        }        else if(a[n]==a[n-1]&amp;&amp;a[n]!=a[1])        {            if(c[1]==1)c[n]=2;            else c[n]=1;        }        else if(a[n]!=a[n-1]&amp;&amp;a[n]==a[1])        {            if(c[n-1]==1)c[n]=2;            else c[n]=1;        }        else if(a[n]==a[n-1]&amp;&amp;a[n]==a[1])c[n]=1;        cout&lt;&lt;sign&lt;&lt;endl;        for(int i=1;i&lt;=n;i++)cout&lt;&lt;c[i]&lt;&lt;&#39; &#39;;        cout&lt;&lt;endl;    }    return 0;}</code></pre><p><strong>ps</strong>：考试的时候一直WA，原因是：没有考虑到 a[n]与a[n-1],最开始的for 只枚举到了n-1.</p><h1 id="E-题目名称："><a href="#E-题目名称：" class="headerlink" title="E 题目名称："></a>E 题目名称：</h1><p>Tree Queries</p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给你一个以 1为根的有根树.<br>每回询问 k节点v<em>1,</em>v2⋯vk<br>求出是否有一条以根节点为一端的链使得询问的每个节点到此链的距离均≤1.<br>只需输出可行性, 无需输出方案. </p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>这道题真的是血亏啊。被傻逼D搞死了，这道题都没看，简单的LCA就这么放弃了。<br>每次询问给了k个结点，找到深度最深的，显然这个结点与1结点构成了链，然后其余的点与此点找到LCA，看深度差是否小于等于1.</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000+5;int n,m,k=1,head[maxn],deep[maxn],fa[maxn][25],a[maxn];struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}void dfs(int u,int f){    fa[u][0]=f;    for(int i=head[u];i;i=edge[i].next)    {        if(edge[i].to==f)continue;        deep[edge[i].to]=deep[u]+1;        dfs(edge[i].to,u);    }}int LCA(int x,int y){    if(deep[x]&lt;deep[y])swap(x,y);    int depth=deep[x]-deep[y];    for(int i=20;i&gt;=0;i--)    if(depth&amp;(1&lt;&lt;i))    x=fa[x][i];    if(x==y)return x;    for(int i=20;i&gt;=0;i--)        if(fa[x][i]!=fa[y][i])        {            x=fa[x][i];y=fa[y][i];        }    return fa[x][0];}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;n;i++)    {        int a,b;        cin&gt;&gt;a&gt;&gt;b;        add(a,b);add(b,a);    }    deep[1]=1;    dfs(1,1);    for(int i=1;i&lt;=20;i++)        for(int j=1;j&lt;=n;j++)            fa[j][i]=fa[fa[j][i-1]][i-1];    for(int i=1;i&lt;=m;i++)    {        int w;cin&gt;&gt;w;int opt=0,maxx=0;        for(int j=1;j&lt;=w;j++)        {            cin&gt;&gt;a[j];            if(maxx&lt;deep[a[j]])            {                maxx=deep[a[j]];                opt=a[j];            }        }        int sign=0;        for(int j=1;j&lt;=w;j++)        {            if(a[j]==opt)continue;            int f=LCA(a[j],opt);            if(abs(deep[f]-deep[a[j]])&gt;1)            {                sign=1;                break;            }        }        if(sign==0)printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    }    return 0;}</code></pre><h1 id="F-题目名称："><a href="#F-题目名称：" class="headerlink" title="F 题目名称："></a>F 题目名称：</h1><p>Make k Equal</p><h4 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给你一个数组及其长度 n 以及一个值 k<br>仅通过将 <strong>最小</strong>元素<strong>自增</strong>/<strong>最大</strong>元素<strong>自减</strong> 的方式, 以使得至少有 k个元素相等, 输出所需的最少步数. </p><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><p>首先先将数组a从小到大排序。如果数组中已经有k个数字大小相等了，那么直接输出0即可。对于ai，要让数组a有k-1个数字和它一样大，就有3种方法。<br>1.全部修改ai左边的数字：<br>    如果ai左边(包括ai)共有k个数字，那么ans=a[i] <em> k-sum[i]；<br>    如果ai左边(包括ai)超过k个数字，那么ans=a[i] </em> i-sum[i]-(i-k);<br>    如果ai左边(包括ai)不足k个数字，自然就与条件矛盾了。<br><strong>ps</strong>：需要主要每次是修改最小的值，所以修改其左边的数字，那么最终全部都要为ai或者ai-1.</p><p>2.全部修改ai右边的数字：<br>    如果ai右边(包括ai)共有k个数字，那么ans=-a[i] <em> k+(sum[n]-sum[i-1]);<br>    如果ai右边(包括ai)超过k个数字，那么ans=-a[i] </em> i+(sum[n]-sum[i-1])-(n-i+1-k);<br>    如果ai右边(包括ai)不足k个数字，自然就与条件矛盾了。<br><strong>ps</strong>：需要主要每次是修改最大的值，所以修改其右边的数字，那么最终全部都要为ai或者ai+1.</p><p>3.两边都要修改：<br>    那么左边要么为ai，要么为ai-1；右边要么为ai，要么为ai+1；所以</p><script type="math/tex; mode=display">ans=a[i]*i-sum[i]+sum[n]-sum[i-1]-(n-i+1)*a[i]-(n-k)</script><p>最终取最小值即可。</p><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=200000+5;long long n,k,a[maxn],sum[maxn],cnt[maxn];int main(){    cin&gt;&gt;n&gt;&gt;k;    for(long long i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    sort(a+1,a+1+n);    for(long long i=1;i&lt;=n;i++)    {        if(a[i]==a[i-1])cnt[i]=cnt[i-1]+1;        else cnt[i]=1;        if(cnt[i]&gt;=k)        {            printf(&quot;0\n&quot;);            return 0;            }    }    for(long long i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i];    long long ans=1e18;    for(long long i=1;i&lt;=n;i++)    {        long long ans1=1e18,ans2=1e18,ans3=1e18;        if(i&gt;=k)        {            ans1=a[i]*i-sum[i]-(i-k);        }        if(n-i+1&gt;=k)        {            ans2=sum[n]-sum[i-1]-(n-i+1)*a[i]-(n-i+1-k);        }        ans3=a[i]*i-sum[i]+sum[n]-sum[i-1]-(n-i+1)*a[i]-(n-k);        ans=min(ans,min(min(ans1,ans2),ans3));    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><p><strong>ps</strong>：ans=1e18，否则要WA</p>        <div id="aplayer-yJUvnAkr" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-yJUvnAkr"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1326</title>
    <link href="/2020/03/21/CodeForces-1326/"/>
    <url>/2020/03/21/CodeForces-1326/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A 题目名称："></a>A 题目名称：</h1><p>A Bad Ugly Numbers</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 构造一个 n位十进制数，保证不被该数的任意一位整除。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>由于只需要求一组即可，那么就猜测一下一个数字一定要么是奇数要么是偶数，若为奇数则个位不为偶数，若为偶数则个位为偶数。这么不妨用2来替换。假如剩余全为3，那么3*x+2一定无法被3整除。所以就全用2，3表示。偶数不能被2整除。那么开头数字为2，其余全为3就可以了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int T,n;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        if(n==1)        {            printf(&quot;-1\n&quot;);        }        else         {            printf(&quot;2&quot;);            for(int i=1;i&lt;=n-1;i++)            printf(&quot;3&quot;);            cout&lt;&lt;endl;        }    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B 题目名称："></a>B 题目名称：</h1><p>Maximums </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>对于一个序列 {an}，定义序列 {cn} ：ci=max{0,a1,⋯,ai−1} 。同时定义序列 {bn} :bi=ai−ci 。</p><p>给定 {bn}，求 {an} 。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>由题意可知：ci=max{0,a1,…,ai-1},bi=ai-ci.所以ai=bi+ci;那么维护max{0,a1,…ai-1}即可。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000 +5;long long n,b[maxn],a[maxn];int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;b[i]);    long long maxx=b[1];    a[1]=b[1];    for(long long i=2;i&lt;=n;i++)    {        a[i]=maxx+b[i];        maxx=max(maxx,a[i]);    }    for(long long i=1;i&lt;=n;i++)    printf(&quot;%lld &quot;,a[i]);    cout&lt;&lt;endl;    return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C 题目名称："></a>C 题目名称：</h1><p>Permutation Partitions</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定一个长度为 n的排列{an}。要求将这个序列分成互不相交的 k段。记第 p段的左端点和右端点分别为 lp,rp 。要求最大化 <img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1584777570005.png" alt="1584777570005"><br>输出<strong>最大化的值</strong>和<strong>可以最大化该值的方案数</strong>。方案数对 998,244,353取模。 </p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>将长度为n的排列分成互不相交的k段，并且取每段的最大值，问它们的和。这一问就直接找到前k大的数字，并求和就可以了。然后求有多少种方案数。这一问需要看一下规律，将前k大的数字进行标记，然后依次统计相邻标记的数字中间有几个未标记的位置，如果为0，这区域的方案数为，如果为1，这区域的方案数位2，如果为2，这区域的方案数为3，如果为k，这区域的方案数为k+1。最后全部一边成一边取模。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000 +5;const int Mod=998244353;int n,m,a[maxn],d[maxn],vis[maxn],tot,f[maxn];long long ans=1,sig=0;int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    f[0]=1;    for(int i=1;i&lt;=n;i++)    {        f[i]=i+1;    }    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);        if(a[i]&gt;=n-m+1&amp;&amp;a[i]&lt;=n)        {            sig+=a[i];            vis[i]=1;        }    }    int maxx=0;    for(int i=1;i&lt;=n;i++)    {        if(maxx==0&amp;&amp;vis[i]==1)        {            maxx=i;        }        else if(vis[i]==1)        {            d[++tot]=i-maxx-1;            maxx=i;        }    }    ans=f[d[1]];    for(int i=2;i&lt;=tot;i++)    {        ans=(ans*f[d[i]])%Mod;    }    printf(&quot;%lld %lld\n&quot;,sig,ans);    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D 题目名称："></a>D 题目名称：</h1><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定一个字符串。要求选取他的一个前缀(可以为空)和与该前缀不相交的一个后缀(可以为空)拼接成回文串，且该回文串长度最大。求该最大长度。 </p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><h5 id="Easy版本："><a href="#Easy版本：" class="headerlink" title="Easy版本："></a>Easy版本：</h5><p>这个数据范围更小，T&lt;=1000,n&lt;=5000；可以暴力。首先从两边往中间收，一一匹配，直到左右不等，记录opt1，opt2。然后看以opt1为起点最长的回文串，然后以opt2为起点最长的回文串，这里可以用暴力办法，比如以opt1为起点时，枚举终点，从opt2开始，一旦中间不符合了，就终点位置往前靠一位；同理以opt2为起点时，枚举终点，从opt1开始，一旦中间不符合了，终点位置就往后靠一位。最后选择一个最长的与开始的合并输出。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=50000+5;int n,l;char s[maxn],t[maxn];int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        memset(t,0,sizeof(t));l=0;        scanf(&quot;%s&quot;,s+1);        int opt1=1,opt2=strlen(s+1);        while(opt1&lt;=opt2)        {            if(s[opt1]==s[opt2])            {                t[++l]=s[opt1];                opt1++;                opt2--;            }            else             break;        }        if(l==(strlen(s+1)+1)/2)        {            int len=strlen(s+1);            for(int i=1;i&lt;=strlen(s+1);i++)            cout&lt;&lt;s[i];            cout&lt;&lt;endl;            continue;        }        int s1=opt1,s2=opt2,tot1=0,sign1=0,T1=0,c=1;        while(s1&lt;=s2)        {            if(s1==s2)sign1=1;            if(s[s1]==s[s2])            {                s1++;s2--;                tot1++;                T1+=2;            }            else             {                tot1=0;                s1=opt1;s2=opt2-c;//WA                c++;                T1=0;            }        }        if(sign1==1)T1--;        s1=opt1;s2=opt2;int tot2=0,sign2=0,T2=0;c=1;        while(s1&lt;=s2)        {            if(s1==s2)sign2=1;            if(s[s1]==s[s2])            {                s1++;s2--;                tot2++;                T2+=2;            }            else             {                s1=opt1+c;s2=opt2;c++;                tot2=0;                T2=0;            }        }        if(sign2==1)T2--;        if(T1&gt;T2)        {            for(int i=opt1;i&lt;=opt1+tot1-1;i++)            {                t[++l]=s[i];            }            if(sign1==1)            {                int len=l;                for(int i=len-1;i&gt;=1;i--)t[++l]=t[i];            }            else             {                int len=l;                for(int i=len;i&gt;=1;i--)t[++l]=t[i];            }        }        else         {            for(int i=opt2;i&gt;=opt2-tot2+1;i--)            t[++l]=s[i];            if(sign2==1)            {                int len=l;                for(int i=len-1;i&gt;=1;i--)t[++l]=t[i];            }            else             {                int len=l;                for(int i=len;i&gt;=1;i--)t[++l]=t[i];            }        }        cout&lt;&lt;t+1&lt;&lt;endl;    }    return 0;}</code></pre><h5 id="hard版本："><a href="#hard版本：" class="headerlink" title="hard版本："></a>hard版本：</h5><p>这里数据范围很大，T&lt;=100000,n&lt;=1000000.显然每次查询必须在O(n)内完成，所以必须用到Manacher的算法了。首先还是先从两端开始匹配出相同的总数，直到两端不等为止，记录opt1，opt2。然后以opt1为起点求最长的回文串，再以opt2为起点求最长的回文串。这里要注意Manacher求得的最长回文串可能不一定以opt1为起点。所以更新长度时候要注意让<strong>i-(p[i]-1)==1</strong>然后再更新长度。当以opt2为起点时候，将字符串s，从opt1到opt2之间翻转一下reverse(s+opt1,s+1+opt2)即可。然后选择最长的回文串与开始的合并输出。</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=3000000+5;int T,p[maxn],l;char s[maxn]; int Manacher(int S,int T){    int len=1;    string ss=&quot;$#&quot;;    for(int i=S;i&lt;=T;i++)    {        ss+=s[i];ss+=&#39;#&#39;;        len+=2;    }    int mx=0,id=0,ans=0;p[0]=p[1]=0;    for(int i=1;i&lt;=len;i++)    {        if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);        else p[i]=1;        while(ss[i+p[i]]==ss[i-p[i]])p[i]++;        if(i+p[i]&gt;mx)        {            mx=i+p[i];            id=i;        }        ans=max(ans,p[i]-1);        if(i-p[i]+1==1)        {            if(l&lt;p[i]-1)            {                l=p[i]-1;            }        }    }    return l;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%s&quot;,s+1);        int len=strlen(s+1);        int opt1=1,opt2=len;        l=0;        while(opt1&lt;=opt2)        {            if(s[opt1]==s[opt2])            {                opt1++;opt2--;            }            else break;        }        if(opt1&gt;opt2)        {            printf(&quot;%s\n&quot;,s+1);            continue;        }        int ans1=Manacher(opt1,opt2);        reverse(s+opt1,s+1+opt2);        l=0;        int ans2=Manacher(opt1,opt2);//        cout&lt;&lt;opt1&lt;&lt;&#39; &#39;&lt;&lt;opt2&lt;&lt;&#39; &#39;&lt;&lt;ans1&lt;&lt;&#39; &#39;&lt;&lt;ans2&lt;&lt;endl;        if(ans1&gt;ans2)        {            reverse(s+opt1,s+1+opt2);            for(int i=1;i&lt;=opt1-1;i++)cout&lt;&lt;s[i];            for(int i=opt1;i&lt;=opt1+ans1-1;i++)cout&lt;&lt;s[i];            for(int i=opt1-1;i&gt;=1;i--)cout&lt;&lt;s[i];            cout&lt;&lt;endl;        }        else         {            reverse(s+opt1,s+1+opt2);            for(int i=1;i&lt;=opt1-1;i++)cout&lt;&lt;s[i];            for(int i=opt2-ans2+1;i&lt;=len;i++)cout&lt;&lt;s[i];            cout&lt;&lt;endl;        }    }    return 0;}</code></pre><p><strong>ps</strong>：说明一下<strong>reverse</strong>函数的用法：reverse(s+opt1,s+opt2),s为进行翻转的字符串，opt1为s[opt1]中的opt1，从s[0]开始。如果读入为s+1，也依然是从s[0]开始。opt2为s[0]开始的第opt2个。如果读入为s+1，也依然是s[0]开始的第opt2个。</p>        <div id="aplayer-TneODgmo" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-TneODgmo"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1325</title>
    <link href="/2020/03/18/CodeForces-1325/"/>
    <url>/2020/03/18/CodeForces-1325/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A 题目名称："></a>A 题目名称：</h1><p>EhAb AnD gCd</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你一个数x，输出一组 (a,b)使得 a和 b的最大公约数和最小公倍数的和为 x，若有多种答案，输出任意一种即可。<br>第一行输入一个 t，有 t组数据，之后每组数据输入一个数 x。<br>对于每组数据，输出两个用一个空格隔开的数 a,b。若有多种答案，输出任意一种即可。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>1是任意一个数的公约数，任意数是它和1的倍数，那么x=1+y。1，y就是答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;int n;int T;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        if(n==2)        {            printf(&quot;1 1\n&quot;);        }        else         {            printf(&quot;1 %d\n&quot;,n-1);        }    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B 题目名称："></a>B 题目名称：</h1><p>CopyCopyCopyCopyCopy</p><h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p> 共有 <code>t</code> 组数据，每组数据给你一个长为 <code>n</code>(1≤<em>n</em>≤105) 的序列(1≤ai≤109)，将它复制 <code>n</code>遍，请在这个复制后的序列里找一个最长上升子序列，输出它的长度。 </p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>由于可以重复n遍，可以依次按序取每组中最小的那个，依次增大，那么一旦有重复的，数量就要-1，所以只需要求数组中有多少数字重复即可。去重求总数即可。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;int T,a[maxn],n,vis[maxn],b[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            b[i]=a[i];        }        sort(b+1,b+1+n);        int tot=unique(b+1,b+1+n)-b-1;        printf(&quot;%d\n&quot;,tot);    }    return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C 题目名称："></a>C 题目名称：</h1><p>Ehab and Path-etic MEXs</p><h4 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个 n个节点 n-1 条边的树<br>要求给边重新标注边权<br>分别为 0,1,2…n-2<br>然后使得树上任意两点u v的MEX(<em>u</em>,<em>v</em>) 的最大值最小。<br>MEX(<em>u</em>,<em>v</em>) 是 u到 v的简单路径没有出现的<strong>自然数</strong>中最小的数。</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>这道题具体到单点上进行分析，如果这是一条链，每一个点最多连两条边。如图：<br><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1584544666135.png" alt="1584544666135"></p><p>这样来看，1-n之间没有出现的最小数只能是n-1,所以边权怎么定义都无法影响MEX了。所以这种情况随便赋值即可。</p><p>如果一个点连接了三个点。如图：</p><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1584544831772.png" alt="1584544831772"><br>三条边(分别是0，1，2)0恰好将图分成两个部分，u，v要么处于一个部分，要么处于两个不同部分。如处于相同部分就是0（但如果u、v之前存在0边权的边，则最小值是1）.如果处于两个不同部分，就是除了相邻的两条边之外的最小的值。这样MEX的最大值就是2，明显是最优的。</p><p>如果一个点连接超过三个点，方法如上图，实际上只需要定义三边就够了。<br><strong>ps</strong>:若总点数小于等于3，就特判一下。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;int n,ind[maxn],k=1,head[maxn],ans[maxn];struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int main(){    scanf(&quot;%d&quot;,&amp;n);    if(n==2)    {        printf(&quot;0\n&quot;);        return 0;    }    if(n==3)    {        printf(&quot;0\n1\n&quot;);        return 0;    }    int now=1;    for(int i=1;i&lt;=n-1;i++)    {        int u,v;        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        add(u,v);add(v,u);        ind[u]++;ind[v]++;         if(ind[u]==3)        {            for(int i=head[u];i;i=edge[i].next)            {                ans[i/2]=now;                now++;            }        }        else if(ind[v]==3)        {            for(int i=head[v];i;i=edge[i].next)            {                ans[i/2]=now;                now++;            }        }        if(ind[u]==3|ind[v]==3)        {            for(int i=1;i&lt;=n-1;i++)            {                if(!ans[i])                {                    ans[i]=now;                    now++;                }                else continue;            }                break;        }    }    if(now==1)    {        for(int i=1;i&lt;=n-1;i++)        {            ans[i]=now;            now++;        }    }    for(int i=1;i&lt;=n-1;i++)    printf(&quot;%d\n&quot;,ans[i]-1);    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D 题目名称："></a>D 题目名称：</h1><p>Ehab the Xorcist</p><h4 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h4><p>给两个整数 u，v，求出长度最短的数组，使得数组内元素的按位异或为 u，元素之和为 v。输入一行，两个数 u，v(u,v≤10^18)。<br>如果有解，输出两行，第一行输出一个数n，第二行输出n个数，表示数组里的元素。如果有多个答案，输出任意一组。<br>如果无解，输出仅一行，输出”-1”。</p><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>先讨论一下特殊情况：<br>如果u和v都等于0，显然答案是0<br>如果u==v，只需要u自己就可以了。<br>如果u&gt;v,异或的值都大于总和了，显然不可能。<br>其余情况：<br>已知y^y==0,那么不妨让x+y+y=v。如果(v-x)%2==1，说明u,v不是同为奇数或者同为偶数，这种情况无法得到答案，直接输出-1.如果(v-x)%2==0,则y=(v-x)/2,那么x^y^y==x，那么答案就是三个数字：x y y。但是这种情况可能不是最好的。有些情况其实两个数字就够了。不妨设v=(x+y)+y.要满足(x+y)^y==u,由于x^y^y==u,所以<br>(x+y)^y==x^y^y,即x+y==x^y;两个数异或等于这两个数相加，显然x&amp;y==0.即当x&amp;y==0时，答案就是两个数字 x+y  y。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long n,m;int main(){    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    if(n==0&amp;&amp;m==0)    {        printf(&quot;0\n&quot;);        return 0;    }    if(n==m)    {        printf(&quot;1\n%lld\n&quot;,n);        return 0;    }    if(n&gt;m)    {        printf(&quot;-1\n&quot;);        return 0;    }    long long yu=m-n;    if(yu%2==0)    {        long long x=n,y=yu/2;        if((x&amp;y)==0)        {            printf(&quot;2\n%lld %lld\n&quot;,x+y,y);        }        else         {            printf(&quot;3\n%lld %lld %lld\n&quot;,x,y,y);        }    }    else     {        printf(&quot;-1\n&quot;);        return 0;    }}</code></pre>         <div id="aplayer-xMcDYLba" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-xMcDYLba"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1324</title>
    <link href="/2020/03/13/CodeForces-1324/"/>
    <url>/2020/03/13/CodeForces-1324/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次参加Div3，结果就翻车了，本来前三题都很顺利，半个小时AC之后，进入T4，结果T4WA了4发，当场崩溃，结果就是minn，maxx的位置有歧义。导致T6只剩下10min，即使有思路也没办法调试出来。第二天花了15minAC了，WA了一发。果然还是细节很不到位。</p><h1 id="A：题目名称："><a href="#A：题目名称：" class="headerlink" title="A：题目名称："></a>A：题目名称：</h1><p>Yet Another Tetris Problem</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>第一行一个t，表示有t组数据。每组数据的第一行是一个数n，接下来一行是一个长度为n的数组a。 分别表示每一列的方块的高度。<br>现在有两个操作：<br>1.当至少一个ai&gt;0时，选择一些i(1&lt;=i&lt;=n)，将ai加2.<br>2.当所有的ai&gt;0时，将所有的ai减1。<br>问最后可不可以将所有的ai都变成0. 如果能，输出”YES”(没有引号)，不然输出”NO”(没有引号) </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>问题转化过来就是，可以在任意一列上+2，问最后可不可以等高。那就看highmax与其余各列的高度差是否都为偶数即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+5;int T,n,a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        int maxx=0;        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            maxx=max(maxx,a[i]);        }        int sign=0;        for(int i=1;i&lt;=n;i++)        {            int t=maxx-a[i];            if(t%2==1)            {                sign=1;                break;            }        }        if(sign==0)printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    }    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B: 题目名称："></a>B: 题目名称：</h1><p>Yet Another Palindrome Problem</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个长度为 n 的序列 a，问其中是否有长度至少为 3 的子序列 b 为「回文序列」，如果有，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p><p>注意：本题有多组数据，对每一组数据，都要给出相应答案。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>只要满足回文串的长度为3即可。那就找到任意相等的两个数字，看他们之间间隔是否大于1。对于每一个类型的数字，记录一下最先出现的位置，用vis[]表示。然后倒着枚举每一个数字，看它的位置与同样大小数字最先出现的位置相差是否大于1，一旦符合就YES；如果找不到就NO。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5000+5;int T,n,a[maxn],vis[maxn],b[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        memset(vis,0,sizeof(vis));        memset(b,0,sizeof(b));        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            if(vis[a[i]])                b[i]=vis[a[i]];            else vis[a[i]]=i;        }        int sign=0;        for(int i=n;i&gt;=1;i--)        {            if(i-b[i]&gt;=2&amp;&amp;b[i]!=0)            {                printf(&quot;YES\n&quot;);                sign=1;                break;            }        }        if(sign==0)printf(&quot;NO\n&quot;);    }        return 0;}</code></pre><h1 id="C-题目名称："><a href="#C-题目名称：" class="headerlink" title="C: 题目名称："></a>C: 题目名称：</h1><p>Frog Jumps</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据。每组数据是一串由L与R组成的字符串。青蛙从0出发，到n+1停止。n就是字符串长度(n不会给出)。若青蛙停在ai上，ai==‘L’就只能向左跳，ai==’R’就只能向右跳。求出最小的d，使得每一次青蛙跳的距离不超过d并且可以到达n+1.</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>假如ai==‘L’，意味着青蛙要向左跳。由于最终要跳到n+1，就必须尽量落在ai==’R’上，假设ai—&gt;aj,ai==’R‘，aj==’L’，如果j-i==d，如果中间没有R了，那显然不能满足它跳到n+1去，若有R那肯定跳到最后一个ak==’R’ 上。如果j-i&lt;d,就看后面是否有ak==’R’(注意范围),或者i—j之间是否有ak==’R’.总之这样推断后，发现每一次都要落在ai==’R’上才能到达n+1处。现在就是如何求d了，对d进行二分即可。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+10;int T,len;char s[maxn];bool check(int mid){    int opt=0,now=0,sign=0;    while(opt&lt;=len+1)    {        if(s[opt]==&#39;R&#39;&amp;&amp;opt-now&lt;=mid)        {            now=opt;        }        else if(opt-now&gt;mid)        {            sign=1;break;        }        opt++;    }    if(sign==1)return 0;    else return 1;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%s&quot;,s+1);        len=strlen(s+1);        s[len+1]=&#39;R&#39;;        int l=0,r=200000+5,ans=0;        while(l&lt;=r)        {            int mid=(l+r)/2;            if(check(mid))            {                ans=mid;                r=mid-1;            }            else             {                l=mid+1;            }        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D: 题目名称："></a>D: 题目名称：</h1><p>Pair of Topics</p><h4 id="Ps：本场比赛WA了4次，把自己坑得人都没了QAQ"><a href="#Ps：本场比赛WA了4次，把自己坑得人都没了QAQ" class="headerlink" title="Ps：本场比赛WA了4次，把自己坑得人都没了QAQ"></a>Ps：本场比赛WA了4次，把自己坑得人都没了QAQ</h4><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定n组ai，bi。求有多少组满足ai+aj&gt;bi+bj(i&lt;j)</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>移项之后就是求 (ai-bi)+(aj-bj)&gt;0有多少组。设ci=ai-bi.就是求ci+cj&gt;0有多少组。将c数组从小到大排好。minn为最靠后的小于或等于0的数，maxx为最靠前的大于或等于0的数。这里特别要注意：如果存在0，那么minn=maxx=i(a[i]==0)，如果存在多个0，那么minn=maxx=i(<strong>i是最后一个0所在位置</strong>)，那么大于0的个数就是n-maxx+1.注意：如果maxx==n，可能a[maxx]=0或者a[maxx]&gt;0；也可能minn=maxx=1，意味着可能a[minn]=a[maxx]=0,也可能是全为负数。这里的特殊情况较多，很容易WA。(主要还是设计算法时候没有注意到），然后将minn倒着向前推，如果c[minn]+c[maxx]&gt;0,ans+=n-maxx+1(意味着maxx后面的也都满足)，如果c[minn]+c[maxx]&lt;=0，就maxx++，直到c[minn]+c[maxx]&gt;0(注意maxx不可以超过n),所以还要判断是否c[minn]+c[maxx]&gt;0。<br>ps：minn=maxx=1时候，也可能全正，直接输出答案即可。ans=(n-1)*n/2;</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=200000+10;long long n,a[maxn],b[maxn],c[maxn];long long cmp(long long x,long long y){    return x&lt;y;}int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;b[i]);    for(long long i=1;i&lt;=n;i++)c[i]=a[i]-b[i];    sort(c+1,c+1+n,cmp);    long long minn=1,maxx=1;    for(long long i=1;i&lt;=n;i++)    {        if(c[i]==0)        {            minn=maxx=i;        }        if(c[i]&gt;0&amp;&amp;c[i-1]&lt;0)        {            minn=i-1;            maxx=i;        }        if(c[i]&gt;0&amp;&amp;c[i-1]&gt;0)break;    }    long long ans=0;    if(minn==maxx)    {        while(c[maxx]&lt;=0&amp;&amp;maxx&lt;=n-1)maxx++;    }    ans=(n-maxx+1)*(n-maxx)/2;    if(maxx==1)    {        printf(&quot;%lld\n&quot;,ans);        return 0;    }    for(long long i=minn;i&gt;=1;i--)    {        if(c[i]+c[maxx]&gt;0)        {            ans+=n-maxx+1;        }        else         {            while(c[i]+c[maxx]&lt;=0&amp;&amp;maxx&lt;=n-1)maxx++;            if(c[i]+c[maxx]&gt;0)ans+=n-maxx+1;        }    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><h1 id="E-题目名称："><a href="#E-题目名称：" class="headerlink" title="E: 题目名称："></a>E: 题目名称：</h1><p>Sleeping Schedule</p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p> Vova  可以选择在ai小时或者ai-1小时后睡觉，每次睡h个小时，如果开始睡觉那一刻位于l和r之间就是符合要求的。问一共有多少个符合要求。</p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>每一次睡觉时有两个选择：ai个小时后睡或者ai-1个小时后睡觉，但是由于之前i-1次也会出现这样的选择。如果单纯直接递推，就无法判断枚举的上次睡觉时间是否可以到达。所以vis[i][j]记录第i次在j时刻睡觉。dp[i][j]表示第i次在j时刻睡觉所累积的符合要求的数量。显然dp[1][a[i]]=1,dp[1][a[i]-1]=1.vis[1][a[1]]=1,vis[1][a[1]-1]=1,然后开始枚举ai，和ai-1次睡觉的时刻。必须满足vis[i-1][j]=1，即上一次睡觉可以在j时刻睡觉才可以继续。那么第i次睡觉可以在(j+a[i])%h或者(j+a[i]-1)%h开始。对vis数组进行记录。然后更新dp数组(看睡觉时刻是否处于l和r之间).然后再dp[n][j]中求maxx(0&lt;=j&lt;=h-1).<br><strong>ps</strong>:l&lt;=a[1]&lt;=r时候，dp[1][a[1]]=1;l&lt;=a[1]-1&lt;=r时候，dp[1][a[i]-1]=1,而vis数组直接标记即可。</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=3000+5;int n,h,l,r,dp[maxn][maxn],a[maxn],vis[maxn][maxn];int main(){    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;h,&amp;l,&amp;r);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    if(a[1]&gt;=l&amp;&amp;a[1]&lt;=r)    {        dp[1][a[1]]=1;    }    vis[1][a[1]]=1;    if(a[1]-1&gt;=l&amp;&amp;a[1]-1&lt;=r)    {        dp[1][a[1]-1]=1;    }    vis[1][a[1]-1]=1;    for(int i=2;i&lt;=n;i++)    {        for(int j=0;j&lt;=h-1;j++)        {            if(!vis[i-1][j])continue;            int x=(j+a[i])%h;            vis[i][x]=1;            if(x&gt;=l&amp;&amp;x&lt;=r)dp[i][x]=max(dp[i][x],dp[i-1][j]+1);            else dp[i][x]=max(dp[i][x],dp[i-1][j]);            x=(j+a[i]-1)%h;            vis[i][x]=1;            if(x&gt;=l&amp;&amp;x&lt;=r)dp[i][x]=max(dp[i][x],dp[i-1][j]+1);            else dp[i][x]=max(dp[i][x],dp[i-1][j]);        }    }    int ans=0;    for(int j=0;j&lt;=h-1;j++)    ans=max(ans,dp[n][j]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><h1 id="F-题目名称："><a href="#F-题目名称：" class="headerlink" title="F: 题目名称："></a>F: 题目名称：</h1><p>Sleeping Schedule</p><h4 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一棵 n 个节点无根树，每个节点 u有一个颜色au，若 au 为 0 则 u 是黑点，若 au为 1 则 u是白点。<br>对于每个节点 u，选出一个包含 u的连通子图，设子图中白点个数为 cnt1，黑点个数为 cnt2，请最大化 cnt1 - cnt2。并输出这个值。 </p><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><p>默认1为根，从头到底进行一边dfs，每次进入dfs，先更新w1，w2数组，若为白色则w1[i]=1否则w2[i]=1,则sum[i]=w1[i]-w2<a href="sum数组表示cnt1-cnt2">i</a>.然后从底部进行回溯：若edge[i].to(即子树的头节点)它的sum[edge[i].to]&gt;0,那么sum[u]+=sum[edge[i].to].这样只是更新了头节点。而子树与其头节点的关系并没有更新。假如一个子树，它的父节点所在子树的sum[u]&gt;0,而该节点所在子树的sum[edge[i].to]&gt;0,那么显然父亲节点的子树一定包含了该子节点所在的子树，那么sum[edge[i].to]=sum[u].如果sum[edge[i].to]&lt;0，就说明该节点为黑色。sum[edge[i].to]=sum[edge[i].to]+sum[u];然后继续dfs。</p><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int n,v[maxn],k=1,w1[maxn],w2[maxn],sum[maxn],son[maxn],head[maxn];struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}void dfs(int u,int f){    if(v[u]==0)w2[u]=1;    if(v[u]==1)w1[u]=1;    sum[u]=w1[u]-w2[u];    for(int i=head[u];i;i=edge[i].next)    {        if(edge[i].to==f)continue;        dfs(edge[i].to,u);        if(sum[edge[i].to]&gt;0)        sum[u]+=sum[edge[i].to];    }}void dfs2(int u,int f){    for(int i=head[u];i;i=edge[i].next)    {        if(edge[i].to==f)continue;        if(sum[edge[i].to]&gt;=0&amp;&amp;sum[edge[i].to]&lt;sum[u])        sum[edge[i].to]=sum[u];        else if(sum[edge[i].to]&lt;0&amp;&amp;sum[u]&gt;=0)        sum[edge[i].to]+=sum[u];        dfs2(edge[i].to,u);    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;v[i]);    for(int i=1;i&lt;n;i++)    {        int u,v;        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        add(u,v);add(v,u);    }    dfs(1,1);    dfs2(1,1);    for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,sum[i]);cout&lt;&lt;endl;    return 0;}</code></pre>         <div id="aplayer-pqvXrxwm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-pqvXrxwm"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1321</title>
    <link href="/2020/03/07/CodeForces-1321/"/>
    <url>/2020/03/07/CodeForces-1321/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A:题目名称："></a>A:题目名称：</h1><p>Contest for Robots</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出长度为1≤<em>n</em>≤100 的两个序列 r,b，且满足 ri, bi∈{0,1}，你需要确定 pi（pi≥1）。</p><p>满足</p><script type="math/tex; mode=display">\sum_{i=1}^n r_ip_i > \sum_{i=1}^n b_ip_i</script><p>，并且最小化max pi（1&lt;=i&lt;=n）</p><p>如果不可能，输出 -1 。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>因为序列的数字要么为1，要么为0，那么如果r中没有数字比b中的大，那么显然不可能实现题目的要求。一旦求得r比b大的个数w1，和r比b小的个数w2，就可以求maxpi，但是注意要求是大于，所以ans=(w2+1)/w1;并且要判断是否整除，如果没有则ans++。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000+5;int a[maxn],b[maxn],n;int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;b[i]);    int w1=0,w2=0;    for(int i=1;i&lt;=n;i++)    {        if(a[i]&gt;b[i])w1++;        if(a[i]&lt;b[i])w2++;    }    if(w1==0&amp;&amp;w2==0)printf(&quot;-1\n&quot;);    else if(w1==0&amp;&amp;w2&gt;0)printf(&quot;-1\n&quot;);    else    {        int s=(w2+1)/w1;        if(s*w1!=w2+1)s++;        printf(&quot;%d&quot;,s);    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p>Journey Planning</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出一个长度为 n的序列 b。</p><p>设 b的一个子序列 c 的长度为 m，它的第 i个元素在原序列的下标为ci，要求对于任意 1≤<em>i</em>&lt;<em>m</em>，ci+1−ci=bci+1−bci。</p><p>此时这个子序列的贡献为</p><script type="math/tex; mode=display">\sum_{i=1}^m{b_{c_i}}​</script><p>求出所有合法的子序列的贡献中最大的贡献。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>有题目大意可知，要求一个子序列，假设该数字在原数组第i位，则要满足bi-bj=i-j;即<br>bi-i=bj-j;所以只需要sort排序的条件设为x.v-x.id&lt;y.v-x.id；然后线性求和并取max，注意最后的小细节。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=200000+5;long long n;struct node{    long long v,id;}a[maxn];long long cmp(node x,node y){    return x.v-x.id&lt;y.v-y.id;}int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i].v);        a[i].id=i;    }    sort(a+1,a+1+n,cmp);    long long maxx=a[1].v,ans=a[1].v;    for(int i=2;i&lt;=n;i++)    {        if(a[i].v-a[i].id==a[i-1].v-a[i-1].id)        {            ans+=a[i].v;            maxx=max(maxx,ans);        }        else         {            maxx=max(maxx,ans);            ans=a[i].v;        }    }    maxx=max(maxx,ans);    printf(&quot;%lld\n&quot;,maxx);    return 0;}</code></pre>         <div id="aplayer-fJrtsJTE" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-fJrtsJTE"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1311</title>
    <link href="/2020/02/29/CodeForces-1311/"/>
    <url>/2020/02/29/CodeForces-1311/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A：题目名称："><a href="#A：题目名称：" class="headerlink" title="A：题目名称："></a>A：题目名称：</h1><p> Add Odd or Subtract Even</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><ul><li>给定两个正整数a,b。</li><li>每次操作你可以把 a加上某个正奇数，或者减去某个正偶数。</li><li>问至少多少次操作可以把 a变成 b。</li><li>多组数据 :T&lt;=10^4,1&lt;=a,b&lt;=10^9</li></ul><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>对于a，b关系可分为3种情况：a&gt;b;a==b;a<b;a==b:答案为0；a > b:若a-b为偶数，答案为1；否则为2，先减一个偶数让a=b-1，再加1。<br>a &lt; b:若b-a为奇数，答案为1；否则为2.</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T,a,b;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        if(b&gt;a)        {            if((b-a)%2==1)printf(&quot;1\n&quot;);            else printf(&quot;2\n&quot;);        }        else if(b==a)        {            printf(&quot;0\n&quot;);        }        else if(b&lt;a)        {            if((a-b)%2==0)printf(&quot;1\n&quot;);            else printf(&quot;2\n&quot;);        }    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p>WeirdSort</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1582966700624.png" alt="1582966700624"></p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>这题看起来和冒泡排序很像，将冒泡排序的判断条件改一下就可以，每一次必须是在限制的位置上时才可以swap。最后再判断是否变成有序数列即可。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int a[maxn],p[maxn],n,m,T,vis[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(vis,0,sizeof(vis));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%d&quot;,&amp;p[i]);            vis[p[i]]=1;        }        int sign=0;        for(int i=1;i&lt;=n;i++)        {            if(sign==1)break;            for(int j=1;j&lt;=n-i;j++)            {                if(a[j]&gt;a[j+1])                {                    if(!vis[j])                    {                        sign=1;                        break;                    }                    else                     {                        swap(a[j],a[j+1]);                    }                }            }        }        for(int i=1;i&lt;=n-1;i++)        {            if(sign==1)break;            if(a[i]&gt;a[i+1])            {                sign=1;                break;            }        }        if(sign==1)printf(&quot;NO\n&quot;);        else printf(&quot;YES\n&quot;);    }    return 0;}</code></pre><h1 id="C：题目名称："><a href="#C：题目名称：" class="headerlink" title="C：题目名称："></a>C：题目名称：</h1><p>Perform the Combo</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一台机器准备要打印一篇文章，有 m 个打印操作</p><p>给出操作序列 p1,p2, …,pm和 长度为 n的字符串 s<br>对于每个 1≤<em>i</em>≤m，pi表示该机器将位置1∼pi上的所有字母打印了出来<br>最后，在所有操作做完后，该机器又将整个字符串 s打印了出来</p><p>请求出字母表中每个字母在文章中出现了多少次</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>先统计位置i之前26个字母每个字母的总数，然后直接模拟求总和，注意最后要加上一次完整的计数。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int T,n,m,s[maxn][27],ans[27];char a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(ans,0,sizeof(ans));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        scanf(&quot;%s&quot;,a+1);        for(int i=1;i&lt;=n;i++)        {            int x=a[i]-&#39;a&#39;+1;            for(int j=1;j&lt;=26;j++)            {                if(j==x)s[i][j]=s[i-1][j]+1;                else s[i][j]=s[i-1][j];            }        }        for(int i=1;i&lt;=m;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            for(int j=1;j&lt;=26;j++)            {                ans[j]=ans[j]+s[x][j];            }        }        for(int i=1;i&lt;=26;i++)ans[i]=ans[i]+s[n][i];        for(int i=1;i&lt;=26;i++)printf(&quot;%d &quot;,ans[i]);        cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="D-题目名称："><a href="#D-题目名称：" class="headerlink" title="D:题目名称："></a>D:题目名称：</h1><p>Three Integers</p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>题目给出三个整数a<em>≤</em>b<em>≤</em>c。</p><p>在一次操作中，你可以给这三个数中任意一个数 +1 或 -1。你可以用同一个数字做这样的操作任意次。但你要保证，变换过后的数，是一个正数。</p><p>你想要用最小操作步数使得三个整数 A<em>≤</em>B<em>≤</em>C能够符合：B 能被 A 整除， C能被 B整除。</p><p>你需要回答 t 组询问。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>一开始想着找出a与b，a与c的关系，结果这样写有点麻烦。b作为中间数字，当然用它来做媒介最好。注意b可以减到a，也可以加到c，所以枚举的大小应该为max(b-a,c-b);找到b-i的所有因子，得到a改变成b-i的因子的最小变化值ned1，并且记录a变化后的值。再找b-i的所有倍数，得到c变成b-i的倍数的最小变化之ned2，并且记录c变化后的值。再更新总变化值，以及记录a，b，c的值。然后同理求b+i的情况。如果b-i&lt;=0直接去掉。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=10000+5;int T,A,B,C,a,b,c;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        int ans=0x3f3f3f3f;        scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);        for(int i=0;i&lt;=max(B-A,C-B);i++)//注意取max         {            int B1=B-i,ned1=0x3f3f3f3f,ned2=0x3f3f3f3f,nowa,nowc;            if(B1&gt;0)            {                for(int j=1;j&lt;=sqrt(B1);j++)                {                    if(B1%j==0)                    {                        if(ned1&gt;abs(A-j))                        {                            ned1=abs(A-j);                            nowa=j;                        }                        if(ned1&gt;abs(A-B1/j))                        {                            ned1=abs(A-B1/j);                            nowa=B1/j;                        }                    }                }                for(int j=1;j&lt;=C/B1+1;j++)                {                    if(ned2&gt;abs(C-B1*j))                    {                        ned2=abs(C-B1*j);                        nowc=B1*j;                    }                }                if(ans&gt;ned1+ned2+i)                {                    ans=ned1+ned2+i;                    b=B1;a=nowa;c=nowc;                }                }            B1=B+i,ned1=0x3f3f3f3f,ned2=0x3f3f3f3f;            for(int j=1;j&lt;=sqrt(B1);j++)            {                if(B1%j==0)                {                    if(ned1&gt;abs(A-j))                    {                        ned1=abs(A-j);                        nowa=j;                    }                    if(ned1&gt;abs(A-B1/j))                    {                        ned1=abs(A-B1/j);                        nowa=B1/j;                    }                }            }            for(int j=1;j&lt;=C/B1+1;j++)            {                if(ned2&gt;abs(C-B1*j))                {                    ned2=abs(C-B1*j);                    nowc=B1*j;                }            }            if(ans&gt;ned1+ned2+i)            {                ans=ned1+ned2+i;                b=B1;a=nowa;c=nowc;            }        }        printf(&quot;%d\n&quot;,ans);        printf(&quot;%d %d %d\n&quot;,a,b,c);    }    return 0;}</code></pre><h1 id="E-题目名称："><a href="#E-题目名称：" class="headerlink" title="E:题目名称："></a>E:题目名称：</h1><p>Construct the Binary Tree</p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 要求构造一个n个节点的二叉树（每个节点拥有不超过2个孩子），节点1为根，要使所有节点到根的距离之和为d。要求先判断可不可以构造，如果可以输出“YES”，下一行输出2到n号节点的父亲节点，否则输出“NO”。有多组询问。 </p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>要想构成树，那么必须保证Minn&lt;=d&lt;=Maxx,Minn就是满二叉树(最接近满二叉树)的情况，Maxx就是链。然后就是从Minn转换或者从Maxx转换成d。这里选择将链转换变成满足深度总和满足d的情况，预处理出Minn[i]，即n=i，对应的最小深度和，若d<Minn||d>Maxx那么就NO,(Maxx=i*(i-1)/2)，然后构成链，a[i][0]=i+1,f[i+1]=i,cnt[i]=1;(cnt[i]表示i这个深度点的总数)，从最底层向上移动，移动最多就是和根(1)相接，设最小深度为minn=1，每一次上升的高度为delt=min(i-minn,t)(i为当前移动点的深度，t为需要上升的总次数)。于是点(i+1)移动到深度为i-delt的层，该层最多有2^(i-delt-1)个点，点(i+1）就位于cnt[pos]的位置，f[i+1]对应的是上一层的第cnt[pos]/2的点。即f[i+1]=a[pot-1][cnt[pos]/2]，那么a[pos][cnt[pos]]=i+1;注意每次cnt[pos]++,一旦cnt[pos]&gt;=pow(2,minn)，那么就要往下一层走了。</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=5000+5;int T,n,d,sum[maxn],maxx[maxn],f[maxn],a[maxn][maxn],cnt[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=2;    sum[1]=0;maxx[1]=0;    for(int i=2;i&lt;=5000;i++)    {        maxx[i]=i*(i-1)/2;        if(i&lt;pow(2,opt))        {            sum[i]=sum[i-1]+(opt-1);        }        else        {            opt++;            sum[i]=sum[i-1]+(opt-1);        }    }    while(T--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;d);        if(d&lt;sum[n]||d&gt;maxx[n])        {            printf(&quot;NO\n&quot;);            continue;        }        int t=maxx[n]-d;        for(int i=0;i&lt;=n-1;i++)        {            a[i][0]=i+1;f[i+1]=i;cnt[i]=1;        }        int minn=1;        for(int i=n-1;i&gt;=1;i--)        {            int delt=min(i-minn,t);            t-=delt;            int pos=i-delt;            f[i+1]=a[pos-1][cnt[pos]/2];            a[pos][cnt[pos]++]=i+1;            if(cnt[pos]&gt;=pow(2,minn))minn++;            if(!t)break;        }        printf(&quot;YES\n&quot;);        for(int i=2;i&lt;=n;i++)        {            printf(&quot;%d &quot;,f[i]);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><h1 id="F-题目名称："><a href="#F-题目名称：" class="headerlink" title="F:题目名称："></a>F:题目名称：</h1><p>Moving Points</p><h4 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h4><p><img src="C:\Users\ha&#39;er\AppData\Roaming\Typora\typora-user-images\1582968080820.png" alt="1582968080820"></p><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><p>假如xi<xj，那么要让i与j的距离可以变成0，就必须vi>vj。不妨让所有的点按xi从小到大的顺序排列。对于i，需要找到所有满足vj&lt;vi的点，这样的i与j的距离就是0，其余的就是abs(xi-xj)，这样就需要维护这种点的vj的总和。可以选择树状数组来维护:先将所有点的vi从d小到大编号，1为最小，n为最大，找到点i的vi的排名p，然后加入到树状数组。排名小于p的就是vj&lt;vp的，否则就是vp&lt;vj的。树状数组要维护点p之前(包括点p)的点的个数和点p之前(包括点p)的v的总和。然后开始枚举点i，首先确定它v的排名p，得到p之前点的个数f1(即v&lt;vi的点的个数)，得到p之前的点的x总和f2(即v&lt;vi的x总和),求得可以使自己和点i之间的距离为0的个数，其余就是不可为0的。ans=ans+abs((n-f1-i)*a[i].x-(sum-f2));注意要减去a[i].x本身，并且每一对点之间只能计算一次，所以树状数组要更新，将权值加上负值即可(add(p,-1,-a[i].x);)。所以剩余距离不能为0的点个数为n-f1-i，而这些点的x之和就是sum-f2(每次sum-a[i].x)。最后输出ans。</p><p><strong>开longlong保平安</strong></p><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=200000+5;long long n,b[maxn],w1[maxn],w2[maxn];struct node{    long long x,v;}a[maxn];long long cmp(node x1,node x2){    return x1.x&lt;x2.x;}long long lowbit(long long x){    return x&amp;(-x);}void add(long long x,long long v1,long long v2){    while(x&lt;=n)    {        w1[x]+=v1;w2[x]+=v2;x+=lowbit(x);    }}long long query1(long long x){    long long ans=0;    while(x)    {        ans+=w1[x];x-=lowbit(x);    }    return ans;}long long query2(long long x){    long long ans=0;    while(x)    {        ans+=w2[x];x-=lowbit(x);    }    return ans;}int main(){    scanf(&quot;%lld&quot;,&amp;n);    long long sum=0;    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i].x);    for(long long i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i].v);        b[i]=a[i].v;    }    sort(a+1,a+1+n,cmp);    sort(b+1,b+1+n);    long long tot=unique(b+1,b+1+n)-b-1;    for(long long i=1;i&lt;=n;i++)    {        long long p=lower_bound(b+1,b+1+tot,a[i].v)-b;        add(p,1,a[i].x);        sum+=a[i].x;    }     long long ans=0;    for(long long i=1;i&lt;=n;i++)    {        long long p=lower_bound(b+1,b+1+tot,a[i].v)-b;        sum-=a[i].x;        long long f1=query1(p-1),f2=query2(p-1);        ans=ans+abs((n-f1-i)*a[i].x-(sum-f2));        add(p,-1,-a[i].x);    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre>         <div id="aplayer-rWFKCeod" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-rWFKCeod"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1300</title>
    <link href="/2020/02/19/CodeForces-1300/"/>
    <url>/2020/02/19/CodeForces-1300/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A:题目名称："></a>A:题目名称：</h1><p> Non-zero</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个含有 n个整数的数列。每次可以将其中的一个数加一，记为一次操作。问使得数列<strong>所有数之和</strong>与数列<strong>所有数的乘积</strong>都不为0的操作次数。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>乘积不可以为0，要就让所有为0的数字变成1，那么统计一下有多少个0就可以了。然后所有数之和不为0，只需要将0变成1之后a[1]-a[n]全部加起来，若不等于0则输出结果，若为0就将次数+1再输出结果。(a1+…+an=0，且不存在ai=0，那么必然存在aj&gt;0，则将aj++即可)</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+5;int T,n,a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        int ans=0,end=0;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            if(a[i]==0)            {                a[i]=1;                ans++;            }            end+=a[i];        }        if(end==0)        ans++;        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p> Assigning to Classes</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个有n * 2 个数的数列。让你把它分成两组，使得每一组的数量均为奇数。请你求出两组中位数之差的绝对值的最小值。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>我的方法稍微复杂了点，先将a数组从小到大排序。若n为奇数，那么直接交错分组即可，即a[1],a[3]…a[n]为一组,a[2],a[4]…a[n-1]为一组，最小的中位数的差的绝对值=a[n+1]-a[n]；若n为偶数，那么也是交错分组，但是有两种分法：</p><p>1.a[1],a[3]…a[n-3]为一组，a[2],a[4]…a[n-4],a[n-2],a[n-1],a[n]为一组。答案为a[n+2]-a[n-1];</p><p>2.a[1],a[3]…a[n-1],a[n]为一组，a[2],a[4]…a[n-2]为一组。答案为a[n+1]-a[n];</p><p>取min(a[n+2]-a[n-1],a[n+1]-a[n]);</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int T,n;long long a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=2*n;i++)        {            scanf(&quot;%lld&quot;,&amp;a[i]);        }        sort(a+1,a+1+2*n);        if(n%2==1)        {            printf(&quot;%lld\n&quot;,a[n+1]-a[n]);        }        else         {            printf(&quot;%lld\n&quot;,min(a[n+2]-a[n-1],a[n+1]-a[n]));        }    }    return 0;}</code></pre><h1 id="C：题目名称"><a href="#C：题目名称" class="headerlink" title="C：题目名称:"></a>C：题目名称:</h1><p>Anu Has a Function</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>定义一个函数f(<em>x</em>,<em>y</em>)=f(<em>x</em>∣<em>y</em>)−<em>y</em>。给定一个长度为 n数列 a，定义f(f..f(f(a1,a2),a3),…an−1),an)为这个数列的值。现在，请你将数列改变一种顺序，使得最后的值最大。输出你改变后的数列。(n&lt;=100000).</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>看样例找规律，假如将数字x分解成二进制，从右到左依次为第1位，第2位…第n位，将数字y分解成二进制，从左到右依次位第1位，第2位…第m位。那么对于f(x,y)=f(x|y)-y，可以当作每一位进行操作，假如第i位，xi=1，yi=1，则结果为0；如果xi=0，yi=1，则结果为0；如果xi=1，yi=0，则结果为1；如果xi=0，yi=0，则结果为0；综上所述，无论xi是否为1，只要yi为1，最后结果一定为0，只要yi=0，那结果一定等于xi。推广到n个数字，假如x存在i(xi==1)，使得剩下的n-1个数字yi==0，那么最后结果一定包含xi。为了使最后结果最大，就要让那独有的xi越大的越排在前面，其余的自由输出即可。(实际上就是将最大xi对应的数字单独输出，其余的自由输出)</p><p><strong>ps</strong>:0&lt;=ai&lt;=10^9，二进制位数设为40位即可。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;int w[42][maxn],n,vis[maxn];long long a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i]);        long long x=a[i],opt=1;        while(x)        {            long long y=x%2;            x/=2;            if(y==1)w[opt][++w[opt][0]]=i;            opt++;        }    }    for(int i=40;i&gt;=1;i--)    {        if(w[i][0]==1&amp;&amp;!vis[w[i][1]])        {            printf(&quot;%d &quot;,a[w[i][1]]);            vis[w[i][1]]=1;        }    }    for(int i=1;i&lt;=n;i++)    {        if(!vis[i])        {            printf(&quot;%d &quot;,a[i]);        }    }    cout&lt;&lt;endl;    return 0;}</code></pre><h1 id="D：题目名称："><a href="#D：题目名称：" class="headerlink" title="D：题目名称："></a>D：题目名称：</h1><p>Aerodynamic</p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个由n个点组成的<strong>严格</strong>（不存在三点共线）凸多边形。你要将这个图形平移n次，每次将一个顶点与原点 (0,0)重合。请判断这 n 个平移后的多边形除了与原点重合的点之外的点组成的多边形是否与原图形相似。在读入中，保证输入的点按逆时针顺序排列，形成严格凸多边形。3≤<em>n</em>≤10^5.</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>根据题意找规律，先观察n=3的情况，n=3使三角形拼接出来的不是三角形，而是六边形。n=4(正方形)刚好是一个新的正方形，而矩形也可以，不规则的则不行。n=5的显然和n=3一样不行。n=6(正六边形)用画图工具一画刚好符合。这时候结论就出来了：若是奇数边一定不行，若位偶数边就看它是否是中对称图形，即枚举前n/2个点i与它的对顶点n/2+i的中心点是否都是同一个点 (这里尽量不要除法，直接用乘法，免得丢失精度)，如果是中对称就符合，否则就不符合。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;long long n;struct node{    long long x,y;}a[maxn];int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)    {        scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y);    }    if(n%2==1)    {        printf(&quot;nO\n&quot;);    }    else     {        int sign=0;        long long midx=a[1].x+a[n/2+1].x;        long long midy=a[1].y+a[n/2+1].y;//不要用除法，要错。。。         for(int i=1;i&lt;=n/2;i++)        {            long long ansx=a[i].x+a[n/2+i].x;            long long ansy=a[i].y+a[n/2+i].y;            if(ansx!=midx||ansy!=midy)            {                sign=1;                break;            }        }        if(sign==1)        {            printf(&quot;nO\n&quot;);        }        else         {            printf(&quot;YES\n&quot;);        }    }    return 0;}</code></pre><h1 id="E：题目名称："><a href="#E：题目名称：" class="headerlink" title="E：题目名称："></a>E：题目名称：</h1><p>Water Balance</p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个序列，每次可以将一个区间内的所有数都变成操作前这个区间的平均数，求最后能得到的字典序最小的结果。  </p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>一共有n个数字，要使得它越靠前的数字越小，变小的方法就是和后面的数字求平均值。让输出这个字典序最小的结果。看数据范围，显然线性是最好的，如何进行线性的操作呢？考虑从1开始，初始使n个数字每个占一个区域块，一旦枚举到的数字可以使前面区域块的平均值减小就合并。详细一点说明：比如枚举到第i个数字，当前有tot个区域块，改区域块的总值为w[tot],所含数字个数t[tot],如果数字a[i]可以使这个区域块的值减小，那么用g表示当前所含个数总数，ans表示当前所含总值，那么g=1+t[tot],ans=a[i]+w[tot],然后再往前判断能否让前面的区域块减小，一直往前推，直到不符合。然后进行区域块的合并。如果a[i]==w[tot]/t[tot]，可以直接合并。如果a[i]&gt;w[tot]/t[tot],则i单独为一个区域块。</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int n,tot,t[maxn];double a[maxn],w[maxn];int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;a[i]);    for(int i=1;i&lt;=n;i++)    {        if(a[i]&lt;w[tot]/(double)t[tot])        {            int opt=tot,g=1;double ans=a[i];            while(opt&gt;=1)            {                g+=t[opt];ans+=w[opt];                if(ans/(double)g&lt;w[opt]/t[opt])                {                    opt--;                }                else                 {                    g-=t[opt];ans-=w[opt];opt++;                    break;                }            }            if(opt==0)opt=1;            tot=opt;            w[tot]=ans;t[tot]=g;        }        else if(a[i]*t[tot]==w[tot]&amp;&amp;tot!=0)        {            t[tot]++;            w[tot]+=a[i];        }        else         {            tot++;t[tot]=1;            w[tot]=a[i];        }    }    for(int i=1;i&lt;=tot;i++)    {        for(int j=1;j&lt;=t[i];j++)        {            printf(&quot;%.9lf\n&quot;,w[i]/t[i]);        }    }    return 0;}</code></pre>         <div id="aplayer-pLqMQBFo" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-pLqMQBFo"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1307</title>
    <link href="/2020/02/18/CodeForces-1307/"/>
    <url>/2020/02/18/CodeForces-1307/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A:题目名称："></a>A:题目名称：</h1><p> Cow and Haybales </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>t组数据，每组数据n堆，有d天，每天可以相邻的堆直接移动物品，每次移动物品数质可以为1，或者不移动。问d天后，第一堆最多有多少个物品。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>每天只能再相邻堆移动1个物品。直接考虑模拟，从最近的地方往前移动，并且一直移动同一个物品，直到它移动到第一堆的地方。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200+5;int T,n,m,a[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);        if(n==1)        {            printf(&quot;%d\n&quot;,a[1]);            continue;        }        while(m)        {            int t=2;            while(t&lt;=n-1&amp;&amp;a[t]==0)//WA1            {                t++;            }            if(t==n&amp;&amp;a[t]==0)            break;            else             {                a[t]--;                a[t-1]++;            }            m--;        }        printf(&quot;%d\n&quot;,a[1]);    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p> Cow and Friend</p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有t只兔子，每只兔子有n个喜欢的数字，并且它想一共跳x的距离(即从 (0，0)跳到(x，0))。每次跳跃都跳的距离只能是自己喜欢的数字。问至少跳几次？</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>看了一下样例，感觉很像是贪心，于是模拟了一下，首先找到最大的喜欢的数字，假设maxx<x，并且2 * maxx>x，那么最多跳两次就够了，成等腰三角形，中间的倾角视情况而定，但是一定是可以的，原因：maxx+maxx&gt;x符合三角形的定义。假设maxx<x，并且2 * maxx<x(等于的情况必然是2)，如果x%maxx==0，那么直接沿着x轴跳x/maxx次就可以了，否则跳x/maxx+1次，(起点和终点相连接的边做调整，使得剩余长度是maxx的倍数就可以了)。如果maxx>x，如果有喜欢的数字==x，就跳1次，否则就2次。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long T,n,t;int main(){    scanf(&quot;%lld&quot;,&amp;T);    while(T--)    {        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;t);        long long maxx=0;int sign=0;        for(int i=1;i&lt;=n;i++)        {            long long x;            scanf(&quot;%lld&quot;,&amp;x);            if(x==t)sign=1;            maxx=max(maxx,x);        }        if(maxx&gt;t)        {            if(sign==1)            printf(&quot;1\n&quot;);            else             printf(&quot;2\n&quot;);            continue;        }        if(t%maxx==0)        {            printf(&quot;%lld\n&quot;,t/maxx);        }        else         {            printf(&quot;%lld\n&quot;,t/maxx+1);        }    }    return 0;}</code></pre><h1 id="C：题目名称："><a href="#C：题目名称：" class="headerlink" title="C：题目名称："></a>C：题目名称：</h1><p>Cow and Message</p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求串s中出现次数最多的子序列t的出现次数。其中子序列在s中所对应的下标必须构成等差数列。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>英语差的锅。一开始被题意神奇迷惑。以为只有某个子串的下标构成了等差数列那么这一类都可以了。这就是一开始觉得方法始终不对的原因。设想子串长度都为1或者2，那么它必然符合题意。如果子串长度为3呢？那么中间只有1个可以符合。这样数量就大大减少了。于是猜测子串长度都为1或者2。都为1即统计每种字母出现的次数然后取max。对于子串长度为2，枚举当前字母i，然后枚举匹配字母j(i!=j)，再枚举起点，并且预处理每个结点之后26个字母每个字母的个数，然后计算。最后还需要求同种字母的情况，即w[i]*(w[i]-1)/2,最后取max就是答案。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+5;long long a[maxn][30],w[30];char s[maxn];int main(){    scanf(&quot;%s&quot;,s+1);    int len=strlen(s+1);    for(int i=len;i&gt;=1;i--)    {        int x=s[i]-&#39;a&#39;+1;        a[i-1][x]=a[i][x]+1;        for(int j=1;j&lt;=26;j++)        {            if(j==x)continue;            a[i-1][j]=a[i][j];        }        w[x]++;    }    long long ans=0;    for(int i=1;i&lt;=26;i++)    {        for(int k=1;k&lt;=26;k++)        {            if(i==k)continue;            long long tot=0;            for(int j=1;j&lt;=len;j++)            {                if(s[j]==i-1+&#39;a&#39;)                {                    tot+=a[j][k];                }            }                ans=max(ans,tot);        }    }    for(int i=1;i&lt;=26;i++)    {        ans=max(ans,w[i]);        ans=max(ans,w[i]*(w[i]-1)/2);    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><h1 id="D：题目名称："><a href="#D：题目名称：" class="headerlink" title="D：题目名称："></a>D：题目名称：</h1><p>Cow and Fields</p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个点，m条道路(双向)，k个特殊点，给定m条边，每条边长度为1，在k个特殊点种选取两个点连接，使得从1到n最短路径要尽量长。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>首先要得到每个点到起点1的距离和到终点n的距离，直接以1为起点跑一次dijksta+堆优化，再以n为起点跑依次dijkstra+堆优化。设最短路径长度为minn，则要求min(minn,min(dist1[i]+dist2[j]+1,dist1[j]+dist2[i]+1)),假设再i和j之间连边，可能是i更靠近1，也可能是j更靠近1，所以求1-n的最短路径长度时取min(dist1[a[i]]+dist2[a[j]]+1,dist1[a[j]]+dist2[a[i]]+1);但是这样的时间复杂度是k * k显然不符合，需要优化，优化的切入点就是a[i]和a[j]之间的关系。假如a[i]始终比a[j]更靠近起点1，那么答案就是min(minn,dist1[a[i]]+dist2[a[j]]+1);并且假设i是最靠近j的并且比j更靠近起点1的特殊点。那么答案就是min(minn,dist1[a[i]]+dist2[a[i]+1]+1);那要如何让a数组种的元素按照到起点的距离进行递增呢？按照前面的假设可得dist1[a[i]]+dist2[a[j]]+1&lt;dist1[a[j]]+dist2[a[i]]+1(i比j更靠近起点1)，即dist1[a[i]]-dist2[a[i]]&lt;dist1[a[j]]-dist2[a[j]];所以直接sort(要求dist1[a[i]]-dist2[a[i]]&lt;dist1[a[j]]-dist2[a[j]])，排序之后就是按照距离起点的距离递增排列了。那么就可以线性找到答案了。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;int n,m,q,head[maxn],dist1[maxn],dist2[maxn],a[maxn],k=1,s,t,vis[maxn];struct node{    int to,next,w,u;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].u=u;}struct N{    int now,w;    bool operator &lt; (N x)const{return x.w&lt;w;}};void dijkstra1(){    priority_queue&lt;N&gt;q;    memset(dist1,0x3f3f3f3f,sizeof(dist1));    memset(vis,0,sizeof(vis));    dist1[s]=0;    N x;x.now=s;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist1[edge[i].to]&gt;dist1[x.now]+edge[i].w)            {                dist1[edge[i].to]=dist1[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist1[edge[i].to];                q.push(now);            }        }    }}void dijkstra2(){    priority_queue&lt;N&gt;q;    memset(dist2,0x3f3f3f3f,sizeof(dist1));    memset(vis,0,sizeof(vis));    dist2[s]=0;    N x;x.now=s;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist2[edge[i].to]&gt;dist2[x.now]+edge[i].w)            {                dist2[edge[i].to]=dist2[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist2[edge[i].to];                q.push(now);            }        }    }}int cmp(int x,int y){    return dist1[x]-dist2[x]&lt;dist1[y]-dist2[y];}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);    for(int i=1;i&lt;=q;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i=1;i&lt;=m;i++)    {        int a,b;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b,1);add(b,a,1);    }    s=1;t=n;    dijkstra1();    s=n;t=1;    dijkstra2();    int ans=0;    int minn=dist1[n];    sort(a+1,a+1+q,cmp);    for(int i=2;i&lt;=q;i++)    {        ans=max(ans,dist1[a[i-1]]+dist2[a[i]]+1);    }    ans=min(ans,minn);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-CuuzNQXI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CuuzNQXI"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1304</title>
    <link href="/2020/02/16/CodeForces-1304/"/>
    <url>/2020/02/16/CodeForces-1304/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A-题目名称："><a href="#A-题目名称：" class="headerlink" title="A: 题目名称："></a>A: 题目名称：</h1><p> Two Rabbits </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，给定x，y，a，b。其中x，y分别为两兔子的坐标(x&lt;y),a，b分别为对应兔子的速度，左边的兔子向右跳，右边的兔子向左跳，问能否相遇，若能请输出时间t，否则输出-1.</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>设delt=y-x，若delt%(a+b)则t=delt/(a+b),否则输出-1.</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long t,x,y,a,b;int main(){    scanf(&quot;%lld&quot;,&amp;t);    while(t--)    {        scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;a,&amp;b);        long long delt=abs(y-x);        if(delt%(a+b)==0)        {            long long t=delt/(a+b);            printf(&quot;%d\n&quot;,t);            continue;        }        else         {            printf(&quot;-1\n&quot;);            continue;        }    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p> Longest Palindrome </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定n个字符串，每个字符串的长度为m，可以任意选择若干个字符串随机组合构成最长的回文串，如果有多个这样的回文串，任意输出一个即可，如果没有则输出0.</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>枚举所有的字符串，找到两个字符串中：字符串i从头到尾等于字符串j的丛尾到头。这样i和j可以配对，并且标记一下。最后还要考虑一种情况：一个字符串本身就是回文，它可以放在中间，并且它没有被标记过，找到一个即可。最后判断是否存在，若无则输出0，否则先输出长度ans <em> 2 </em> m+Ans * m，然后先输出前面部分的字符串，并储存方便后面逆序输出，然后输出中间部分，若不存在则不管。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int n,m,vis[maxn],stack[maxn],V[maxn];char s[maxn][maxn],t[maxn*maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)scanf(&quot;%s&quot;,s[i]);    int ans=0,Ans=0;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(i==j||vis[i]||vis[j])continue;            int sign=0;            for(int k=0;k&lt;m;k++)            {                if(s[i][k]!=s[j][m-k-1])                {                    sign=1;                    break;                }            }            if(sign==0)            {                vis[i]=j;vis[j]=i;                ans++;                stack[ans]=i;            }        }    }    for(int i=1;i&lt;=n;i++)    {        if(vis[i])continue;        int sign=0;        for(int j=0;j&lt;m;j++)        {            if(s[i][j]!=s[i][m-j-1])            {                sign=1;                break;            }        }        if(sign==0)        {            Ans++;            V[Ans]=i;            break;        }    }    if(ans==0&amp;&amp;Ans==0)    {        printf(&quot;0\n&quot;);    }    else     {        printf(&quot;%d\n&quot;,ans*2*m+Ans*m);        int now=0;        for(int i=1;i&lt;=ans;i++)        {            printf(&quot;%s&quot;,s[stack[i]]);            for(int j=0;j&lt;m;j++)            {                t[++now]=s[stack[i]][j];            }        }        if(Ans)        {            printf(&quot;%s&quot;,s[V[Ans]]);        }        for(int i=now;i&gt;=1;i--)        printf(&quot;%c&quot;,t[i]);        cout&lt;&lt;endl;    }    return  0;}</code></pre><h1 id="C：题目名称："><a href="#C：题目名称：" class="headerlink" title="C：题目名称："></a>C：题目名称：</h1><p> Air Conditioner </p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有q组数据，每组数据给定顾客数n，和初始温度m，然后再给定每个顾客到达的时间，和适应的最低温度和最高温度， 每一分钟可以选择升高温度1，降低温度1，或者不变。问能否满足所有的顾客，能则YES，否则NO。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>一开始我以为是贪心，结果准备统计所有的空闲时间并且与调整时间来比大小，结果不对，完全错误，于是又想DP，但是数据10^9，没办法写出DP方程，然后突然想到了区间，既然给定了左右端点，那不就可以得到每个顾客到达那一刻温度可调整的区间吗？只要这个区间和顾客适应的区间存在交点那就符合。并且保证判断之后这个区间要修改到顾客适应的区间的范围内(一开始以为既然符合情况了就不会存在超出范围的情况了，其实完全可能某一端点无法在限定时间内缩回去，所以超出的必须除去)，因为当前温度超出顾客的适应范围就不符合要求了。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=500+5;long long T,n,t,x,y;struct node{    long long t,x,y;}a[maxn];int main(){    scanf(&quot;%lld&quot;,&amp;T);    while(T--)    {        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;t);        x=y=t;        for(int i=1;i&lt;=n;i++)        scanf(&quot;%lld%lld%lld&quot;,&amp;a[i].t,&amp;a[i].x,&amp;a[i].y);        long long now=1;        long long sign=0;        while(now&lt;=n)        {            long long delt=a[now].t-a[now-1].t;            if(x&lt;a[now].x)            {                x+=delt;                if(x&gt;a[now].x)                x=a[now].x;            }            else if(x&gt;a[now].x)            {                x-=delt;                if(x&lt;a[now].x)                x=a[now].x;            }            if(y&lt;a[now].y)            {                y+=delt;                if(y&gt;a[now].y)                y=a[now].y;            }            else if(y&gt;a[now].y)            {                y-=delt;                if(y&lt;a[now].y)                y=a[now].y;            }            if((x&lt;a[now].x&amp;&amp;y&lt;a[now].x)||(x&gt;a[now].y&amp;&amp;y&gt;a[now].y))            {                sign=1;                printf(&quot;NO\n&quot;);                break;            }            if(x&lt;a[now].x)x=a[now].x;            if(y&gt;a[now].y)y=a[now].y;            now++;        }        if(sign==0)        {            printf(&quot;YES\n&quot;);        }    }    return 0;}</code></pre><hr><h1 id="补题："><a href="#补题：" class="headerlink" title="补题："></a>补题：</h1><h1 id="D：题目名称："><a href="#D：题目名称：" class="headerlink" title="D：题目名称："></a>D：题目名称：</h1><p> Shortest and Longest LIS </p><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有t组数据，每组数据给定一个n，说明数字1-n，然后给定n-1个&gt;/&lt;，让排出符合要求的数字排列，第一个要求最长上升序列是最短的，第二个要求最长上升序列是最短的。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>贪心+模拟。首先考虑第一问，观察一下答案，发现凡是小于(不连续)的都是从左到右依次减小，而大于的都是左边的尽量大，右边的尽量小。可以设想：要让最长上升序列最短，那么&lt;对应的数字就要比它左边的&lt;对应的数字更小，这样就可以进行隔断，来缩小长度；而左边&gt;对应的数字就是比右边&gt;对应的数字更小，这样的话越右边的数字就越小，这样也可以缩小长度。于是对于问题一的做法就很简单了：设minn=1,maxx=n，因为越右边的&lt;对应的数字越小，所有我们从右向左枚举，一旦枚举到s[i]==’&lt;’就让a[i]=minn并且minn++，但是现在问题来了：如果&lt;重复了呢？(如&lt;&lt;,&lt;&lt;&lt;等等)再如此做的话就与’&lt;’的定义矛盾了，于是这时候就需要找到这一串连续的 ‘&lt;’的左端点，然后从左端点到右端点依次让a[j]=minn并且minn++。枚举结束后让i=now+1，这样就实现了跳转，依旧是线性的。然后对于’&gt;’，要让左边的尽量大，所以我们从左向右枚举，如果s[i]==’&gt;’,那么a[i]=maxx，maxx—；最后a[n]=maxx;这样再输出a数组，问题1就解决了。</p><p>那问题2呢？</p><p>问题2要求的是最长上升序列最长，就与问题1相反，对于’&lt;’就从左往右依次增大，对于’&gt;’就从右往左依次减小，方法与问题基本一样，但是要注意连续的’&gt;’的情况，处理方式与连续的’&lt;’类似，如果s[n-1]即最后一个符号是 &lt;，那么就让a[n]=n,这里特判一下即可。</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;int T,n;char s[maxn];int a[maxn],maxx,minn;int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%s&quot;,s+1);        maxx=n;minn=1;        for(int i=n-1;i&gt;=1;i--)        {            if(s[i]==&#39;&lt;&#39;&amp;&amp;s[i-1]!=&#39;&lt;&#39;)            {                a[i]=minn;                minn++;            }            else if(s[i]==&#39;&lt;&#39;&amp;&amp;s[i-1]==&#39;&lt;&#39;)            {                int now=i;                while(s[now]==&#39;&lt;&#39;&amp;&amp;now&gt;=1)now--;                for(int j=now+1;j&lt;=i;j++)                {                    a[j]=minn;                    minn++;                }                i=now+1;            }        }        for(int i=1;i&lt;=n-1;i++)        {            if(s[i]==&#39;&gt;&#39;)            {                a[i]=maxx;                maxx--;                }        }        a[n]=maxx;        for(int i=1;i&lt;=n;i++)        printf(&quot;%d &quot;,a[i]);        cout&lt;&lt;endl;        maxx=n,minn=1;        for(int i=1;i&lt;=n-1;i++)        {            if(s[i]==&#39;&lt;&#39;)            {                a[i]=minn;                minn++;            }        }        if(s[n-1]==&#39;&lt;&#39;)        {            a[n]=n;maxx--;        }        for(int i=n-1;i&gt;=1;i--)        {            if(s[i]==&#39;&gt;&#39;&amp;&amp;s[i-1]!=&#39;&gt;&#39;)            {                a[i]=maxx;                maxx--;            }            else if(s[i]==&#39;&gt;&#39;&amp;&amp;s[i-1]==&#39;&gt;&#39;)            {                int now=i;                while(s[now]==&#39;&gt;&#39;&amp;&amp;now&gt;=1)now--;                for(int j=now+1;j&lt;=i;j++)                {                    a[j]=maxx;                    maxx--;                }                i=now+1;            }        }        if(s[n-1]!=&#39;&lt;&#39;)        {            a[n]=maxx;        }        for(int i=1;i&lt;=n;i++)        {            printf(&quot;%d &quot;,a[i]);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre><h1 id="E：题目名称："><a href="#E：题目名称：" class="headerlink" title="E：题目名称："></a>E：题目名称：</h1><p> 1-Trees and Queries </p><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个n个点的树,相邻点的距离为1 。</p><p>q个询问，每个询问包含无个整数： x,y,a,b,k。</p><p>含义是：在原树上新连上一条边 (x,y) ，要求判断一下从a点是否有距离为k的到b的路径。</p><p>注意：</p><ul><li>每个询问是独立的，即上次询问加上的边，不能为这一次的询问所用。</li><li>这一条路径也许会重复经过某一条边或某一点。</li></ul><p>(q&lt;=10^5,n&lt;=10^5)</p><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><p>由题知此图是树，任意两点之间的最短距离是确定唯一的。有q个操作，每次操作会加入两种新边，一共就有三种边(对于在无关路径上来回移动的不考虑)，很显然每次新加入边之后，受到直接影响的是端点x，y。它将改变a—&gt;b的路径方式。考虑新的路径必然是将端点a，b作为切入点。(必须要走新加入的边，因为这个边是改变路径方式的唯一方式！)</p><p>路径1：a—&gt;b；</p><p>路径2：a—&gt;x x—&gt;y(即新加的边) y—&gt;b</p><p>路径3：a—&gt;y y—&gt;x(即新加的边) x—&gt;b</p><p>那么就开始求路径1，2，3的长度。如何求呢？肯定需要用到LCA了。为了方便，设点1为起点，并且deep[1]=0,假如要求点a，b的距离，那么就要分两种情况：</p><p>情况1：a，b其中一点是另一个点的祖先，那么s=abs(deep[a]-deep[b]);</p><p>情况2：f1是点a，b的最近公共祖先，那么s=deep[a]+deep[b]-deep[f1]*2(第一次交就因为没×2 WA了)</p><p>对于路径1的s：</p><pre><code class="lang-cpp">        f1=lca(x,y);        if(f1==x||f1==y)        s1=abs(deep[x]-deep[y]);        else        s1=deep[x]+deep[y]-deep[f1]*2;</code></pre><p>对于路径2的s：</p><pre><code class="lang-cpp">        f1=lca(x,a);f2=lca(b,y);//因为是两条边，自然两边的LCA都要求        if(f1==x||f1==a)        s1=abs(deep[x]-deep[a]);        else         s1=deep[x]+deep[a]-deep[f1]*2;        if(f2==b||f2==y)        s1=s1+abs(deep[b]-deep[y]);        else         s1=s1+deep[b]+deep[y]-deep[f2]*2;        s1+=1;//必须要走新加入的边，因为这个边是改变路径方式的唯一方式！</code></pre><p>对于路径3的s：(同路径2类似)</p><pre><code class="lang-cpp">        f1=lca(x,b);f2=lca(a,y);        if(f1==x||f1==b)        s1=abs(deep[x]-deep[b]);        else         s1=deep[x]+deep[b]-deep[f1]*2;        if(f2==a||f2==y)        s1=s1+abs(deep[a]-deep[y]);        else         s1=s1+deep[a]+deep[y]-deep[f2]*2;        s1+=1;</code></pre><p>最后如何判定s是否符合要求呢？</p><p>首先明确一下，如果如果剩余了偶数的长度，其实就可以在终点和它相邻的点之间来回走，直到走完为止。当然要确保k足够提前到达终点。</p><p>所以判定条件就是(k-s1)&gt;=0&amp;&amp;(k-s1)%2==0。三条路径任意一条满足即可，否则就NO。</p><p><strong>ps</strong>:我人傻了，为什么要分情况啊，直接s1=deep[a]+deep[b]-deep[f1]*2就可以了啊;</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=100000+5;long long K=1,n,q,head[maxn],father[maxn][22],vis[maxn],deep[maxn];struct node{    long long to,next;}edge[maxn*2];void add(long long u,long long v){    edge[++K].to=v;edge[K].next=head[u];head[u]=K;}long long dfs(long long x,long long depth){    deep[x]=depth;vis[x]=1;    for(long long i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            father[edge[i].to][0]=x;            dfs(edge[i].to,depth+1);        }    }}long long lca(long long x,long long y){    if(deep[x]&lt;deep[y])swap(x,y);    long long depth=deep[x]-deep[y];    for(long long i=20;i&gt;=0;i--)    {        if(depth&amp;(1&lt;&lt;i))        {            x=father[x][i];        }    }    if(x==y)return x;    for(long long i=20;i&gt;=0;i--)    {        if(father[x][i]!=father[y][i])        {            x=father[x][i];y=father[y][i];        }    }    return father[x][0];}int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;n;i++)    {        long long a,b;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        add(a,b);add(b,a);    }    dfs(1,0);    for(long long i=1;i&lt;=20;i++)    {        for(long long j=1;j&lt;=n;j++)        {            father[j][i]=father[father[j][i-1]][i-1];        }    }    scanf(&quot;%lld&quot;,&amp;q);    for(long long i=1;i&lt;=q;i++)    {        long long a,b,x,y,k,f1,f2,s1;//新加a--b         long long sign=0;        scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;x,&amp;y,&amp;k);        f1=lca(x,y);        if(f1==x||f1==y)        s1=abs(deep[x]-deep[y]);        else        s1=deep[x]+deep[y]-deep[f1]*2;        if((k-s1)&gt;=0&amp;&amp;(k-s1)%2==0)        {            sign=1;            printf(&quot;YES\n&quot;);            continue;        }        f1=lca(x,a);f2=lca(b,y);        if(f1==x||f1==a)        s1=abs(deep[x]-deep[a]);        else         s1=deep[x]+deep[a]-deep[f1]*2;        if(f2==b||f2==y)        s1=s1+abs(deep[b]-deep[y]);        else         s1=s1+deep[b]+deep[y]-deep[f2]*2;        s1+=1;        if((k-s1)&gt;=0&amp;&amp;(k-s1)%2==0)        {            sign=1;            printf(&quot;YES\n&quot;);            continue;        }        f1=lca(x,b);f2=lca(a,y);        if(f1==x||f1==b)        s1=abs(deep[x]-deep[b]);        else         s1=deep[x]+deep[b]-deep[f1]*2;        if(f2==a||f2==y)        s1=s1+abs(deep[a]-deep[y]);        else         s1=s1+deep[a]+deep[y]-deep[f2]*2;        s1+=1;        if((k-s1)&gt;=0&amp;&amp;(k-s1)%2==0)        {            sign=1;            printf(&quot;YES\n&quot;);            continue;        }        if(sign==0)        {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-SAtpHMRh" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-SAtpHMRh"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-1303</title>
    <link href="/2020/02/15/CodeForces-1303/"/>
    <url>/2020/02/15/CodeForces-1303/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A：题目名称："><a href="#A：题目名称：" class="headerlink" title="A：题目名称："></a>A：题目名称：</h1><p>  Erasing Zeroes </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>删除最少的0，使所有的1连续，问删除多少个0？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>找到最后一个1的位置，和开头1的位置，枚举中间0的个数</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int T;char s[105];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%s&quot;,s);        int sign=0,ans=0,t=0;        for(int i=strlen(s);i&gt;=0;i--)        {            if(s[i]==&#39;1&#39;)            {                t=i;                break;            }        }        for(int i=0;i&lt;=t;i++)        {            if(!sign)            {                if(s[i]==&#39;1&#39;)                {                    sign=1;                }            }            else if(sign==1)             {                if(s[i]==&#39;0&#39;)                {                    ans++;                }            }        }        if(sign==0)ans=0;        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="B：题目名称："><a href="#B：题目名称：" class="headerlink" title="B：题目名称："></a>B：题目名称：</h1><p>National Project </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>修一条长n的路，连续g天修的好路，连续b天修的坏路，好路至少占一半，问要修完这条路至少几天？(一天只修长度1的路)</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>先特判：n如果&lt;=g||(n/2&lt;=g&amp;&amp;n&gt;=g)直接修n天</p><p>分n为奇数和偶数判断，先找到修g天好路需要t个轮回。如果好路没修够，就需要延长1个轮回，这个轮回不一定完整。如果好路修够了，那么只需要看剩下多长没修，注意期间可以修坏路，最后求个总和。对于延长一个轮回的情况，要加上继续修好路的天数。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long T,n,g,b;int main(){    scanf(&quot;%lld&quot;,&amp;T);    while(T--)    {        scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;g,&amp;b);        long long p;        if(n%2==0)p=n/2;        else p=n/2+1;        if(n&lt;=g)        {            printf(&quot;%lld\n&quot;,n);            continue;        }        if(p&lt;=g&amp;&amp;n&gt;=g)        {            printf(&quot;%lld\n&quot;,n);            continue;        }        long long ans=0;        long long t=p/g;        long long yu=p-t*g;        if(yu==0)        {            long long t2=min(n-p,(t-1)*b);            long long yu2=n-p-t2;            ans=yu2+t*g+(t-1)*b;        }        else         {            long long t2=min(n-p,t*b);            long long yu2=n-p-t2;            ans=yu2+t*(b+g)+yu;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-yGAixyaQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-yGAixyaQ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces-620</title>
    <link href="/2020/02/14/CodeForces-620/"/>
    <url>/2020/02/14/CodeForces-620/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="A：题目名称："><a href="#A：题目名称：" class="headerlink" title="A：题目名称："></a>A：题目名称：</h1><p>Professor GukiZ’s Robot </p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>机器人很好玩</p><p>一开始在(x1,y1)</p><p>最后在(x2,y2)</p><p>每秒钟内横坐标最多变化1（也可以不变化）纵坐标也是</p><p>问最少几秒钟到 x1 和 x2 绝对值在10^9以内 。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>取两者坐标x，y相差的最大值，开longlong保平安。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){    long long x1,x2,y1,y2;    scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);    long long maxx=max(abs(x1-x2),abs(y1-y2));    printf(&quot;%lld\n&quot;,maxx);    return 0;}</code></pre><h1 id="B-题目名称："><a href="#B-题目名称：" class="headerlink" title="B:题目名称："></a>B:题目名称：</h1><p> Grandfather Dovlet’s calculator </p><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>从0-9每一个数字由若干个小木棍组成，给定a，b，问搭出a-b的每一个数字需要多少个小木棍。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>t[i]表示数字i需要的木棍(i∈[0,9]),然后枚举。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long a,b,t[10]={6,2,5,5,4,5,6,3,7,6};int main(){    long long ans=0;    scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);    for(long long i=a;i&lt;=b;i++)    {        long long now=i;        while(now)        {            long long x=now%10;            now/=10;            ans+=t[x];        }    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><h1 id="C：题目名称："><a href="#C：题目名称：" class="headerlink" title="C：题目名称："></a>C：题目名称：</h1><p> Pearls in a Row </p><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>现在有N个数，你的任务是将这N个数尽可能切割成多段。每一段必须包括两个相同的数。 </p><p>输出的第一行为尽可能切割的最大段数K。</p><p>接下来K行，每行为两个整数lj, rj (1 ≤lj ≤ rj ≤ <em>n</em>) ，表示切割的区间范围</p><p>如果存在多个合法的切割方法，输出任意一个即可。</p><p>如果不能切割成合法的情况，输出”-1”.</p><p>数据第一行为N(1 ≤ <em>N</em> ≤ 3·105) 。</p><p>数据的第二行包括N个数ai(1 ≤ a[i] ≤ 109) 。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>看到N&lt;=300000，然后再看到a[i]的数据，由于答案只与二者是否相等有关，那么它的值就无关紧要了，所以直接离散化。离散化之后就是如何分割了，首先就想到了贪心，一旦又符合条件的就直接分割，如何考虑这个分案的合理性呢？假设区间 [x,y]为一段，a[x]==a[y],如果w∈(x,y),z&gt;y,那么我们也必须选择[x,y] ,否则区间(x,w)不符合题意。如果我们遇到有两个相等了而不分割，这样并不能使数量增加，所以每遇到两个相等就立即分割，这样受到影响的只有最后一段，因为最后一段可能无法成立，那它直接与前一段合并，即前一段的l[opt]=n就可以了。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long maxn=300000+5;long long n,a[maxn],b[maxn],vis[maxn],opt,l[maxn],r[maxn];int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(long long i=1;i&lt;=n;i++)    {        scanf(&quot;%lld&quot;,&amp;a[i]);         b[i]=a[i];    }    sort(b+1,b+1+n);    long long tot=unique(b+1,b+1+n)-b-1;        for(long long i=1;i&lt;=n;i++)    {        a[i]=lower_bound(b+1,b+1+tot,a[i])-b;    }    for(long long i=1;i&lt;=n;i++)    {        if(vis[a[i]]==opt+1)        {            vis[a[i]]=0;            opt++;            l[opt]=r[opt-1]+1;            r[opt]=i;        }        else        {            vis[a[i]]=opt+1;        }    }    if(opt==0)    {        printf(&quot;-1\n&quot;);        return 0;    }    if(r[opt]!=n)    r[opt]=n;    printf(&quot;%lld\n&quot;,opt);    for(long long i=1;i&lt;=opt;i++)    {        printf(&quot;%lld %lld\n&quot;,l[i],r[i]);    }    return 0;}</code></pre><p><strong>ps</strong>：一开始一直WA，原因使if，else那段写反了，注意每一个vis[a[i]]都需要修改！</p>        <div id="aplayer-JogxhmFt" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-JogxhmFt"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu-1640</title>
    <link href="/2020/02/13/luogu-1640/"/>
    <url>/2020/02/13/luogu-1640/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>luogu1640-[SCOI2010]连续攻击游戏</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://www.luogu.com.cn/problem/P1640" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1640</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个装备，每个装备有两个攻击值，每个装备只能用1次，问从1开始可以连续攻击几次？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>虽然有很多并查集的方法，但是最近一直在练习二分图匹配，发现这个题可以用二分图来做，主要是因为每个装备只有两个攻击值这样的话可以大大减少时间复杂度，很显然这个地方就是突破点，设想每个攻击值x，y对装备i建单向边，然后从1开始跑匈牙利算法，一旦找不到匹配说明攻击中断，当前的最大匹配ans就是最多能连续攻击的次数，但是注意一下不可以memset(vis,0,sizeof(vis))，处理方法很简单，vis只是防止当前dfs不能重复点，于是vis[edge[i].to]=x，相当于一个时间戳，就可以完美避免初始化了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int k=1,head[maxn],vis[maxn],cy[maxn],n;struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(vis[edge[i].to]==x)continue;        vis[edge[i].to]=x;        if(cy[edge[i].to]==-1||dfs(cy[edge[i].to]))        {            cy[edge[i].to]=x;            return 1;        }    }    return 0;}int main(){    int maxx=0;    scanf(&quot;%d&quot;,&amp;n);    memset(cy,-1,sizeof(cy));    for(int i=1;i&lt;=n;i++)    {        int x,y;        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        maxx=max(maxx,y);        add(x,i);add(y,i);    }    int ans=0;    for(int i=1;i&lt;=maxx;i++)    {    //    memset(vis,0,sizeof(vis));        if(dfs(i))        {            ans++;        }        else break;    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>         <div id="aplayer-LDhjFncT" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LDhjFncT"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3488</title>
    <link href="/2020/02/13/HDU-3488/"/>
    <url>/2020/02/13/HDU-3488/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-3488 Tour</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3488" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3488</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，n个点，m条有向边边(可能有重边)， 现在问将图中的每一个点都划分到一个环中的最少代价是多少？每条边都有一个代价 。即选择边，使得图是若干个有向环，除出发点(即终点)外每个点都只可以经过一次，如何选择花费最小？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这里需要提到一下<strong>有向环覆盖问题</strong>： 给一个N个顶点M条边的带权有向图，要你把该图分成一个或多个不相交的有向环。且所有定点都被有向环覆盖。问你该有向环所有权值的总和最小是多少? </p><p>答案就是：有向环最大权值覆盖=最佳匹配。 </p><p>如果，改为无向图，问你无向环最大权值覆盖？答案也是一样的。只是在建图的时候把有向改为无向即可。 </p><p><strong>分析</strong>：把任意一个顶点i分成连个点，即i和i‘，如果原图存在边i—&gt;j，那么二分图就存在i—&gt;j’</p><p><strong>引理</strong>： </p><p>①  如果原图能由多个不相交的有向环覆盖，那么二分图必然存在完备匹配。 二者互为充要条件 。即： 二分图存在完备匹配,那么原图必定能由几个不相交的有向环覆盖。</p><p>②  如果 即权值最大的有向环覆盖在数值上等于改图的最佳匹配值。原图存在权值最大的有向环覆盖，那么二分图的<strong>最佳匹配</strong>一定就是这个值。</p><p>因为该有向环覆盖对应了一个二分图的完备匹配,而该完备匹配的权值就等于该有向环覆盖的权值,所以最佳匹配不可能丢失该最大权值的匹配。 </p><p>(假设原图的有向环为(1-&gt;2-&gt;3-&gt;1) and(6-&gt;5-&gt;4-&gt;6),那么二分图的完备匹配就是1-&gt;2’ 2-&gt;3’ 3-&gt;1’ 6-&gt;5’ 5-&gt;4’ 4-&gt;6’)</p><p>(假设二分图的完备匹配是1-&gt;2’ 2-&gt;3’ 3-&gt;1’ 6-&gt;5’ 5-&gt;4’ 4-&gt;6’那么原图的有向环为(1-&gt;2-&gt;3-&gt;1) and (6-&gt;5-&gt;4-&gt;6))</p><p>由此，知道了如果一个二分图存在<strong>完备匹配</strong>，那么这个<strong>完备匹配</strong>一定是可以在原图构成有向环，题目既然给出了路径，并且一定可以组成有向环，那么二分图一定存在<strong>完备匹配</strong>，而且是求最小的代价，此时想到了KM是求<strong>最佳匹配</strong>，即边权最大的完备匹配，所以需要转换一下， 将边权转换为负值，初始化为-0x3f3f3f3f，然后wx也初始化为-0x3f3f3f3f，然后其余正常地跑KM，求得ans为最佳匹配，输出-ans即可</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=30000+5;const int maxm=200+5;int Map[maxm][maxm],visx[maxm],visy[maxm],wx[maxm],wy[maxm],cx[maxm],cy[maxm],T,n,m,minn;int dfs(int x){    visx[x]=1;    for(int i=1;i&lt;=n;i++)    {        if(!visy[i]&amp;&amp;Map[x][i]!=-0x3f3f3f3f)        {            int t=wx[x]+wy[i]-Map[x][i];            if(t==0)            {                visy[i]=1;                if(!cy[i]||dfs(cy[i]))                {                    cy[i]=x;                    cx[x]=i;                    return 1;                }            }            else             {                minn=min(minn,t);            }        }    }    return 0;}int KM(){    memset(cy,0,sizeof(cy));    memset(cx,0,sizeof(cx));    memset(visx,0,sizeof(visx));    memset(visy,0,sizeof(visy));    for(int i=1;i&lt;=n;i++)wx[i]=-0x3f3f3f3f;    memset(wy,0,sizeof(wy));    minn=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            wx[i]=max(wx[i],Map[i][j]);        }    }    for(int i=1;i&lt;=n;i++)    {        while(1)        {            memset(visx,0,sizeof(visx));            memset(visy,0,sizeof(visy));            minn=0x3f3f3f3f;            if(dfs(i))break;            for(int i=1;i&lt;=n;i++)            {                if(visx[i])                {                    wx[i]-=minn;                }            }            for(int i=1;i&lt;=n;i++)            {                if(visy[i])                {                    wy[i]+=minn;                }            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        if(cx[i]!=0)        {            ans+=Map[i][cx[i]];        }    }    return ans;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                Map[i][j]=-0x3f3f3f3f;        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            Map[a][b]=max(Map[a][b],-c);        }        int ans=KM();        printf(&quot;%d\n&quot;,-ans);    }    return 0;}</code></pre>        <div id="aplayer-ASFwZEom" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ASFwZEom"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>KM</tag>
      
      <tag>有向环覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3189</title>
    <link href="/2020/02/13/POJ-3189/"/>
    <url>/2020/02/13/POJ-3189/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-3189 Steady Cow Assignment</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3189" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3189</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>这道题的题意是真的很坑人啊，首先答案是求所有牛对居住的牛棚最大喜欢度-最小喜欢度+1，就是求区间长度，不是让求最大值-最小值。然后矩阵i，j不是表示第i头牛对第j个牛棚的喜欢度，而是表示第i头牛心中排名第j的牛棚是map[i][j]，喜欢度就是指牛棚在牛心中的排名。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>每个牛棚是有容纳量的，所以会用到多重匹配，而如何找到最小的区间长度呢？区间长度=所有牛对居住的牛棚最大喜欢度-最小喜欢度+1，那么求出最大值-最小值就可以了，求最值问题，很容易就想到二分了，但是光二分又不够，这时候枚举最小值就可以了，二分<strong>最大值-最小值的值</strong>，然后跑匈牙利算法的多重匹配，对每一条边的边权要判断：edge[i].w&gt;=minn&amp;&amp;edge[i].w&lt;-=maxx，并且注意容纳量。跑出的最大匹配如果==n，就说明所有的牛都又牛棚，就符合题意，于是右边界就可以缩小，否则左边界增大，直到找到ans，注意在枚举最小值的时候要更新答案minn，最后minn+1就是区间长度。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1500+5;int k=1,head[maxn],vis[maxn],cy[25][maxn],n,m,v[maxn];struct node{    int to,next,w;}edge[maxn*maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int dfs(int x,int minn,int maxx){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to]&amp;&amp;edge[i].w&gt;=minn&amp;&amp;edge[i].w&lt;=maxx)        {            vis[edge[i].to]=1;            if(cy[edge[i].to][0]&lt;v[edge[i].to])            {                cy[edge[i].to][0]++;                cy[edge[i].to][cy[edge[i].to][0]]=x;                return 1;            }            else             {                for(int j=1;j&lt;=cy[edge[i].to][0];j++)                {                    if(dfs(cy[edge[i].to][j],minn,maxx))                    {                        cy[edge[i].to][j]=x;                        return 1;                    }                }            }        }    }    return 0;}bool check(int minn,int maxx){    int ans=0;    for(int i=1;i&lt;=n;i++)    {        memset(vis,0,sizeof(vis));        ans+=dfs(i,minn,maxx);    }    return ans==n;}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=m;j++)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            add(i,x,j);        }    }    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d&quot;,&amp;v[i]);    }    int minn=0x3f3f3f3f;    for(int i=1;i&lt;=m;i++)    {        int l=0,r=m,ans=0x3f3f3f3f;        while(l&lt;=r)        {            memset(cy,0,sizeof(cy));            int mid=(l+r)/2;            if(check(i,i+mid))            {                ans=mid;                r=mid-1;            }            else             {                l=mid+1;            }        }        if(ans==0x3f3f3f3f)break;        minn=min(minn,ans);    }    printf(&quot;%d\n&quot;,minn+1);    return 0;}</code></pre>        <div id="aplayer-FPRMXlJr" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-FPRMXlJr"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>二分图(匈牙利算法-多重匹配)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2112</title>
    <link href="/2020/02/12/POJ-2112/"/>
    <url>/2020/02/12/POJ-2112/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-2112 Optimal Milking</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2112#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2112#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>FJ有K台挤奶机和C只奶牛。机器编号1~K，奶牛编号K+1~K+C。<br>机器一天工作M只奶牛。如何把奶牛分配给机器，使得奶牛到机器的最远距离最小。<br>奶牛可以进过某些机器，但不在那台机器上挤奶。奶牛也可以经过其他奶牛所在的位置。                     输出一个整数，表示走最远的奶牛的需要行走的最小距离。  </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>“最远的行走的最小距离”确认是二分，每一个机器一天可以工作M只奶牛显然是多重匹配。首先用Floyd跑出任意两点之间的最小距离，然后建图，奶牛—&gt;机器，边权为dist[奶牛][机器],当然建单向边，二分距离，跑匈牙利算法的时候，一旦edge[i].w&gt;Max(Max就是二分的距离)那么奶牛就不可以去edge[i].to机器，注意这是多重匹配。</p><p><strong>ps</strong>：WA了一次，比较奇怪r=200这样是错的，所以r=0x3f3f3f3f靠谱点。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=500+5;int k=1,head[maxn],vis[maxn],cy[maxn][maxn],n,c,m,dist[maxn][maxn];struct node{    int to,next,w;}edge[maxn*maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int dfs(int x,int Max){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to]&amp;&amp;edge[i].w&lt;=Max)        {            vis[edge[i].to]=1;            if(cy[edge[i].to][0]&lt;m)            {                cy[edge[i].to][0]++;                cy[edge[i].to][cy[edge[i].to][0]]=x;                return 1;            }            else             {                for(int j=1;j&lt;=cy[edge[i].to][0];j++)                {                    if(dfs(cy[edge[i].to][j],Max))                    {                        cy[edge[i].to][j]=x;                        return 1;                    }                }            }        }    }    return 0;}bool check(int mid){    int ans=0;    for(int i=n+1;i&lt;=n+c;i++)    {        memset(vis,0,sizeof(vis));        ans+=dfs(i,mid);    }    return ans==c;}int main(){    int l=0,r=0x3f3f3f3f,ans=0;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;c,&amp;m);    memset(dist,0x3f3f3f3f,sizeof(dist));    for(int i=1;i&lt;=n+c;i++)    {        for(int j=1;j&lt;=n+c;j++)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            if(i==j||x==0)continue;            dist[i][j]=x;        }    }    for(int k=1;k&lt;=n+c;k++)    {        for(int i=1;i&lt;=n+c;i++)        {            for(int j=1;j&lt;=n+c;j++)            {                if(i==j||i==k||k==j)continue;                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);            }        }    }    for(int i=1;i&lt;=n;i++)    {        for(int j=n+1;j&lt;=n+c;j++)        {            add(j,i,dist[j][i]);        }    }    while(l&lt;=r)    {        memset(cy,0,sizeof(cy));        int mid=(l+r)/2;        if(check(mid))        {            r=mid-1;            ans=mid;        }        else         {            l=mid+1;        }    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-qiDInMSl" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-qiDInMSl"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>最短路</tag>
      
      <tag>二分图(匈牙利算法-多重匹配)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2289</title>
    <link href="/2020/02/12/POJ-2289/"/>
    <url>/2020/02/12/POJ-2289/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-2289  Jamie’s Contact Groups </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2289" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2289</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> n个人，m个社交团体，一个人可能对应多个社交团体，但只能参加一个社交团体，问所有社交团体中人数最多的团体最少有多少人。 (N&lt;=1000,M&lt;=500)</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>“<strong>最多的最少</strong>“这是典型的二分的套路，由题可知：一个人可能对于多个社交团体。可以二分最多的团体的人数，每一个人向自己可参加的团体连一条<strong>有向边</strong>。</p><p>然后在跑匈牙利算法的时候，需要注意：</p><p>要记录这个团体对应了多少的成员了，以cy[edge[i].to][0]记录团体edge[i].to的人数，Max表示本次团队最多容纳人数，如果cy[edge[i].to][0]&lt;Max，直接加入这个团队即可，否则就从第一个成员到最后一个成员都找一次增广路。</p><p>每一次二分时，如果跑完匈牙利算法后，最大匹配==n，就缩小r，否则增大l。</p><p><strong>ps</strong>：题目给的团队从0开始，我自己对它+1了，所以从1开始。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;const int maxn=1000+5;const int maxm=15000+5;int k=1,head[maxn],vis[maxn],cy[maxn][505],n,m;struct node{    int to,next;    }edge[maxn*maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x,int Max){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(cy[edge[i].to][0]&lt;Max)            {                cy[edge[i].to][0]++;                cy[edge[i].to][cy[edge[i].to][0]]=x;                return 1;            }            else             {                for(int j=1;j&lt;=cy[edge[i].to][0];j++)                {                    if(dfs(cy[edge[i].to][j],Max))                    {                        cy[edge[i].to][j]=x;                        return 1;                    }                }            }        }    }    return 0;}bool check(int mid){    int ans=0;    for(int i=1;i&lt;=n;i++)    {        memset(vis,0,sizeof(vis));        ans+=dfs(i,mid);    }    if(ans==n)    return 1;    return 0;}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;m+n!=0)    {        k=1;        memset(head,0,sizeof(head));        memset(cy,0,sizeof(cy));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=n;i++)        {            char a[20];            scanf(&quot;%s&quot;,a);            while(1)            {                int x;char c;                scanf(&quot;%d%c&quot;,&amp;x,&amp;c);                x++;                add(i,x);                if(c==&#39;\n&#39;)                break;            }        }        int l=0,r=n,ans=0;        while(l&lt;=r)        {            memset(cy,0,sizeof(cy));            int mid=(l+r)/2;            if(check(mid))            {                r=mid-1;                ans=mid;            }            else             {                l=mid+1;            }        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-gHKuFoyz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-gHKuFoyz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>二分图(匈牙利算法-多重匹配)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3829</title>
    <link href="/2020/02/12/HDU-3829/"/>
    <url>/2020/02/12/HDU-3829/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-3829 Cat VS Dog</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3829" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3829</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一群小朋友去动物园，如果每个小朋友喜欢的动物是猫，那么不喜欢的动物一定是狗，反之也是。现在动物园的管理者要拿走一些动物，如果拿走的是某个小朋友不喜欢的动物，那这个小朋友就非常开心，反之，如果是某个小朋友喜欢的动物，这个小朋友就非常的不开心，问那完后最多有几个小朋友会非常开心。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是<strong>最大独立集</strong>的问题。这里需要讲解一样<strong>最大独立集</strong>。</p><p><strong>最小顶点覆盖</strong>：</p><p><strong>定义</strong>:假如选了一个点就相当于覆盖了以它为端点的所有边 。最小顶点覆盖就是选择最少的点来覆盖所有的边。 <strong>结论</strong>： <strong>最小顶点覆盖</strong>等于<strong>最大匹配</strong>。 </p><p> <img src="https://img2018.cnblogs.com/blog/1502540/201810/1502540-20181003114327352-650542909.png" alt="img"> </p><p><strong>最大独立集：</strong> </p><p><strong>定义</strong>: 选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。  找出一个包含顶点数最多的独立集称为最大独立集。 <strong>结论</strong>： <strong>最大独立集 = 顶点个数 - 最小覆盖</strong> 。</p><p> <img src="https://img2018.cnblogs.com/blog/1502540/201810/1502540-20181003114344925-207551823.png" alt="img"> </p><p>红点的选择：显然每一条非匹配边一定和匹配边有公共点，所以这样的公共点一定会被选出来，不可能作为最大独立集的元素。</p><p>这样就了解了<strong>最大独立集</strong>，将每一个人喜欢的动物和不喜欢的动物保存下来，1-C为猫，1+N-D+N为狗，如果一个人i喜欢的动物是人j讨厌的动物，那么i与j连双向边。显然如果甲喜欢的动物是乙讨厌的动物，那么甲、乙最多能有一个人高兴。最后求出最大匹配ans，注意ans/=2，这样ans代表的是有多少个人不可以高兴，n-ans就是高兴的人数。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=500+5;const int N=100;int C,D,n,k=1,head[maxn],cy[maxn],vis[maxn],l[maxn],h[maxn];struct node{    int to,next;}edge[maxn*maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;C,&amp;D,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        int tot=0;        for(int i=1;i&lt;=n;i++)        {            char x1,x2;int y1,y2;            cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;            l[i]=y1;h[i]=y2;            if(x1==&#39;D&#39;)l[i]+=N;            if(x2==&#39;D&#39;)h[i]+=N;        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(i==j)continue;                if(l[i]==h[j])                {                    add(i,j);                    add(j,i);                }            }        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        ans/=2;        printf(&quot;%d\n&quot;,n-ans);    }    return 0;}</code></pre>        <div id="aplayer-HESUuvWj" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-HESUuvWj"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最大独立集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2594</title>
    <link href="/2020/02/12/POJ-2594/"/>
    <url>/2020/02/12/POJ-2594/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-2594  Treasure Exploration </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2594" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2594</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在外星上有n个点需要机器人去探险，有m条单向路径。问至少需要几个机器人才能遍历完所有的点，一个点可以被多个机器人经过（这就是和单纯的最小路径覆盖的区别）。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这也是最小路径覆盖问题，但是这与最小不相交路径覆盖问题不同，这是最小相交路径覆盖问题，每个顶点可以经过多次。算法和最小不相交路径覆盖问题基本相同，但是需要用闭包传递预处理一下再建图。</p><p>闭包传递的原因：</p><p> <img src="https://pic002.cnblogs.com/images/2011/239942/2011073111520332.jpg" alt="img"> </p><p>如图，如果不进行闭包传递，最终需要三条路径，但实际上3可以经过多次，只需要两条路径，如果1-&gt;2-&gt;3这条路径走了，4-&gt;2-&gt;5也是可以走的，于是就需要（1，3）合并，（4，5）合并，这就要用到闭包传递。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2500+5;const int maxm=500+5;int k=1,head[maxn],vis[maxn],dist[maxn][maxn],cy[maxn],n,m;struct node{    int to,next;}edge[maxm*maxm];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;} int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(1)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        k=1;        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        memset(dist,0,sizeof(dist));        memset(head,0,sizeof(head));        for(int i=1;i&lt;=m;i++)        {            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b]=1;        }        for(int w=1;w&lt;=n;w++)        {            for(int i=1;i&lt;=n;i++)            {                for(int j=1;j&lt;=n;j++)                {                    if(dist[i][w]&amp;&amp;dist[w][j])                    {                        dist[i][j]=1;                    }                }            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(dist[i][j]==1)                {                    add(i,j);                }            }        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;%d\n&quot;,n-ans);    }    return 0;}</code></pre><p><strong>ps</strong>：一开始一直WA，才发现自己的匈牙利算法的模板错了，我竟然一开始就vis[x]=1，关键这份模板还AC了10个题，我人都傻了。</p>        <div id="aplayer-pGNoOJiz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-pGNoOJiz"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最小路径覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1151</title>
    <link href="/2020/02/11/HDU-1151/"/>
    <url>/2020/02/11/HDU-1151/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1151 Air Raid</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1151#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1151#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一个城镇有n个路口，由一些单向马路连接。现在要安排一些伞兵降落在某些路口上，清查所有的路口。一个伞兵可以沿着马路一路清查过去。清查过程中不能有两个伞兵同时清查一个路口（应该是为了防止暴露）。给定城镇的线路，求最少需要几个人伞兵就能清查所有的路口。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始看到这题，猜想入度为0则ans++，实则不对，出度大于1时就不对了。然后又猜想：建单向边，跑匈牙利算法求出最大匹配，n-ans就是最后的答案。事实证明这个思路是正确的。AC之后即去找了一份题解，这题就是最小路径覆盖问题。</p><p><strong>DAG的最小路径覆盖的定义</strong>： 在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。 </p><p>最小路径覆盖分为最小不相交路径覆盖和最小可相交路径覆盖。 </p><p>最小不相交路径覆盖：每一条路径经过的顶点各不相同。</p><p>最小可相交路径覆盖：每一条路径经过的顶点可以相同。</p><p><strong>DAG的最小不相交路径覆盖的算法</strong>： 把原图的每个点V拆成两个点Vx和Vy，如果有一条有向边A-&gt;B，那么就加边：Ax—&gt;By。这样就得到了一个二分图。那么最小路径覆盖=原图的结点数-新图的最大匹配数。 </p><p><strong>证明</strong>： 一开始每个点都是独立的为一条路径，总共有n条不相交路径。  每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了1。  所以找到了几条匹配边，路径数就减少了多少。 所以 <strong>最小路径覆盖=原图的结点数-新图的最大匹配数。</strong> </p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1200+5;int k=1,head[maxn],vis[maxn],cy[maxn],T,n,m;struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a,b);        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;%d\n&quot;,n-ans);    }    return 0;}</code></pre>        <div id="aplayer-LFDfPjer" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LFDfPjer"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最小路径覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1054</title>
    <link href="/2020/02/11/HDU-1054/"/>
    <url>/2020/02/11/HDU-1054/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1054 Strategic Game</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1054#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1054#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>Bob非常享受玩电脑游戏的过程，尤其是策略游戏，但是在有些时候，他因为不能在第一时间找到最佳的策略而十分伤心。 现在，他遇到了一个问题。他必须保卫一个中世纪的城市，有很多道路将整个城市连起来，整体上看上去像一棵树。Bob需要放置尽可能少的士兵，保卫树上所有的边。士兵只能放在节点上，但是却可以保卫所有与这个节点相邻的边。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题目要求很明确，就是要最少的点覆盖所有的边，即最小定点覆盖问题。 <strong>最小顶点覆盖要求用最少的点，让每条边都至少和其中一个点关联。即</strong>点集里面的点能覆盖所有的边 。</p><p><strong>knoig定理</strong>： <strong>二分图的最小顶点覆盖数=二分图的最大匹配数。</strong> </p><p><strong>证明</strong>：</p><p>要证明<strong>最小顶点覆盖数==最大匹配数</strong>，即证明<strong>最小顶点覆盖数&gt;=最大匹配数</strong>，并且<strong>最大匹配数&gt;=最小顶点覆盖数</strong>。设<strong>最小顶点覆盖数</strong>为S，<strong>最大匹配数</strong>为M。</p><p> <strong>①</strong> <strong>最小顶点覆盖数&gt;=最大匹配数</strong>：</p><p>假设最大匹配数为n，那么我们就得到了n条互不相邻的边，光覆盖这些边就至少需要n个顶点。由于最大匹配数为n，那么就可能存在一些边不在最大匹配的集合中，这样的话要覆盖这些边就还需要顶点，因此<strong>最小顶点覆盖数&gt;=最大匹配数</strong>。</p><p> <strong>②</strong> <strong>最大匹配数&gt;=最小顶点覆盖数</strong>：</p><p>假设匹配边a—&gt;b在最大匹配的集合中，如果a相连的边有未匹配点x，b相连的边有未匹配点y，那么x-a<strong>-</strong>b-y是一条增广路，而这就与M是<strong>最大匹配数</strong>矛盾了。所以a,b不可能同时相连为匹配点。</p><p>因此a，b中有非匹配边相连的点假设是a，那么选择a就可以覆盖a-b以及a-？(非匹配边)。并且M中没有孤立的非匹配边，每一条边一定会跟一个匹配点相连。这就意味着，每一个非匹配边的出发点一定同时连接了一条匹配边，这样非匹配边不可能单独存在。那么，从最大匹配边中选择M个点一定可以覆盖所有的边。所以<strong>最大匹配数&gt;=最小顶点覆盖数</strong>。</p><p>综上所述：<strong>最大匹配数==最小顶点覆盖数</strong>。</p><p>而此题就是要求最少的点将所有的边覆盖，就是<strong>最小点覆盖</strong>的模板题了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1500+5;int k=1,n,head[maxn],cy[maxn],vis[maxn];struct node{    int to,next;}edge[maxn*maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=n;i++)        {            int u,tot;            scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;tot);            for(int j=1;j&lt;=tot;j++)            {                int v;                scanf(&quot;%d&quot;,&amp;v);                add(u+1,v+1);add(v+1,u+1);            }        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        ans/=2;        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-ZDECHCxs" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ZDECHCxs"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最小顶点覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3020</title>
    <link href="/2020/02/11/POJ-3020/"/>
    <url>/2020/02/11/POJ-3020/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-3020  Antenna Placement </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3020" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3020</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，每一组数据是hxw的矩阵，矩阵中的每一个方格有o或者<em>组成,问用1x2的矩阵 (横着或竖着都可以)来覆盖所有的 </em> ，问至少需要多少个这样的矩阵？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题和HDU4185 Oil Skimming 很相似。观察之后发现，将所有的 <em> 先预处理出它的编号，然后对于 </em> 的上下左右若为 <em> 就可以建边，然后跑匈牙利算法，求出最大匹配，对于这样求出来的最大匹配ans应该要÷2，即ans/=2，因为我们建的双向边。ans </em> 2表示的是已经覆盖了的点，temp-ans <em> 2就是剩余的美誉覆盖的点，这些点只能单独覆盖了，所以最终答案是 temp-ans </em> 2+ans。</p><p><strong>ps</strong>：WA了几次，注意 <em> 的数量&lt;=40 </em> 10=400，边就是400 <em> 400 </em> 4，数组要够，不然就是TLE或者WA。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=400+5;const int maxm=400*400+5;int T,n,m,k=1,head[maxn],s[maxn][maxn],cy[maxn],vis[maxn];char a[maxn][maxn];struct node{    int to,next;}edge[maxm*4];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        int temp=0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,a[i]);            for(int j=0;j&lt;=m-1;j++)            {                if(a[i][j]==&#39;*&#39;)                {                    s[i][j]=++temp;                }            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=0;j&lt;=m-1;j++)            {                if(a[i][j]==&#39;*&#39;)                {                    if(j&lt;=m-2&amp;&amp;a[i][j+1]==&#39;*&#39;)                    {                        add(s[i][j],s[i][j+1]);                    }                    if(j&gt;=1&amp;&amp;a[i][j-1]==&#39;*&#39;)                    {                        add(s[i][j],s[i][j-1]);                    }                    if(i&lt;=n-1&amp;&amp;a[i+1][j]==&#39;*&#39;)                    {                        add(s[i][j],s[i+1][j]);                    }                    if(i&gt;=2&amp;&amp;a[i-1][j]==&#39;*&#39;)                    {                        add(s[i][j],s[i-1][j]);                    }                }            }        }        int ans=0;        for(int i=1;i&lt;=temp;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        ans/=2;        int yu=temp-ans*2;        printf(&quot;%d\n&quot;,ans+yu);    }    return 0;}</code></pre>        <div id="aplayer-fPSKwAKk" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-fPSKwAKk"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4185</title>
    <link href="/2020/02/11/HDU-4185/"/>
    <url>/2020/02/11/HDU-4185/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 4185  Oil Skimming </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4185" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4185</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有K组数据，每组数据是N*N的方阵，每个方格由.或者#组成，问有多少个互相不重叠的##(横着或竖着)。</p><p>  (1 &lt;= K &lt;= 100)  (1 &lt;= N &lt;= 600) </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最开始的思路是每个点只判断它下方或者右方是不是#，如果是就连边，但是这个方法存在一个问题：横着的##和竖着的##如果重叠会导致计数重复，又没有一个比较好的办法来规范。于是换了一个想法，一个点若为#就像它上下左右为#的点都连边，最后答案/2就可以避免重复。枚举所有的点，预处理#点的编号temp记录，然后开始跑匈牙利算法，最后ans/2.</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1200+5;const int maxm=360000+5;const int N=360000;int k=1,T,n,head[maxm],vis[maxm],cy[maxm],s[605][605];char a[605][605];struct node{    int to,next;}edge[maxm*4];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){     for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        opt++;        k=1;        memset(cy,0,sizeof(cy));        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(s,0,sizeof(s));        int temp=0;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,a[i]);            for(int j=0;j&lt;n;j++)            {                if(a[i][j]==&#39;#&#39;)                {                    s[i][j]=++temp;                }            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=0;j&lt;n;j++)            {                if(a[i][j]==&#39;#&#39;)                {                    if(j&lt;=n-2&amp;&amp;a[i][j+1]==&#39;#&#39;)                    {                        add(s[i][j],s[i][j+1]);                    }                    if(j&gt;=1&amp;&amp;a[i][j-1]==&#39;#&#39;)                    {                        add(s[i][j],s[i][j-1]);                    }                    if(i&lt;=n-1&amp;&amp;a[i+1][j]==&#39;#&#39;)                    {                        add(s[i][j],s[i+1][j]);                    }                    if(i&gt;=2&amp;&amp;a[i-1][j]==&#39;#&#39;)                    {                        add(s[i][j],s[i-1][j]);                    }                }            }        }        int ans=0;        for(int i=1;i&lt;=temp;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;Case %d: %d\n&quot;,opt,ans/2);    }    return 0;}</code></pre>        <div id="aplayer-uAtBxcDW" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-uAtBxcDW"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2389</title>
    <link href="/2020/02/10/HDU-2389/"/>
    <url>/2020/02/10/HDU-2389/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2389  Rain on your Parade </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2389" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2389</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，每组数据第一行是t，表示到t时下雨，第二行是m，表示有m个客人，接下来m行，每行3个数字，依次为x,y,v(速度)，然后是n，表示有n把伞，接下来n行，每行2个数字，依次为x，y，每一把伞只能由一个人使用，从开始每个客人出发拿伞，到t时间结束，问最多有几个人拿到了伞。   (1 &lt;= m，n &lt;= 3000) </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>1-m客人，N+1-N+n伞</p><p>依次枚举客人和伞，在规定时间内t*v&gt;=距离就可能拿到这把伞，就可以建边客人—&gt;伞。</p><p>一开始跑匈牙利算法，但是匈牙利算法时间复杂度较大，要TLE。</p><p>这时候需要用<strong>hopcroft-karp</strong>来优化，这里介绍一下<strong>hopcroft-karp</strong>：</p><p><strong>hopcroft-karp</strong>的时间复杂度为 <strong>O（n^0.5*m）</strong>。</p><p>思路：</p><p> HK算法分为三步 ：假设我们将集合分为两个，一个是左边的x集合，右面的y集合； </p><p> 1） ：首先x集合中没有匹配的元素入队列； </p><p> 2） ：以队列中的每一个元素作为起始点然后向他们相邻的点进行BFS就是在寻找增广路或者说是将其他的点根据我们的起始点来分层，如果与队列中的元素（x集合）相连的元素（y集合）没有匹配的话我们就找到了一条增广路（就是一个可能的匹配） </p><p> 3）如果这个元素与x集合中的元素匹配了那么我么就要将x集合中的元素入队列； </p><p> 假设我们有 1—2  1—3 1—4  2—5  2—6 3—5这六条边那么我们的HK算法过程是这样</p><p>集合   x ： 1    2     3</p><p>集合   y ：  2   3    4    5   6  </p><p> 1）在入队了的时候是 1  2  3  </p><p> 2）　　u=1　　 to:　　２　　３　　４　　因为ｙ集合中的２，３，４在ｘ集中没有匹配的元素所以找到了一条增广路 </p><p>​                              dy :　　１　　１　　１　 </p><p>​                u=2     to :     5     6         同上；</p><p>​                              dy:    1     1  </p><p>​                 u=3    to :     5 </p><p>​                             dy:     1 //             这里的深度是在2的时候就更新好了 </p><p>3）</p><p>最后就是朴素的匈牙利匹配算法了：首先1-2成功，2匹配5成功，3匹配5的时候不成功，但是我们我们可以将集合y中5的x集合中 的匹配元素2在找一个匹配正好找到y集合中的6，所以问题中的最大匹配是3 </p><h4 id="匈牙利算法代码："><a href="#匈牙利算法代码：" class="headerlink" title="匈牙利算法代码："></a>匈牙利算法代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=3000*3000+5;const int maxm=6000+5;const int N=3000;struct node{    int to,next;}edge[maxn];struct node1{    double v,x,y;}a[maxm];struct node2{    double x,y;}b[maxm];int k=1,head[maxn],t,T,n,m,cy[maxm],vis[maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        scanf(&quot;%d&quot;,&amp;t);        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%lf%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].v);        }        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%lf%lf&quot;,&amp;b[i].x,&amp;b[i].y);        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=n;j++)            {                if((sqrt((a[i].x-b[i].x)*(a[i].x-b[i].x)+(a[i].y-b[i].y)*(a[i].y-b[i].y)))&lt;=a[i].v*t)                {                    add(i,j+N);                }            }        }        int ans=0;        for(int i=1;i&lt;=m;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,ans);    }    return</code></pre><h4 id="hopcroft-karp算法的代码："><a href="#hopcroft-karp算法的代码：" class="headerlink" title="hopcroft-karp算法的代码："></a>hopcroft-karp算法的代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;const int maxn=3000*3000+5;const int maxm=6000+5;const int N=3000;struct node{    int to,next;}edge[maxn];struct node1{    int v,x,y;}a[maxm];struct node2{    int x,y;}b[maxm];int k=1,head[maxn],t,T,n,m,cy[maxm],dx[maxm],dy[maxm],cx[maxm];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(dy[edge[i].to]==dx[x]+1)        {            dy[edge[i].to]=0;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                cx[x]=edge[i].to;                return 1;            }        }    }    return 0;}int bfs(){    queue&lt;int&gt;q;    memset(dx,0,sizeof(dx));    memset(dy,0,sizeof(dy));    for(int i=1;i&lt;=m;i++)    {        if(!cx[i])            {            q.push(i);        }    }    int ans=0;    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!dy[edge[i].to])            {                dy[edge[i].to]=dx[x]+1;                if(!cy[edge[i].to])ans=1;                else                 {                    dx[cy[edge[i].to]]=dy[edge[i].to]+1;q.push(cy[edge[i].to]);                }            }        }    }    return ans;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        memset(cx,0,sizeof(cx));        scanf(&quot;%d&quot;,&amp;t);        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].v);        }        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d%d&quot;,&amp;b[i].x,&amp;b[i].y);        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(((a[i].x-b[j].x)*(a[i].x-b[j].x)+(a[i].y-b[j].y)*(a[i].y-b[j].y))&lt;=a[i].v*t*a[i].v*t)                {                    add(i,j+N);                }            }        }        int ans=0;        while(bfs())        {            for(int i=1;i&lt;=m;i++)            {                ans+=dfs(i);            }            }        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-PjKbCbpJ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-PjKbCbpJ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(hopcroft-karp)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2819</title>
    <link href="/2020/02/10/HDU-2819/"/>
    <url>/2020/02/10/HDU-2819/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2819 Swap</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2819" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2819</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个n*n的方阵，每一个格子(i,j)由0/1组成，问能否使得斜对角线即i==j,（i∈[1,n]），如果不能就输出-1，否则请输出方案。R表示交换行，C表示交换列。</p><hr><p><strong>这里有一点需要说明，就是说题目的交换，其实是将原来图的某一行移到最后图的某一行，而不是指先交换两行，得到一个新图，再交换新图的两行。</strong> </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>首先是关于能否得到斜对角线全为1的方阵，假如一个方阵的斜对角线全为1，那么这个方阵的秩为n，那么如果一个方阵的秩小于n那一定就不可以。那么如何得到方阵的秩呢？受到前面几个二分图的题的影响，凡是方格类的题目都可以将行和列分开，将数字为1的方格就行连边，即行i—&gt;列j，最后求最大匹配，一旦最大匹配为n那就可以，否则输出-1。由矩阵的运算性质可以知道，所有的列变换都可以用行变换来替代，所有的行变换都可以用列变换来替代，于是我们不妨全部都用列变换来替换，已知cy[i]表示第i列和cy[i]行来配对，从1-n列开始枚举，然后枚举得到第一个cy[j]==i的列，说明i列与j列应该替换，然后这一层循环就应该终止！必须终止！否则答案会变多。储存交换的列。最后一个个输出。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+5;const int maxm=100+5;const int N=100+5;int n,a[maxm][maxm],k=1,head[maxn],cy[maxn],l1[maxn],l2[maxn],vis[maxn]; struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;a[i][j]);            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(a[i][j])                {                    add(i,j+N);                }            }        }            int ans=0;            for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        if(ans==n)        {            int tot=0;            for(int i=1;i&lt;=n;i++)            {                for(int j=1;j&lt;=n;j++)                {                    if(cy[j+N]!=i)continue;                    if(i!=j)//交换i，j列                     {                        tot++;                        l1[tot]=i;l2[tot]=j;                        swap(cy[j+N],cy[i+N]);                        break;                    }                }            }            printf(&quot;%d\n&quot;,tot);            for(int i=1;i&lt;=tot;i++)            {                printf(&quot;C %d %d\n&quot;,l1[i],l2[i]);            }        }        else         {            printf(&quot;-1\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-kkedeLFF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-kkedeLFF"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1281</title>
    <link href="/2020/02/10/HDU-1281/"/>
    <url>/2020/02/10/HDU-1281/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1281 棋盘游戏</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1281" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1281</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在N*M的棋盘上，在p个位置上允许放车，每一行每一列最多放一个车，并且在不允许放车的位置并不会影响车的攻击。重要点：要使车的数量最大，该点必须放车。问最多有多少个重要点、最多允许放多少个车？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题和Fire Net的区别在于，Fire Net不允许放置的点是一堵墙，会隔离攻击，而这道题不会影响攻击。所以Fire Net那道题需要进行分区域块，这样就可以分离开。但是这道题不会影响攻击，因此直接按点分，X集合为行，Y集合为列，只要当a[i][j]==1才可以让i行与j列连边，相当于点(i,j)可以放车。这样跑匈牙利算法可以得到最大匹配即最大的车的放置量。对于重要点的求解需要暴力求解，对于每一个可放置车的点需要去除它，然后跑匈牙利算法，如果最大匹配变小了，说明这是重要点，当然对于前向星链表，要记录出发点u，这样就可以进行标记了，vis数组不可以开大了，容易TLE。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int maxm=300+5;const int N=100+5;int head[maxn],k=1,n,m,p,a[maxm][maxm],cy[maxn],vis[maxm];struct node{    int to,next,u;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].u=u;}int dfs(int x,int sign1,int sign2){    for(int i=head[x];i;i=edge[i].next)    {        if(edge[i].to==sign2&amp;&amp;edge[i].u==sign1)continue;        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to],sign1,sign2))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p)!=EOF)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(a,0,sizeof(a));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=p;i++)        {            int X,Y;            scanf(&quot;%d%d&quot;,&amp;X,&amp;Y);            a[X][Y]=1;        }        int ans1=0,ans2=0,tot=0;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=m;j++)            {                if(a[i][j])                {                    add(i,j+N);                }            }        }        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans2+=dfs(i,0,0);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=m;j++)            {                ans1=0;                memset(cy,0,sizeof(cy));                for(int w=1;w&lt;=n;w++)                {                    memset(vis,0,sizeof(vis));                    ans1+=dfs(w,i,j+N);                }                if(ans1!=ans2)                    tot++;            }        }        printf(&quot;Board %d have %d important blanks for %d chessmen.\n&quot;,opt,tot,ans2);    }    return 0;}</code></pre>        <div id="aplayer-IAOthUyP" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-IAOthUyP"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1083</title>
    <link href="/2020/02/09/HDU-1083/"/>
    <url>/2020/02/09/HDU-1083/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 1083Courses</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1083#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1083#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 一共有N个学生跟P门课程,一个学生可以任意选一 门或多门课,问是否达成:</p><p>1.每个学生选的都是不同的课(即不能有两个学生选同一门课)</p><p>2.每门课都有一个代表(即P门课都被成功选过)</p><p> 若能满足上面两个要求这输出”YES”,否则为”NO”  注意：是课程匹配的学生，学生没课上没事….. </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最终问题就是问能否所有的课程都被人选，并且没有两个及以上的人选同一门课。换言之，二分图的最大匹配数是否==p。建图时课程—&gt;学生，课程(1-P)，学生(N+1-N+n)，跑匈牙利算法。</p><p><strong>ps</strong>：数组开小了不会RE，它会TLE！因为一开始只开了10000的边，实际上时100*300，然后TLE了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=30000+5;const int N=300+5;struct node{    int to,next;}edge[maxn*2];int k=1,T,p,n,head[maxn],vis[maxn],cy[maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        scanf(&quot;%d%d&quot;,&amp;p,&amp;n);        for(int i=1;i&lt;=p;i++)        {            int num;            scanf(&quot;%d&quot;,&amp;num);            for(int j=1;j&lt;=num;j++)            {                int x;                scanf(&quot;%d&quot;,&amp;x);                add(i,x+N);            }        }        int ans=0;        for(int i=1;i&lt;=p;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        if(ans==p)        {            printf(&quot;YES\n&quot;);        }        else         {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-LzujRIDu" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LzujRIDu"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2444</title>
    <link href="/2020/02/09/HDU-2444/"/>
    <url>/2020/02/09/HDU-2444/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 2444 The Accomodation of Students</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2444#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2444#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个关系，他们之间某些人相互认识。这样的人有m对。<br>你需要把人分成2组，使得每组人内部之间是相互不认识的。<br>如果可以，就可以安排他们住宿了。安排住宿时，住在一个房间的两个人应该相互认识。<br>最多的能有多少个房间住宿的两个相互认识。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题分为两个问题，第一个问题就是问是否可以分成两组，每一组内部任意两人都互相不认识；第二个问题是最多有几组两人之间相互认识，注意一人只能选择一次。第一个问题很显然就是判断这个图是否可以形成一个二分图，第二个问题是在该图是二分图的条件下的最大匹配数。二分图的判断方法就染色法，用bfs，将相邻的点全部染成相反的颜色，一旦该点与相邻点颜色相同就说明不能形成二分图，最后如果无矛盾就说明可以形成二分图。注意我们建图全部小—&gt;大，而条件给的数据也是如此，这样一定是从小的点出发，bfs起点就为1。求最大匹配时候，我们注意这图是单向的所以直接跑匈牙利。当然保险的是建双向边，求出最大匹配后，注意ans/2就可以了，因为对称，1认识2 与 2认识1 属同一情况。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;struct node{    int to,next;}edge[maxn*2];int k=1,head[maxn],vis[maxn],cy[maxn],n,m;void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}bool bfs(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(vis[edge[i].to]==vis[x])return 0;            if(vis[x]==1)vis[edge[i].to]=2;            else vis[edge[i].to]=1;            q.push(edge[i].to);        }    }    return 1;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        k=1;        memset(edge,0,sizeof(edge));        memset(head,0,sizeof(head));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=m;i++)        {            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a,b);        }        int pd=bfs();        if(pd==0)        {            printf(&quot;No\n&quot;);            continue;        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-FZNKuELH" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-FZNKuELH"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1045</title>
    <link href="/2020/02/09/HDU-1045/"/>
    <url>/2020/02/09/HDU-1045/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 1045 Fire Net</p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://vjudge.net/problem/HDU-1045#author=Codeblocksm" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1045#author=Codeblocksm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 现在有一个N*N的地图，地图上有一些围墙。你的任务是在没有围墙的空白地方建尽可能多的炮台。 假设炮台可以向“上下左右”四个方向发射子弹，子弹可以穿越任何距离并可在途中摧毁一个另一个炮台。而墙壁结构坚固，可以阻止子弹。 问最多可以建设多少个炮台？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>刚开始做二分图的最大匹配问题，没有什么思路啊，没想到如何将一块区域弄来建图，后来看了一下别人的思路，将同一列的联通区域求出来，当然同一联通区域有且只有一个炮台，否则不合题意；将同一行的联通区域求出来，也只能存在一个炮台。如何将列和行结合起来呢？然后列中第i个连通块与行中第j个连通块有交点，说明交点处可以建炮台，判断方法：y[j].h&gt;=x[i].s&amp;&amp;y[j].h&lt;=x[i].t&amp;&amp;x[i].l&gt;=y[j].s&amp;&amp;x[i].l&lt;=y[j].t。那么可以add(i,j+N)。这样建了图后用匈牙利算法来求最大匹配就可以了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;const int N=500;char a[maxn][maxn];int vis[maxn],cy[maxn],n,k=1,head[maxn];struct node1{    int l,s,t;}x[maxn];//表示列块 struct node2{    int h,s,t;}y[maxn];//表示行块 struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int check(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||check(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=0)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        memset(a,0,sizeof(a));        memset(x,0,sizeof(x));        memset(y,0,sizeof(y));        int tot1=0,tot2=0;        for(int i=1;i&lt;=n;i++)            scanf(&quot;%s&quot;,a[i]+1);        for(int i=1;i&lt;=n;i++)        {            int s=1;            while(s&lt;=n)            {                if((s&gt;1&amp;&amp;a[s-1][i]==&#39;X&#39;&amp;&amp;a[s][i]==&#39;.&#39;)||(s==1&amp;&amp;a[s][i]==&#39;.&#39;))                {                    tot1++;                    x[tot1].l=i;x[tot1].s=s;x[tot1].t=s;                }                if(a[s][i]==&#39;.&#39;)x[tot1].t=s;                s++;            }        }        for(int i=1;i&lt;=n;i++)        {            int s=1;            while(s&lt;=n)            {                if((s&gt;1&amp;&amp;a[i][s-1]==&#39;X&#39;&amp;&amp;a[i][s]==&#39;.&#39;)||(s==1&amp;&amp;a[i][s]==&#39;.&#39;))                {                    tot2++;                    y[tot2].h=i;y[tot2].s=s;y[tot2].t=s;                }                if(a[i][s]==&#39;.&#39;)y[tot2].t=s;                s++;            }        }        for(int i=1;i&lt;=tot1;i++)        {            for(int j=1;j&lt;=tot2;j++)            {                if(y[j].h&gt;=x[i].s&amp;&amp;y[j].h&lt;=x[i].t&amp;&amp;x[i].l&gt;=y[j].s&amp;&amp;x[i].l&lt;=y[j].t)                {                    add(i,j+N);                }            }        }        int ans=0;        for(int i=1;i&lt;=tot1;i++)        {            memset(vis,0,sizeof(vis));            ans+=check(i);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-HziVIamO" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-HziVIamO"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2255</title>
    <link href="/2020/02/09/HDU-2255/"/>
    <url>/2020/02/09/HDU-2255/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2255  奔小康赚大钱 </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2255#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2255#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>n个居民n个房子，每个居民会给不同的房子不同的钱，问如何分配使得钱最多？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>KM的模板题，KM的具体介绍由blog的KM讲解中提供</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300+5;int Map[maxn][maxn],visx[maxn],visy[maxn],cx[maxn],cy[maxn],n,wx[maxn],wy[maxn],minn;int dfs(int x){    visx[x]=1;    for(int i=1;i&lt;=n;i++)    {        if(!visy[i]&amp;&amp;Map[x][i]!=0x3f3f3f3f)        {            int t=wx[x]+wy[i]-Map[x][i];            if(t==0)            {                visy[i]=1;                if(!cy[i]||dfs(cy[i]))                {                    cy[i]=x;                    cx[x]=i;                    return 1;                }                    }            else             {                minn=min(minn,t);            }        }    }    return 0;}int KM(){    memset(visx,0,sizeof(visx));    memset(visy,0,sizeof(visy));    memset(cx,0,sizeof(cx));    memset(cy,0,sizeof(cy));    memset(wx,0,sizeof(wx));    memset(wy,0,sizeof(wy));    minn=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(Map[i][j]!=0x3f3f3f3f)            {                wx[i]=max(wx[i],Map[i][j]);            }        }    }    for(int i=1;i&lt;=n;i++)    {        while(1)        {            memset(visx,0,sizeof(visx));            memset(visy,0,sizeof(visy));            minn=0x3f3f3f3f;            if(dfs(i))break;            for(int i=1;i&lt;=n;i++)            {                if(visx[i])                {                    wx[i]-=minn;                }            }            for(int i=1;i&lt;=n;i++)            {                if(visy[i])                {                    wy[i]+=minn;                }            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        if(cx[i]!=0)ans+=Map[i][cx[i]];    }    return ans;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(Map,0x3f3f3f3f,sizeof(Map));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;Map[i][j]);            }        }        int ans=KM();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-OPJXatJx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-OPJXatJx"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>KM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KM算法详解</title>
    <link href="/2020/02/09/KM%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/02/09/KM%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h1><p>以<strong><em>匈牙利算法</em></strong>为基础，改善后用于求解带权二分图的<strong><em>最佳匹配</em></strong>问题</p><h2 id="完备匹配："><a href="#完备匹配：" class="headerlink" title="完备匹配："></a>完备匹配：</h2><p>如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，<strong>或者</strong>Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。 </p><h2 id="完美匹配："><a href="#完美匹配：" class="headerlink" title="完美匹配："></a>完美匹配：</h2><p>若二分图X部的每一个顶点都与Y中的一个顶点匹配，<strong>并且</strong>Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完美匹配。 </p><p>即： 一个二分图，X部和Y部的顶点数相等，存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。  </p><h2 id="最大权匹配："><a href="#最大权匹配：" class="headerlink" title="最大权匹配："></a>最大权匹配：</h2><p>带权二分图的边权重和最大的匹配，如图，最大和为102</p><p> <img src="https://img-blog.csdnimg.cn/20181105155320651.png" alt="img"> </p><h2 id="最佳匹配："><a href="#最佳匹配：" class="headerlink" title="最佳匹配："></a>最佳匹配：</h2><p>带权二分图的边权重和最大的完备匹配，如图</p><p> <img src="https://img-blog.csdnimg.cn/2018110515570130.png" alt="img"> </p><p>显然最大权匹配和最佳匹配不完全相同，最大权匹配由于不一定是最大匹配，所以无法等同于最佳匹配。</p><p>但是如果把剩余的边补上，并且设置边权为0，那么二者可以统一起来。如图</p><p> <img src="https://img-blog.csdnimg.cn/20181105160925184.png" alt="img"> </p><h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><p>km算法用于求最佳匹配，而不是最大权匹配。换言之，km算法用来求完备匹配下的最大权匹配。</p><p><u>如果不存在完备匹配，km算法会求最大匹配，如果最大匹配存在多种，那么结果就是最大匹配中权重和最大的。</u></p><hr><p>在一个二分图中，左顶点为X，右顶点为Y，现在对于每组左右连接XiYi有权Wij，求最大匹配，并且使得该匹配中所有Wij的和最大。</p><p>该算法通过给每一个顶点一个标号(称为顶标)来把求最大权匹配的问题转换为求完备匹配的问题。</p><p>设顶点Xi的顶标为A[i]，顶点Yi的顶标为B[i]，顶点Xi和Yi之间的边权为W[i][j]，在整个过程中任意一条边<i,j>，始终满足A[i]+B[j]&gt;=W[i][j].</p><h2 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h2><p>图G中每一条边有左右两个顶标，<strong><em>相等子图</em></strong>就是那些顶标和等于边权重的边构成的子图，如图例</p><p> <img src="https://img-blog.csdnimg.cn/20181105162845589.png" alt="img"> </p><h2 id="KM算法的正确性"><a href="#KM算法的正确性" class="headerlink" title="KM算法的正确性"></a>KM算法的正确性</h2><p><strong>定理</strong>：若二分图中，A[i]+B[j]&gt;=W[i][j],并且存在某个相等子图有完备匹配，那么这个完备匹配就是二分图的最大权匹配</p><p><strong>证明</strong>：因为这个完备匹配存在于相等子图中，因此，这个匹配所有边满足于：A[i]+B[j]==W[i][j],同时由于完备匹配包含所有的顶点，因此这个属于相等子图的完备匹配的总权重等于所有顶标的和。</p><p>如果这个二分图存在另外一个完备匹配，如果它不完全属于相等子图，即存在某条边：A[i]+B[j]&gt;W[i][j],那么该匹配的权重和就小于所有顶标的和，即小于上述属于相等子图的完备匹配的权重和。</p><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ul><li><p>首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。</p><p><img src="https://img-blog.csdnimg.cn/20181105161921533.png" alt="img"> </p></li><li><p>对于X部中的每个顶点，在<strong><em>相等子图</em></strong>中利用<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">匈牙利算法</a>找一条<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">增广路径</a>，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配是最大权重的完备匹配，即为二分图的最佳匹配。</p><p><strong>匈牙利算法</strong>对左边第一个顶点，在<strong><em>相等子图</em></strong>中进行增广路径搜索，找到路径1-C后进行<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">匹配增广操作</a>，如下图所示 </p><p><img src="https://img-blog.csdnimg.cn/20181105163243917.png" alt="img"> </p></li></ul><p>接着<strong>匈牙利算法</strong>对左边第二个顶点，在<strong><em>相等子图</em></strong>中进行增广路径搜索，结果是没有找到增广路径！这时需要修改顶标值，<strong>扩大</strong>相等子图，左边的顶标减少d，右边的顶标增加d，这里产生两个问题： </p><ul><li>哪些顶标需要修改</li><li>d是多少</li></ul><p><strong>question1：</strong> 注意在保持相等子图原来的边符合相等子图要求的同时，让新加的边也满足相等子图的要求。 </p><p>那么在增广路径搜索时，我们知道，如果下面这些紫色边任意一条加入相等子图后，都可以在相等子图中使用<strong>匈牙利算法</strong>找到一条增广路径2-A（or 2-B or 2-C-1-A）： </p><p> <img src="https://img-blog.csdnimg.cn/20181105165825707.png" alt="img"> </p><p><strong>question2</strong>： <strong>KM算法</strong>选择上述三条紫色边中，顶标和与边权重差值最小的边1-A或者2-A，以该最小差值为d </p><p><strong>ps</strong>： 为什么选最小那个 ？</p><p><strong>回答</strong>：如果比这个还小就不能扩大相等子图了，如果大了，就不能保证A[i]+B[j]&gt;=W[i][j]总是成立了。 比如上图选择了2-B边 ，则差值d就为2，1-A就有A[i]+B[j]=2+0&lt;3=W[i][j].</p><p><strong>KM算法</strong>中需要修改的顶标是<strong>匈牙利算法</strong>增广路径搜索时，产生一棵交错树，为了保证A[i]+B[j]&gt;=W[i][j]总是成立，交错树上所有的顶标都需要进行修改。</p><p>比如在第二个顶点搜索增广路时，产生如图所示的橙色顶标集合{1,2,C}</p><p> <img src="https://img-blog.csdnimg.cn/20181105165032976.png" alt="img"> </p><p> <strong>修改顶标</strong>后产生如下图所示的结果： </p><p> <img src="https://img-blog.csdnimg.cn/20181105183106680.png" alt="img"> </p><p> 在该相等子图上以顶点2为开始点，<strong>搜索增广路径</strong>2-A（or 2-C-1-A），<strong>进行增广</strong>操作: </p><p> <img src="https://img-blog.csdnimg.cn/20181105183544455.png" alt="img"> </p><p> 同样对左边第三个点： </p><p> <img src="https://img-blog.csdnimg.cn/20181105185155651.png" alt="img"> </p><p><strong>ps</strong>:为什么修改橙色顶标而不去修改顶标A(找到最小差对应的边的右边顶标)？修改顶标A的值为-1， 那么边1-A也可以加入<strong>相等子图</strong>了。但是这样就无法保证A[i]+B[j]&gt;=W[i][j]恒成立了。如下图所示结果，修改顶标A，边3-A就不满足该条件了。除非在修改顶标A的同时，增加顶标3的值，但是需要修改的顶标集合需要额外的搜索算法，而修改橙色顶标所需要的<strong>交错树</strong>在增广路径搜索时可以一并产生。 </p><p> <img src="https://img-blog.csdnimg.cn/20181106152548762.png" alt="img"> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300+5;int Map[maxn][maxn],visx[maxn],visy[maxn],cx[maxn],cy[maxn],n,wx[maxn],wy[maxn],minn;int dfs(int x){    visx[x]=1;    for(int i=1;i&lt;=n;i++)    {        if(!visy[i]&amp;&amp;Map[x][i]!=0x3f3f3f3f)        {            int t=wx[x]+wy[i]-Map[x][i];            if(t==0)            {                visy[i]=1;                if(!cy[i]||dfs(cy[i]))                {                    cy[i]=x;                    cx[x]=i;                    return 1;                }                    }            else             {                minn=min(minn,t);            }        }    }    return 0;}int KM(){    memset(visx,0,sizeof(visx));    memset(visy,0,sizeof(visy));    memset(cx,0,sizeof(cx));    memset(cy,0,sizeof(cy));    memset(wx,0,sizeof(wx));    memset(wy,0,sizeof(wy));    minn=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(Map[i][j]!=0x3f3f3f3f)            {                wx[i]=max(wx[i],Map[i][j]);            }        }    }    for(int i=1;i&lt;=n;i++)    {        while(1)        {            memset(visx,0,sizeof(visx));            memset(visy,0,sizeof(visy));            minn=0x3f3f3f3f;            if(dfs(i))break;            for(int i=1;i&lt;=n;i++)            {                if(visx[i])                {                    wx[i]-=minn;                }            }            for(int i=1;i&lt;=n;i++)            {                if(visy[i])                {                    wy[i]+=minn;                }            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        if(cx[i]!=0)ans+=Map[i][cx[i]];    }    return ans;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(Map,0x3f3f3f3f,sizeof(Map));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;Map[i][j]);            }        }        int ans=KM();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-MsoZqWoS" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-MsoZqWoS"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>KM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu-3386</title>
    <link href="/2020/02/08/luogu-3386/"/>
    <url>/2020/02/08/luogu-3386/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>luogu-P3386 二分图匹配模板</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://www.luogu.com.cn/problem/P3386" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3386</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定一个二分图，结点个数分别为n,m，边数为e，求二分图最大匹配数 </p><p> 因为数据有坑，可能会遇到 v&gt;m 或者 u&gt;n的情况。请把 v&gt;m 或者 u&gt;n的数据自觉过滤掉。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是二分图最大匹配匹配的模板题。</p><p>这里简述一下二分图的匈牙利算法：</p><p>给出下图，要求最大匹配数</p><p> <img src="https://img-blog.csdn.net/20130503155150538" alt="img"> </p><p> 匈牙利算法的工作模式 如下：</p><p> <strong>一：</strong> 先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，got it，连上一条蓝线 </p><p> <img src="https://img-blog.csdn.net/20130503155256629" alt="img"> </p><p> <strong>二</strong>：接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主，got it  <img src="https://img-blog.csdn.net/20130503155344972" alt="img"> </p><p> <strong>三</strong>：接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？ </p><p> 我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。 </p><p> (黄色表示这条边被临时拆掉) </p><p> <img src="https://img-blog.csdn.net/20130503155428908" alt="img"> </p><p> 与1号男生相连的第二个女生是2号女生，但是2号女生也有主了，怎么办呢？我们再试着给2号女生的原配  重新找个妹子 </p><p> <img src="https://img-blog.csdn.net/20130503155441032" alt="img"> </p><p> 此时发现2号男生还能找到3号女生，那么之前的问题迎刃而解了，回溯回去 ：</p><p> 2号男生可以找3号妹子     </p><p> <img src="https://img-blog.csdn.net/20130503155453501" alt="img"> </p><p>  1号男生可以找2号妹子了 </p><p> <img src="https://img-blog.csdn.net/20130503155626560" alt="img"> </p><p> 3号男生可以找1号妹子 </p><p> <img src="https://img-blog.csdn.net/20130503162147840" alt="img"> </p><p> 所以第三步最后的结果就是： </p><p> <img src="https://img-blog.csdn.net/20130503160156253" alt="img"> </p><p> <strong>四</strong>： 接下来是4号男生，很遗憾，按照第三步的节奏我们没法给4号男生腾出来一个妹子 。</p><p>综上所诉：</p><p>我们对于左边(即X集合)每一个点都进行一次dfs，寻找可匹配的点(Y集合)，注意每一轮的dfs每一个点只可遍历一次，对于vis数组每轮开始要清空，然后遍历时，注意!girl[edge[i].to]||check(girl[edge[i].to])意味着有增广路，也就是说匹配数可以增加1.此时Y集合对应的X集合的点就变了。、</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000000+5;struct node{    int to,next;}edge[maxn];int n,m,e,vis[maxn],girl[maxn],head[maxn],k=1;void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int check(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!girl[edge[i].to]||check(girl[edge[i].to]))            {                girl[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;e);    for(int i=1;i&lt;=e;i++)    {        int u,v;        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        if(u&gt;n||v&gt;m)continue;        add(u,v+n);    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        memset(vis,0,sizeof(vis));        ans+=check(i);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-cNhxFkxi" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-cNhxFkxi"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3416</title>
    <link href="/2020/02/07/HDU-3416/"/>
    <url>/2020/02/07/HDU-3416/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-3416 Marriage Match IV</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3416" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3416</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> n 个点 m 条边带权有向图，问每条边最多只能走一次时从 A 到 B 的最短路径数量。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>问题是问从s—&gt;t有多少种完全不同的最短路径。首先要想办法找到哪些边属于最短路径里面的边，于是先正向跑一遍spfa，再反向跑一遍spfa，设smin为s—&gt;t的最短路的长度，那如果一条边属于最短路，那它一定满足dist1[x[i]]+dist2[y[i]]+w[i]==smin&amp;&amp;x[i]!=y[i]。这样就可以找到最短路径的所有边，然后建边时注意，x[i]—&gt;y[i],边权为1，跑dinic，得到的最大流ans就是答案。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200010+5;int T,n,m,s,t,head[maxn],dist2[maxn],dist1[maxn],vis[maxn],k=1,k2=1,head2[maxn],deep[maxn],x[maxn],y[maxn],w[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa1(int s)//dist1[i]表示从A--i的距离,spfa1跑正边 {    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist1,0x3f3f3f3f,sizeof(dist1));    dist1[s]=0;vis[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)            {                dist1[edge[i].to]=dist1[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void spfa2(int s)//dist2[i]表示从i--B的距离,spfa2跑反边 {    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist2,0x3f3f3f3f,sizeof(dist2));    dist2[s]=0;vis[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)            {                dist2[edge[i].to]=dist2[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    q.push(s);deep[s]=1;    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}int dinic(){    int ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }    return ans;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(x,0,sizeof(x));        memset(y,0,sizeof(y));        memset(w,0,sizeof(w));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;x[i],&amp;y[i],&amp;w[i]);        }        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);        for(int i=1;i&lt;=m;i++)        {            add(x[i],y[i],w[i]);        }        spfa1(s);        int smin=dist1[t];        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=m;i++)        {            add(y[i],x[i],w[i]);        }        spfa2(t);        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=m;i++)        {        //    cout&lt;&lt;dist1[x[i]]&lt;&lt;&#39; &#39;&lt;&lt;dist2[y[i]]&lt;&lt;&#39; &#39;&lt;&lt;w[i]&lt;&lt;&#39; &#39;&lt;&lt;smin&lt;&lt;endl;            if(dist1[x[i]]+dist2[y[i]]+w[i]==smin&amp;&amp;x[i]!=y[i])            {                add(x[i],y[i],1);add(y[i],x[i],0);            }        }        int ans=dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-JcKElyvj" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-JcKElyvj"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu-2764</title>
    <link href="/2020/02/07/luogu-2764/"/>
    <url>/2020/02/07/luogu-2764/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>luogu2764-最小路径覆盖问题</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定有向图 G=(V,E)<em>G</em>=(<em>V</em>,<em>E</em>) 。设 P是 G 的一个简单路(顶点不相交)的集合。如果 V 中每个定点恰好在P<em>P</em>的一条路上，则称 P 是 G的一个路径覆盖。P<em>P</em>中路径可以从 V 的任何一个定点开始，长度也是任意的，特别地，可以为 0 。G 的最小路径覆盖是 G所含路径条数最少的路径覆盖。设计一个有效算法求一个 GAP (有向无环图) G的最小路径覆盖 </p><p> 从第1 行开始，每行输出一条路径。文件的最后一行是最少路径数。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>要求的是最少路径数将所有的点都覆盖掉。</p><p>由konig定理知：最小点覆盖=最大匹配数；<br>而该题抽出模型就成了：最小路径覆盖；<br>最小路径覆盖=点数-最大匹配数；</p><p>如何理解这个结论呢？(这个解释并不严谨，只是为了帮助理解，请勿喷)<br>    加入1—&gt;2—&gt;3;<br>    可以转化为1—&gt;2’;2—&gt;3’;<br>    1,2,3在X中，1’,2’,3’在Y中；路径数=3-2；符合结论；<br>    再举例1—&gt;2,1—&gt;3,2—&gt;4,3—&gt;4;<br>    可以转化为1—&gt;2’,1—&gt;3’,2—&gt;4’,3—&gt;4’;最大匹配数为2；最少路径数为2.符合结论<br>由上面的例子可以分析一下：<br>    x与x’都处于匹配边中时，说明点x处于一条路径中；而一条路径中的开头点与结尾点的x和x’只能选择其中一个。此时(该路径中的)点个数-边数=1;<br>那么有多少个“1”就说明有多少条路径。就可以说明最小路径覆盖=点数-最大匹配数；</p><p>证明了以上的结论后，就可以考虑建模了：<br>    把一个点拆成x，x’，s向所有的x连边，所有的x’ 向t连边， 如果x1—&gt;y1，就将x1向y1’连边，所有的边容量为1(反边容量为0)；<br>    然后开始跑最大流，实际上跑出来的最大流就是最大匹配数，那么最小边覆盖=n-ans；<br>接着要开始说明每一条路径：<br>    从1-n都枚举一边，每一个点连向的是x’,并且如果最大流流向了x’(流向了x’就说明该边流量为0），然后输出该值，继续dfs。<br>    注意要排除s，t的点；</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt; using namespace std;const int maxn=600000+5;int n,m,k=1,head[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int s,t,ans,deep[maxn];bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(edge[i].w&amp;&amp;!deep[edge[i].to])            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    if(deep[t])return 1;    return 0;}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;            }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int vis[maxn];void work(int x){    for(int i=head[x];i;i=edge[i].next)    {        int TO=edge[i].to;        if(TO&gt;2*n)continue;        if(TO&gt;n)TO-=n;        if(edge[i].w==0&amp;&amp;!vis[TO])        {            int x=edge[i].to;            if(x&gt;n)x-=n;            cout&lt;&lt;x&lt;&lt;&#39; &#39;;            vis[x]=1;            work(x);        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    s=2*n+1;t=s+1;    for(int i=1;i&lt;=n;i++)add(s,i,1),add(i,s,0);    for(int i=1;i&lt;=m;i++)    {        int a,b;        cin&gt;&gt;a&gt;&gt;b;        add(a,b+n,1);add(b+n,a,0);    }    for(int i=1;i&lt;=n;i++)add(i+n,t,1),add(t,i+n,0);    dinic();    for(int i=1;i&lt;=n;i++)    {        if(!vis[i])        {            vis[i]=1;            cout&lt;&lt;i&lt;&lt;&#39; &#39;;            work(i);            cout&lt;&lt;endl;        }    }    cout&lt;&lt;n-ans&lt;&lt;endl;    return 0;}</code></pre>        <div id="aplayer-rAtSryli" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-rAtSryli"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3336</title>
    <link href="/2020/02/07/HDU-3336/"/>
    <url>/2020/02/07/HDU-3336/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3336 Count the string</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3336#author=cust_acm" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3336#author=cust_acm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个字符串，求它所有子串(包括自身)出现的总次数之</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>该题目需要比较完善地理解Next数组地含义与作用。当匹配到i失败时，就会返回到Next[i]。则匹配到i时，应该记录了子串s[0…i]，以及与子串s[0…Next[i]]。于是就可以得到动态转移方程dp[i]=dp[Next[i]]+1.然后求和dp数组，同时取模。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;const int Mod=10007;int T,len1,len2,Next[maxn],dp[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        int ans=0;        memset(s2,0,sizeof(s2));        memset(Next,0,sizeof(Next));        memset(dp,0,sizeof(dp));        scanf(&quot;%d&quot;,&amp;len2);        scanf(&quot;%s&quot;,s2);        next_pre();        for(int i=1;i&lt;=len2;i++)        {            if(Next[i]!=-1)                dp[i]=dp[Next[i]]+1;        }        for(int i=1;i&lt;=len2;i++)            ans=(ans+dp[i])%Mod;        printf(&quot;%d\n&quot;,ans);    }        return 0;}</code></pre>        <div id="aplayer-hanUScEX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-hanUScEX"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4300</title>
    <link href="/2020/02/07/HDU-4300/"/>
    <url>/2020/02/07/HDU-4300/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-4300 Clairewd’s message</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4300" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4300</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>第一行给的是26个字母对应的翻译密码，而第二行给的是文本串，该文本串前面部分为加密后的内容，而后部分(可能不完整)为未加密的内容。求：一行字符串前一半为加密后的内容，后一半为未加密的内容。一一对应的关系。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>由题意可知，文本串前一部分是加密过后的内容，后一部分是未加密的内容，而这一部分可能是不完整的。则可理解为s=stringA+stringB。可以根据第一行给的加密方式将s整体当作加密内容，将其转化为整体未加密的内容，即字符串s转化成了t。这时候将原s的所有后缀与t匹配，这个过程实际上就是ex-kmp，将t作为子串，s作为母串，求t与s的所有后缀的公共前缀的长度extend[]。如果extend[i]+i==len(s)&amp;&amp;i&gt;=extend[i].即以i为分界点，s[0…i-1]作为stringA，s[i…len-1]作为stringB，即stringB就是原文本内容。(i&gt;=extend[i]的原因：如果stringB与t的公共连续子串的长度大于了i，这就与extend[i]的定义矛盾了。)选择最近的符合条件的点作为答案。分两部分输出即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;const int maxm=1000+5;int T,len1,len2,Next[maxn],Extend[maxn],t[maxm],q[maxm];char S[maxn],s1[maxn],s2[maxn];void next_pre(){    int i=0,po=0;    while(s1[i]==s1[i+1]&amp;&amp;i+1&lt;len2)i++;    Next[0]=len2;Next[1]=i;po=1;    for(int i=2;i&lt;len1;i++)    {        if(Next[i-po]+i&lt;Next[po]+po)            Next[i]=Next[i-po];        else         {            int j=Next[po]+po-i;            if(j&lt;0)j=0;            while(s1[i+j]==s1[j]&amp;&amp;i+j&lt;len2)j++;            Next[i]=j;            po=i;        }    }}void extend_pre(){    int i=0,po=0;    while(s2[i]==s1[i]&amp;&amp;i&lt;len2)i++;    Extend[0]=i;    for(int i=1;i&lt;len2;i++)    {        if(Next[i-po]+i&lt;Extend[po]+po)            Extend[i]=Next[i-po];        else         {            int j=Extend[po]+po-i;            if(j&lt;0)j=0;//            cout&lt;&lt;j&lt;&lt;&#39; &#39;&lt;&lt;i+j&lt;&lt;endl;//            cout&lt;&lt;s1[j]&lt;&lt;&#39; &#39;&lt;&lt;s2[i+j]&lt;&lt;endl;            while(s2[i+j]==s1[j]&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len2)j++;            Extend[i]=j;            po=i;        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(Next,0,sizeof(Next));        memset(Extend,0,sizeof(Extend));        memset(t,0,sizeof(t));        memset(q,0,sizeof(q));        memset(S,0,sizeof(S));        memset(s1,0,sizeof(s1));        memset(s2,0,sizeof(s2));        scanf(&quot;%s%s&quot;,S,s2);        len1=strlen(s2);len2=strlen(s2);        for(int i=0;i&lt;26;i++)        {            t[i]=S[i]-&#39;a&#39;;//a,b,c...z分别转化为s1[0],s1[1],s1[2]...s1[25]             q[S[i]-&#39;a&#39;]=i;//再转化回去，形成映射         }        for(int i=0;i&lt;len2;i++)        {            s1[i]=q[s2[i]-&#39;a&#39;]+&#39;a&#39;;        }        s1[len2]=&#39;\0&#39;;//        cout&lt;&lt;s1&lt;&lt;endl;        next_pre();        extend_pre();//        for(int i=0;i&lt;len2;i++)cout&lt;&lt;Next[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;//        for(int i=0;i&lt;len2;i++)cout&lt;&lt;Extend[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;        int opt=0;        for(int i=0;i&lt;len2;i++)        {            if(Extend[i]+i==len2&amp;&amp;i&gt;=Extend[i])            {                opt=i;                break;            }        }//        cout&lt;&lt;opt&lt;&lt;endl;        for(int i=0;i&lt;opt;i++)printf(&quot;%c&quot;,s2[i]);        for(int i=0;i&lt;opt;i++)printf(&quot;%c&quot;,q[s2[i]-&#39;a&#39;]+&#39;a&#39;);        if(opt==0)        {            printf(&quot;%s&quot;,s2);            for(int i=0;i&lt;len2;i++)printf(&quot;%c&quot;,q[s2[i]-&#39;a&#39;]+&#39;a&#39;);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-hAMPvWXX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-hAMPvWXX"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>ex-kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1238</title>
    <link href="/2020/02/07/HDU-1238/"/>
    <url>/2020/02/07/HDU-1238/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1238 Substrings</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1238#author=organicsalt" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1238#author=organicsalt</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给n个字符串，问是否存在一个子串(或将该子串reverse)为所有字符串的子串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>将第一个字符串的所有子串与其余子串匹配一遍，如果有一个匹配失败，就将该子串reverse再匹配。这里使用reverse会更快，用kmp加速。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;int n,T,Next[maxn],len1,len2;string s[105],s2;void next_pre(int len){    int i=0,j=1;Next[0]=-1;    while(j&lt;len)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int next_work(int opt,int len){    int i=0,j=0;len2=s[opt].length();    while(i&lt;len2)    {        if(s2[j]==s[opt][i]||j==-1)i++,j++;        else j=Next[j];        if(j==len)        {            return 1;        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(Next,0,sizeof(Next));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];        len1=s[1].length();        for(int i=len1;i&gt;=0;i--)        {            int sign=0;            for(int l=0;l+i-1&lt;len1;l++)            {                int r=l+i-1;                s2=s[1].substr(l,i);                memset(Next,0,sizeof(Next));                next_pre(i);                sign=0;                for(int k=2;k&lt;=n;k++)                {                    int x1=next_work(k,i);                    if(x1==0)                    {                        reverse(s2.begin(),s2.end());                        memset(Next,0,sizeof(Next));                        next_pre(i);                        int x2=next_work(k,i);                        if(x2==0)                        {                            sign=1;                            break;                        }                    }                    else continue;                }                if(sign==0)                {                    printf(&quot;%d\n&quot;,i);                    break;                }            }            if(sign==0)            {                break;            }        }    }    return 0;}</code></pre>        <div id="aplayer-bjABqNzs" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-bjABqNzs"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "/music/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2328</title>
    <link href="/2020/02/07/HDU-2328/"/>
    <url>/2020/02/07/HDU-2328/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 2328 Corporate Identity</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2328" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2328</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求n个字符串的最长公共子串，若有多个则输出字典序最小的，若没有就输出“IDENTITY LOST”。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题就相当简单了，直接暴力枚举第一个字符串的所有子串，用kmp与所有别的字符串匹配，看它们是否都包含了这个子串，将符合条件的子串存进数组，在排序sort一下，输出第一个字符串即可。用到substr函数。<br>不过数据可能比较水，理论上时间复杂度是不够的，以为会TLE，结果可以过，甚至暴力都可以过。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=4000+5;int len1,len2,Next[maxn],n,ans;string s1[maxn],s2,Ans[maxn];void next_pre(int len){    int i=0,j=1;Next[0]=-1;    while(j&lt;len)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int next_work(int opt,int len){    int i=0,j=0;int len2=s1[opt].length();    while(i&lt;len2)    {        if(s1[opt][i]==s2[j]||j==-1)i++,j++;        else j=Next[j];        if(j==len)        {            return 1;        }    }    return 0;}int cmp(string x,string y){    return x&lt;y;}int main(){    while(1)    {        memset(Next,0,sizeof(Next));        ans=0;        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s1[i];        len1=s1[1].length();        for(int l=len1;l&gt;=1;l--)        {            int sign=0;            for(int i=0;i+l-1&lt;len1;i++)            {                sign=0;                int r=i+l-1;                s2=s1[1].substr(i,l);                memset(Next,0,sizeof(Next));                next_pre(l);                for(int k=2;k&lt;=n;k++)                {                    int x=next_work(k,l);                    if(x==0)                    {                        sign=1;                        break;                    }                }                if(sign==0)                {                    ans++;                    Ans[ans]=s2;                }            }            if(ans)            break;        }        if(ans==0)        {            printf(&quot;IDENTITY LOST\n&quot;);            continue;        }        else         {            sort(Ans+1,Ans+1+ans,cmp);            cout&lt;&lt;Ans[1]&lt;&lt;endl;        }    }    return 0;}</code></pre>        <div id="aplayer-tsPdLHeO" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-tsPdLHeO"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3374</title>
    <link href="/2020/02/07/HDU-3374/"/>
    <url>/2020/02/07/HDU-3374/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3374 String Problem</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3374" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3374</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>对于一个字符串，它可以每次左移一次，得到一个新的字符串，因此一个长度为n的字符串，可以得到n个字符串。问，字典序最小的字符串排第几位，一共有多少个，字典序最大的字符串排第几位，一共有多少个<br>ps:如果最大和最小的有多个，输出最先出现的那个。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>求有多少个相同的字符串相对简单，并且运用到了kmp的知识，只有内部循环的字符串才可能会重复，对于这种字符串来讲它的循环节T= n-Next[n]，出现次数times=n/T。如何求最大字符串和最小字符串呢？这个就需要用到字符串的最小表示法和最大表示法。这里简单描述一下字符串的最小表示法，至于字符串的最大表示法，可以将最小表示法照搬修改即可。<br>字符串的最小表示法：<br>设定一个opt1和一个opt2与k。初始opt1=0，opt2=1，k=0，一开始指向s[0],s[1]<br>如果s[opt1+k]==s[opt2+k]，则k++.注意opt2+k可能越界，所以要对len取模。当k==len时，说明每一个字符串都恰好等于，没有字符串比当前的小。就直接返回min(opt1,opt2)<br>如果s[opt1+k]&gt;s[opt2+k],说明s[opt1…..opt1+k]之间的每个字符都不可能作为最小字符串的起始点.于是opt1滑至opt1+k+1，k=0.<br>如果s[opt1+k]&lt;s[opt2+k],说明s[opt2…..opt2+k]之间的每个字符都不可能作为最小字符串的起始点.于是opt2滑至opt2+k+1，k=0.<br>如果opt1==opt2，则让刚才修改过的opt++；<br>最后返回min(opt1,opt2)就可以了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int len1,len2,Next[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int get_min(){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len2&amp;&amp;opt2&lt;len2&amp;&amp;k&lt;len2)    {        if(s2[(opt1+k)%len2]==s2[(opt2+k)%len2])k++;        else if(s2[(opt1+k)%len2]&gt;s2[(opt2+k)%len2])        {            opt1=opt1+k+1,k=0;            if(opt1==opt2)                opt1++;        }        else if(s2[(opt1+k)%len2]&lt;s2[(opt2+k)%len2])        {            opt2=opt2+k+1,k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int get_max(){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len2&amp;&amp;opt2&lt;len2&amp;&amp;k&lt;len2)    {        if(s2[(opt1+k)%len2]==s2[(opt2+k)%len2])k++;        else if(s2[(opt1+k)%len2]&lt;s2[(opt2+k)%len2])        {            opt1=opt1+k+1,k=0;            if(opt1==opt2)                opt1++;        }        else if(s2[(opt1+k)%len2]&gt;s2[(opt2+k)%len2])        {            opt2=opt2+k+1,k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int main(){    while(scanf(&quot;%s&quot;,s2)!=EOF)    {        len2=strlen(s2);        memset(Next,0,sizeof(Next));        next_pre();        int T=len2-Next[len2];int times=0;        if(len2%T==0)        {            times=len2/T;        }        else             times=1;        int x1=get_min();        int x2=get_max();        printf(&quot;%d %d %d %d\n&quot;,x1+1,times,x2+1,times);    }    return 0;}</code></pre>        <div id="aplayer-jQxiDhaL" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-jQxiDhaL"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
      <tag>字符串的最小(大)表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2609</title>
    <link href="/2020/02/07/HDU-2609/"/>
    <url>/2020/02/07/HDU-2609/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 2609 How many</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2609" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2609</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给n个字符串，每个字符串可以滑动形成新的字符串，问有多少个不同的字符串。<br>ps：若一个字符串滑动后与另一个字符串相同，则这两个字符串相同。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>先将每个字符串的最小表示法找到，然后用string数组储存字符串的最小表示法，然后sort排序，匹配找到总数</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+5;const int maxm=100+5;int len2,Next[maxn],len1,n;string s[maxn];char a[maxn][maxm];int cmp(string x,string y){    return x&lt;y;}int get_min(int opt){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len1&amp;&amp;opt2&lt;len1&amp;&amp;k&lt;len1)    {        if(s[opt][(opt1+k)%len1]==s[opt][(opt2+k)%len1])k++;        else if(s[opt][(opt1+k)%len1]&gt;s[opt][(opt2+k)%len1])        {            opt1=opt1+k+1;k=0;            if(opt1==opt2)                opt1++;        }        else if(s[opt][(opt1+k)%len1]&lt;s[opt][(opt2+k)%len1])        {            opt2=opt2+k+1;k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(a,0,sizeof(a));//char  与 string不同，必须清空！string s[i] 清空：s[i].clear();         for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];        for(int i=1;i&lt;=n;i++)        {            len1=s[i].length();            int x=get_min(i);            int opt=0;            while(opt&lt;len1)            {                a[i][opt]=s[i][(x+opt)%len1];                opt++;            }        }        for(int i=1;i&lt;=n;i++)s[i]=a[i];        sort(s+1,s+1+n,cmp);        int ans=1;        for(int i=2;i&lt;=n;i++)        {            if(s[i]!=s[i-1])ans++;        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-zaNSTfgN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-zaNSTfgN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>字符串的最小(大)表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FZU-1901</title>
    <link href="/2020/02/07/FZU-1901/"/>
    <url>/2020/02/07/FZU-1901/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>FZU - 1901 Period II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/FZU-1901" target="_blank" rel="noopener">https://vjudge.net/problem/FZU-1901</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>对于一个正整数p，p&lt;=字符串的长度，使得任意的s[i]==s[i+p]，求出所有符合要求的p。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题和之前的某个题意很迷的密码题有点相似，那个题当时就是用的ex-kmp，做这个题开始时题意不理解，百度了一下题意。一开始想的就是用kmp，似乎网上用kmp的很多，但我一下子不知道如何运行Next，不过，我突然发现，令s2=s1，用s1的所有后缀匹配s2的结果让我意外，所有符合Extend[i]+i&gt;=len的都是p，当然len本身也是。很显然这个题可以用ex-kmp来做。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int T,len1,len2,Next[maxn],Extend[maxn],Ans[maxn];string s1,s2;//s1的所有后缀与s2匹配 void next_pre(){    int i=0,po=0;    while(s2[i]==s2[i+1]&amp;&amp;i+1&lt;len2)i++;    Next[0]=len2;Next[1]=i;po=1;    for(int i=2;i&lt;len2;i++)    {        if(Next[i-po]+i&lt;Next[po]+po)            Next[i]=Next[i-po];        else         {            int j=Next[po]+po-i;            if(j&lt;0)j=0;            while(s2[j+i]==s2[j]&amp;&amp;i+j&lt;len2)j++;            Next[i]=j;            po=i;        }    }} void extend_pre(){    int i=0,po=0;    while(s1[i]==s2[i]&amp;&amp;i&lt;len2&amp;&amp;i&lt;len1)i++;    Extend[0]=i;    for(int i=1;i&lt;len1;i++)    {        if(Next[i-po]+i&lt;Extend[po]+po)            Extend[i]=Next[i-po];        else         {            int j=Extend[po]+po-i;            if(j&lt;0)j=0;            while(s1[j+i]==s2[j]&amp;&amp;i+j&lt;len1&amp;&amp;j&lt;len2)j++;            Extend[i]=j;            po=i;        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);int now=0;    while(now&lt;T)    {        now++;        memset(Next,0,sizeof(Next));        memset(Extend,0,sizeof(Extend));        memset(Ans,0,sizeof(Ans));        cin&gt;&gt;s2;s1=s2;        len2=s2.length();len1=s1.length();        next_pre();        extend_pre();        int opt=0,res=0;int ans=0;        for(int i=0;i&lt;len2;i++)        {            if(Extend[i]+i&gt;=len2&amp;&amp;i!=0)            {                Ans[++ans]=i;            }            }        Ans[++ans]=len2;        printf(&quot;Case #%d: %d\n&quot;,now,ans);        for(int i=1;i&lt;ans;i++)printf(&quot;%d &quot;,Ans[i]);printf(&quot;%d\n&quot;,Ans[ans]);    }    return 0;}//注意数组不能太大，容易TLE //一开始找到第一个Extend[i]+i&gt;=len2就以为找到循环节了，实际上有问题。要线性枚举一遍才行！</code></pre>        <div id="aplayer-XSthxqpq" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-XSthxqpq"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>ex-kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3068</title>
    <link href="/2020/02/07/HDU-3068/"/>
    <url>/2020/02/07/HDU-3068/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3068 最长回文</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3068" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3068</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求多组数据的最长回文的长度，就是Manacher的模板题</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>讲解一下Manacher算法<br>首先该算法的时间复杂度为O(N)，一个长度为len的字符串，len可能为奇数，也可能是偶数，那么中间点就不一样了，那对于长度L=2len+1呢？<br>显然它一定是奇数。具体操作为：<br>t[0]=’$’;<br>for(int i=1;i&lt;=len;i++)t[++len]=’#’,t[++len]=s[i-1];<br>t[++len]=’#’;<br>比如字符串 abccba 就转换成了 $#a#b#c#c#b#a#;</p><p>以上是初始化的过程，接下来是具体的操作过程：<br>对于p[i]，如果i&lt;mx，设j是i关于id对称点，如图所示，则基于以下三种情况，可以求出p[i]的值：</p><p>（1）以j为中心的回文串有一部分在以id为中心的回文串之外。因为mx是以id为中心的最长回文的右边界，所以以i为中心的回文串不可能会有字符在以id为中心的回文串之外；否则mx就不是以id为中心的最长回文的右边界。所以，在这种情况下，p[i]=mx–i。<br>具体阐释一下：此时s[id,id+1,…i-1,i]=s[id,id-1,…,j+1,j]，假如以i为中心的回文串有字符在以id为中心的回文串之外，显然mx不应该为右边界！</p><p>（2）以j为中心的回文串全部在以id为中心的回文串的内部，则p[i]=p[j]，而且p[i]不可能再增加。</p><p>（3）以j为中心的回文串的左端正好与以id为中心的回文串的左端重合。则p[i]=p[j]或p[i]=mx–i，并且p[i]还有可能会继续增加，即while (s_new[i-p[i]]==s_new[i+p[i]]) p[i]++;</p><p>所以，if (i &lt; mx) p[i] = min(p[2 <em> id - i], mx- i)；其中2</em>id - i为i关于id的对称点，即上面的j点，而p[j]表示以j为中心的最长回文半径，因此可以利用p[j]来加快求解p[i]。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=110000*2+100;char s[maxn],t[maxn];int len,p[maxn];int main(){    while(scanf(&quot;%s&quot;,s)!=EOF)    {        len=0;memset(p,0,sizeof(p));        memset(t,0,sizeof(t));        int L=strlen(s),ans=0;        t[0]=&#39;$&#39;;        for(int i=1;i&lt;=L;i++)        {            t[++len]=&#39;#&#39;;t[++len]=s[i-1];        }        t[++len]=&#39;#&#39;;        int id=0,mx=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]])p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;            }            ans=max(ans,p[i]-1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-srWozmql" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-srWozmql"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4513</title>
    <link href="/2020/02/07/HDU-4513/"/>
    <url>/2020/02/07/HDU-4513/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4513 吉哥系列故事——完美队形II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4513#author=hzoi2017_wty" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4513#author=hzoi2017_wty</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>假设有n个人按顺序的身高分别是h[1], h[2] … h[n]，从中挑出一些人形成一个新的队形，新的队形若满足以下要求，则就是新的完美队形：<br>　　1、连续的<br>　　2、形成回文串<br>　　3、从左到中间那个人，身高需保证不下降</p><p>　　　问有组成完美队形的最多人数</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>要求连续的并且是回文串，这很明显就是回文串的题，应该用Manacher算法，但是又要求从左到中间，身高不下降，就需要修改一下判定条件：    while(t[i+p[i]]==t[i-p[i]]&amp;&amp;(t[i-p[i]]==0||t[i-p[i]]&lt;=t[i-p[i]+2]))p[i]++;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000*2+15;int T,n,p[maxn],s[maxn],t[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(p,0,sizeof(p));        memset(t,0,sizeof(t));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;s[i]);        int len=0;        t[0]=10000;        for(int i=1;i&lt;=n;i++)        {            t[++len]=0;t[++len]=s[i];        }        t[++len]=0;        int id=0,mx=0,ans=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]]&amp;&amp;(t[i-p[i]]==0||t[i-p[i]]&lt;=t[i-p[i]+2]))p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;            }            ans=max(ans,p[i]-1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-PrFxYPVP" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-PrFxYPVP"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3294</title>
    <link href="/2020/02/07/HDU-3294/"/>
    <url>/2020/02/07/HDU-3294/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3294 Girls’ research</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3294#author=asasas5d" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3294#author=asasas5d</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>先给一个字符x，然后给一个 字符串，表示字符串中所有字符x变成’a’，其余的字符依次往前变换。例如b babad就转换成azazc。让寻找第一个最长回文串，长度若小于2，则输出No solution!，否则输出起点，终点和转换后的最长回文串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最长回文串问题，当然就是用Manacher，先计算出字符x与‘a’的差值，然后将字符串进行转换。然后直接跑Manacher，更新ans时注意更新储存一下终点和起点</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000*2+105;int p[maxn],len,a[maxn],S,T;char s[maxn],t[maxn],x[3];int main(){    while(scanf(&quot;%s&quot;,x)!=EOF)    {        len=0;S=0;T=0;        scanf(&quot;%s&quot;,&amp;s);        int delt=x[0]-&#39;a&#39;;        int L=strlen(s);        for(int i=0;i&lt;L;i++)        {            a[i]=s[i]-&#39;a&#39;-delt;            if(a[i]&lt;0)a[i]+=26;            s[i]=a[i]+&#39;a&#39;;        }        t[0]=&#39;$&#39;;        for(int i=1;i&lt;=L;i++)        {            t[++len]=&#39;#&#39;;t[++len]=s[i-1];        }        t[++len]=&#39;#&#39;;        int mx=0,id=0,ans=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]])p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;                if(ans&lt;p[i]-1)                {                    ans=p[i]-1;                    T=(mx-1)/2;                    S=T-ans+1;                    T--;S--;                }            }        }        if(ans&lt;2)        {            printf(&quot;No solution!\n&quot;);        }        else         {            printf(&quot;%d %d\n&quot;,S,T);            for(int i=S;i&lt;=T;i++)            printf(&quot;%c&quot;,s[i]);cout&lt;&lt;endl;        }    }    return 0;}</code></pre><p>//注意读入时要！=EOF，否则TLE</p>        <div id="aplayer-aiwzsGjf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-aiwzsGjf"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4763</title>
    <link href="/2020/02/07/HDU-4763/"/>
    <url>/2020/02/07/HDU-4763/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4763 Theme Section</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4763#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4763#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>字符串E是字符串S的前缀和后缀，同时也出现在字符串S的中间，不与前缀后缀重合，问字符串S中符合要求的字符串E的最大长度。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这题显示是kmp问题，kmp中Next[i]表示字符串s从0…..i-1中前缀与后缀的最大公共子串，而问题就是求EAEBE，A，B长度任意(可以为0)，显然E最长为Next[len]，于是可以从len-Next[len]开始往前看Next[now]与E的大小关系，now&gt;=2*E，因为不可以重叠，如果找不到呢，E就应该缩小，理论是E—，所以E=Next[E]，继续寻找，直到找到或者无法继续。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int n,len1,len2,Next[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        memset(Next,0,sizeof(Next));        scanf(&quot;%s&quot;,s2);        len2=strlen(s2);        next_pre();        int L=Next[len2];        int sign=0;        while(L)        {            int now=len2-L;            while(Next[now]==0&amp;&amp;now&gt;=2*L)now--;            while(now&gt;=2*L)            {                if(Next[now]&gt;=L)                {                    break;                }                else now--;            }            if(Next[now]&gt;=L&amp;&amp;now&gt;=2*L)            {                sign=1;                printf(&quot;%d\n&quot;,L);                break;            }            L=Next[L];        }        if(sign==0)        {            printf(&quot;0\n&quot;);            continue;        }    }    return 0;}</code></pre><p>//注意要判定now&gt;=2*L！</p>        <div id="aplayer-SSAuVByL" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-SSAuVByL"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2387</title>
    <link href="/2020/02/07/POJ-2387/"/>
    <url>/2020/02/07/POJ-2387/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2387 Til the Cows Come Home</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2387#author=ght5160" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2387#author=ght5160</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求从1到n的最短距离</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最短路模板，spfa或者dijkstra+堆优化。<br>朴素Dijkstra：时间复杂度o(n^2)<br>堆优化Dijkstra：时间复杂度o(（V+E）logV）</p><p>spfa在稀疏图O（E），稠密图O（VE）</p><p>dijkstra+堆优化的代码：</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=2000+5;int n,m,k=1,dist[maxn],vis[maxn],head[maxn];struct node{    int to,next,w;}edge[maxn*2];struct N{    int now,w;    bool operator &lt; (N x)const{return x.w&lt;w;}};void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(!vis[edge[i].to]&amp;&amp;dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);add(a,b,c);add(b,a,c);    }    dijkstra();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre><p>spfa的代码：</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=2000+5;int n,m,k=1,head[maxn],dist[maxn],vis[maxn]; struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(){    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    queue&lt;int&gt;q;    dist[1]=0;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    q.push(edge[i].to);                    vis[edge[i].to]=1;                }            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);add(a,b,c);add(b,a,c);    }    spfa();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre>        <div id="aplayer-CtMKvwHc" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CtMKvwHc"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2253</title>
    <link href="/2020/02/07/POJ-2253/"/>
    <url>/2020/02/07/POJ-2253/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2253 Frogger</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2253#author=dusenlin" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2253#author=dusenlin</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>两块石头之间的青蛙距离被定义为两块石头之间所有可能路径上的最小必要跳跃距离，某条路径的必要跳跃距离即这条路径中单次跳跃的最远跳跃距离。求1到2的最小必要跳跃距离。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>数据很小，符合Floyd算法。每一次更新的时候需要调整一下：<br>dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));<br>因为必要跳跃距离是指整个路径单次跳跃的最远距离，所以取max</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=200+5;int n;double dist[maxn][maxn],x[maxn],y[maxn];int main(){    int opt=0;    while(1)    {        opt++;        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                dist[i][j]=0x3f3f3f3f;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(i!=j)                dist[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));            }        }        for(int k=1;k&lt;=n;k++)        {            for(int i=1;i&lt;=n;i++)            {                for(int j=1;j&lt;=n;j++)                {                    dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));                }            }            }        printf(&quot;Scenario #%d\n&quot;,opt);        printf(&quot;Frog Distance = %.3lf\n&quot;,dist[1][2]);        cout&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-hzPpgfKd" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-hzPpgfKd"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1797</title>
    <link href="/2020/02/07/POJ-1797/"/>
    <url>/2020/02/07/POJ-1797/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1797 Heavy Transportation</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1797#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1797#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求1-n路径上边权最小值最大。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最短路径的变形题，用spfa来实现<br>原本的dist[edge[i].to]=min(dist[edge[i].to],dist[x]+edge[i].w)<br>修改为dist[edge[i].to]=max(dist[edge[i].to],min(dist[x],edge[i].w)<br>注意初始化dist全为0，由于收缩，dist[1] =0x3f3f3f3f;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000000+5;const int maxm=1000+5;int k=1,T,n,m,head[maxm],vis[maxm],dist[maxm];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    dist[1]=0x3f3f3f3f;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;min(dist[x],edge[i].w))            {                dist[edge[i].to]=min(dist[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);int opt=0;    while(T--)    {        opt++;        memset(head,0,sizeof(head));        k=1;memset(edge,0,sizeof(edge));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,c);        }        spfa();        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,dist[n]);    }}</code></pre>        <div id="aplayer-egSiCWWx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-egSiCWWx"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3268</title>
    <link href="/2020/02/07/POJ-3268/"/>
    <url>/2020/02/07/POJ-3268/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3268 Silver Cow Party</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3268#author=Demon_de_Laplace" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3268#author=Demon_de_Laplace</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>N头牛，M条单行道，在s出举行聚会，每头牛出发和返回都是走最短路，问所有牛中走的路程最远的牛走了多远？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>建边的时候建双向边，k=2开始.<br>当边号为偶数时，说明是正边；<br>当边号为奇数时，说明时反边；<br>从s出发，跑正边，dist[i]存的是从s到i的最短距离；<br>从s出发，跑反边，dist[i]存的是从i到s的最短距离；<br>ans=max(ans,dist1[i]+dist2[i])</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int n,m,t,k=1,head[maxn],vis[maxn],dist1[maxn],dist2[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa1(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist1,0x3f3f3f3f,sizeof(dist1));    vis[t]=1;dist1[t]=0;    q.push(t);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(i%2==1)continue;            if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)            {                dist1[edge[i].to]=dist1[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void spfa2(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist2,0x3f3f3f3f,sizeof(dist2));    vis[t]=1;dist2[t]=0;    q.push(t);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(i%2==0)continue;            if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)            {                dist2[edge[i].to]=dist2[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);add(b,a,c);    }    spfa1();spfa2();    int ans=0;    for(int i=1;i&lt;=n;i++)    {        ans=max(ans,dist1[i]+dist2[i]);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-sfWIvqZS" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-sfWIvqZS"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1860</title>
    <link href="/2020/02/07/POJ-1860/"/>
    <url>/2020/02/07/POJ-1860/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1860 Currency Exchange</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1860#author=riba2534" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1860#author=riba2534</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出每两种货币之间交换的手续费和汇率，求出从当前货币s开始交换，能否赚。能赚输出YES，否则输出NO</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>运用spfa判断是否存在存在正环(类似于判负环)。和判负环一样，记录一下点出现的次数，一旦出现此次数&gt;n就可以作出判断。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10000+5;int n,m,s,k=1,head[maxn],vis[maxn],used[maxn];double w,dist[maxn];struct node{    int to,next;double w,q;}edge[maxn*2];void add(int u,int v,double q,double w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].q=q;}int spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    dist[s]=w;vis[s]=1;used[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;(dist[x]-edge[i].w)*edge[i].q)            {                dist[edge[i].to]=(dist[x]-edge[i].w)*edge[i].q;                if(!vis[edge[i].to])                {                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d%lf&quot;,&amp;n,&amp;m,&amp;s,&amp;w);    for(int i=1;i&lt;=m;i++)    {        int a,b;double w1,w2,q1,q2;        scanf(&quot;%d%d%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;q1,&amp;w1,&amp;q2,&amp;w2);        add(a,b,q1,w1);add(b,a,q2,w2);    }    int x=spfa();    if(x==1)printf(&quot;YES\n&quot;);    else printf(&quot;NO\n&quot;);    return 0;}</code></pre>        <div id="aplayer-fOAdgYzp" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-fOAdgYzp"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3259</title>
    <link href="/2020/02/07/POJ-3259/"/>
    <url>/2020/02/07/POJ-3259/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3259 Wormholes</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3259#author=chen_zhe_" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3259#author=chen_zhe_</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个教室，m条走廊(双向)，w条密道(单向)。走廊耗时&gt;0，密道可耗时&lt;0，问是否可以回到过去。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>密道耗时&lt;0，再根据题目要求，就是问该图是否存在负环。由于这是一个连通图，从哪个点出发效果都一样，不妨从1开始出发，判断是否存在负环，判断方法：每次进行收缩时记录次数++，一旦超过了n就可以作出判断。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=50000+5;int k=1,T,n,m,w,head[maxn],vis[maxn],dist[maxn],used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int spfa(){    queue&lt;int&gt;q;    memset(used,0,sizeof(used));    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    vis[1]=1;dist[1]=0;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;w);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,c);        }        for(int i=1;i&lt;=w;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,-c);        }        int x=spfa();        if(x==1)printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    }    return 0;}</code></pre>        <div id="aplayer-gcTxuiEY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-gcTxuiEY"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1502</title>
    <link href="/2020/02/07/POJ-1502/"/>
    <url>/2020/02/07/POJ-1502/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1502 MPI Maelstrom</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1502#author=20175101008" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1502#author=20175101008</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出a[i][j]之间的值，若a[i][j]==’x’说明i，j之间不通，问从1开始同时向2…..n传递信息，需要多久全部结点都收到？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=100，显然可以用Floyd算法，读入时字符串读入，加以处理，得到a[i][j]之间的距离，i，j不通则将长度设为无穷大，然后开始跑Floyd，最后统计dist[1][i],i∈[2,n]的最大值，该值为答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200+5;int n,a[maxn][maxn],dist[maxn][maxn];int main(){    memset(dist,0x3f3f3f3f,sizeof(dist));    scanf(&quot;%d&quot;,&amp;n);    char x[10];    for(int i=2;i&lt;=n;i++)    {        for(int j=1;j&lt;i;j++)        {            scanf(&quot;%s&quot;,x);            if(x[0]==&#39;x&#39;)a[j][i]=a[i][j]=0x3f3f3f3f;            else             {                int sum=0;                for(int k=0;k&lt;=strlen(x)-1;k++)                {                    sum=sum*10+x[k]-&#39;0&#39;;                }                a[j][i]=a[i][j]=sum;            }        }    }    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(i==j)dist[i][j]=0;            else dist[i][j]=a[i][j];        }    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);            }        }    }    int ans=0;    for(int i=2;i&lt;=n;i++)    ans=max(ans,dist[1][i]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-VaArdtzF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-VaArdtzF"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3660</title>
    <link href="/2020/02/07/POJ-3660/"/>
    <url>/2020/02/07/POJ-3660/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3660 Cow Contest</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3660#author=arasHi_" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3660#author=arasHi_</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n头牛，m条比赛结果，每行两个数字，第一个数字表示的是胜利者。<br>问有几头牛的排名可以确定？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>排名可以确定，这该如何理解？对于结点i，如果箭头指向i所包含的结点数为ans1，i箭头指出所包含的结点数为ans2，若ans1+ans2==n-1就说明结点i的排名可以确定。问题在于如何确定ans1，ans2的值。<br>举个例子：若a可以到b，b可以到c，那么a就可以到c。这就是传递闭包了。<br><img src="https://img-blog.csdn.net/20170409190428811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MTM3NjEyNDA2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>如何进行传递闭包呢？以上例子，a可以到b，b可以到c，则dist[a][b]=1,dist[b][c]=1,则a可以到c，即dist[a][c]=1；用floyd进行收缩即可。然后每个结点是否可以到达剩余的n-1个结点，或者剩余n-1个结点能否到达该结点，即ans1+ans2==n。判断条件就是dist[i][j]==1||dist[j][i]==1;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int n,m,dist[maxn][maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=m;i++)    {        int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        dist[a][b]=1;    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(dist[i][k]==1&amp;&amp;dist[k][j]==1)                dist[i][j]=1;            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        int sign=0;        for(int j=1;j&lt;=n;j++)        {            if(i==j)continue;            if(dist[i][j]||dist[j][i])continue;            else sign=1;        }        if(sign==0)ans++;    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-UvhTJipR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-UvhTJipR"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>闭包传递</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2240</title>
    <link href="/2020/02/07/POJ-2240/"/>
    <url>/2020/02/07/POJ-2240/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2240 Arbitrage</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2240#author=Andy_acmer" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2240#author=Andy_acmer</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n种货币，m条货币的汇率关系。比如：USDollar 0.5 BritishPound<br>说明1个USDollar货币，可以换成0.5个BritishPound货币，问是否可以通过这种关系来获利。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>由于货币名字使字符串，那么用map比较方便,map<string,int>q，可以将字符串映射成int型。然后跑spfa，看是否存在正环，与判断负环的方法一样。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;const int maxn=10000+5;int n,m,head[maxn],vis[maxn],used[maxn],k=1;double dist[maxn];map&lt;string,int&gt;q;struct node{    int to,next;double w;}edge[maxn*2];void add(int u,int v,double w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;    }int spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    vis[1]=1;used[1]=1;dist[1]=1.0;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;dist[x]*edge[i].w)            {                dist[edge[i].to]=dist[x]*edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    int now=0;    while(1)    {        now++;        k=1;memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        q.clear();        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        int tot=0;        for(int i=1;i&lt;=n;i++)        {            string x;cin&gt;&gt;x;            q[x]=++tot;            }                scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            string a,b;double c;            cin&gt;&gt;a&gt;&gt;c&gt;&gt;b;            add(q[a],q[b],c);        }        int x=spfa();        printf(&quot;Case %d: &quot;,now);        if(x==1)printf(&quot;Yes\n&quot;);        else printf(&quot;No\n&quot;);    }    return 0;}</code></pre>        <div id="aplayer-dmdbfTPE" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-dmdbfTPE"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1511</title>
    <link href="/2020/02/07/POJ-1511/"/>
    <url>/2020/02/07/POJ-1511/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1511 Invitation Cards</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1511#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1511#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>n-1个人从1号点出发，到剩余n-1个宣传点，然后再回到1号点汇报结果，求所有人往返路径和的最小值。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>m条边，边号为偶数的表示正方向，边号为奇数的表示反方向。spfa1()沿着正方向跑，起点为1，则dist[i]表示的是从1到i的最短距离。spfa2()沿着反方向跑，起点为1，则dist2[i]表示的是从i到1的最短距离。最终答案就是dist1[i]+dist2[i]的总和，i∈[2,n]。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">    #include&lt;cstdio&gt;    #include&lt;cstring&gt;    #include&lt;iostream&gt;    #include&lt;algorithm&gt;    #include&lt;queue&gt;    using namespace std;    const long long maxn=1000000+5;    struct node    {        long long to,next,w;    }edge[maxn*2];    long long k=1,head[maxn],vis[maxn],dist1[maxn],dist2[maxn],T,n,m;    void add(long long u,long long v,long long w)    {        edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;    }    void spfa1()//1到其余所有点     {        queue&lt;long long&gt;q;        memset(vis,0,sizeof(vis));        memset(dist1,0x3f3f3f3f,sizeof(dist1));        dist1[1]=0;vis[1]=1;        q.push(1);        while(!q.empty())        {            long long x=q.front();q.pop();vis[x]=0;            for(long long i=head[x];i;i=edge[i].next)            {                if(i%2==1)continue;                if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)                {                    dist1[edge[i].to]=dist1[x]+edge[i].w;                    if(!vis[edge[i].to])                    {                        vis[edge[i].to]=1;                        q.push(edge[i].to);                    }                }            }        }    }    void spfa2()//其余所有点到1；     {        queue&lt;long long&gt;q;        memset(vis,0,sizeof(vis));        memset(dist2,0x3f3f3f3f,sizeof(dist2));        dist2[1]=0;vis[1]=1;        q.push(1);        while(!q.empty())        {            long long x=q.front();q.pop();vis[x]=0;            for(long long i=head[x];i;i=edge[i].next)            {                if(i%2==0)continue;                if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)                {                    dist2[edge[i].to]=dist2[x]+edge[i].w;                    if(!vis[edge[i].to])                    {                        vis[edge[i].to]=1;                        q.push(edge[i].to);                    }                }            }        }    }    int main()    {        scanf(&quot;%lld&quot;,&amp;T);        while(T--)        {            k=1;            memset(head,0,sizeof(head));            memset(edge,0,sizeof(edge));            scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);            for(long long i=1;i&lt;=m;i++)            {                long long a,b,c;                scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);                add(a,b,c);add(b,a,c);            }            spfa1();             spfa2();            long long ans=0;            for(long long i=2;i&lt;=n;i++)            {                ans+=dist1[i]+dist2[i];                }                printf(&quot;%lld\n&quot;,ans);        }        return 0;    }</code></pre>        <div id="aplayer-jYhdfCSf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-jYhdfCSf"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3159</title>
    <link href="/2020/02/07/POJ-3159/"/>
    <url>/2020/02/07/POJ-3159/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3159 Candies</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3159#author=2018112767" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3159#author=2018112767</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个同学，m条信息，每条信息为a,b,c三个整数表示a相信b的糖果不会比自己多于c。问n同学最多比1同学多多少个糖果？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是差分约束的题目，由题知Have[b]-Have[a]&lt;=c;即<br>Have[b]&lt;=c+Have[a]；而最短路的更新条件是dist[edge[i].to]&gt;dist[x]+edge[i].w，就说明了dist[edge[i].to]&lt;=dist[x]+edge[i].w;于是建边就可以a—-&gt;b,边权为c，跑最短路。dist[n]就是答案</p><p>ps：一开始跑spfa，TLE，此图有点稠密，用dijkstra+堆优化更保险！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=150000+5;struct node{    int to,next,w;}edge[maxn*2];int k=1,head[maxn],vis[maxn],dist[maxn],n,m;void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}struct N{    int now,w;    bool operator &lt; (N x) const{return x.w&lt;w;}};void spfa(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);    }    dijkstra();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre>        <div id="aplayer-KcnUPNvG" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KcnUPNvG"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>差分约束</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2502</title>
    <link href="/2020/02/07/POJ-2502/"/>
    <url>/2020/02/07/POJ-2502/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2502 Subway</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2502#author=1738160864" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2502#author=1738160864</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>小k要从家去学校，他可以选择步行或者地铁，步行的速度是10km/h，地铁的速度是40km/h。假设小k非常的幸运，每次他到地铁站就立刻会有地铁。小k可以随意上下地铁，并且可以在地铁线路之间转换。所有的地铁运行都是双向的。<br>注意地铁站不会重复出现。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=200，所以可以用Floyd。每次出现的新地铁站，先与起点更新时间花费，此时速度为v1，然后输入地铁线，此时速度为v2，可以更新相邻地铁站之间的时间花费，并且更新起点与地铁站之间的时间花费，此时速度为v1。最后地铁站输入完之后，tot++，这就是终点编号，所有结点与终点的时间花费需要更新。然后开始跑Floyd。最后dist[0][tot]储存答案，需要四舍五入，即int ans=dist[0][tot]+0.5;ans为最终答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int maxn=200+5;double v1=10*1000/60;double v2=40*1000/60;double dist[maxn][maxn],a[maxn][maxn],x[maxn],y[maxn],sx,sy,tx,ty;int main(){    int tot=1;int s=0;    memset(a,0x7f7f7f7f,sizeof(a));    memset(dist,0x7f7f7f7f,sizeof(dist));    scanf(&quot;%lf%lf%lf%lf&quot;,&amp;sx,&amp;sy,&amp;tx,&amp;ty);    while(scanf(&quot;%lf%lf&quot;,&amp;x[tot],&amp;y[tot])!=EOF)    {        a[tot][0]=a[0][tot]=sqrt((sx-x[tot])*(sx-x[tot])+(sy-y[tot])*(sy-y[tot]))/v1;        while(1)        {            tot++;            scanf(&quot;%lf%lf&quot;,&amp;x[tot],&amp;y[tot]);            if(x[tot]==-1&amp;&amp;y[tot]==-1)            {                break;            }            a[tot][tot-1]=a[tot-1][tot]=sqrt((x[tot]-x[tot-1])*(x[tot]-x[tot-1])+(y[tot]-y[tot-1])*(y[tot]-y[tot-1]))/v2;            a[tot][0]=a[0][tot]=sqrt((sx-x[tot])*(sx-x[tot])+(sy-y[tot])*(sy-y[tot]))/v1;                    }    }        for(int i=1;i&lt;=tot;i++)        {            for(int j=1;j&lt;=tot;j++)            {                a[i][j]=a[j][i]=min(a[i][j],sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/v1);            }        }        tot++;        a[0][tot]=a[tot][0]=sqrt((sx-tx)*(sx-tx)+(sy-ty)*(sy-ty))/v1;        for(int i=1;i&lt;tot;i++)        {            a[i][tot]=a[tot][i]=sqrt((x[i]-tx)*(x[i]-tx)+(y[i]-ty)*(y[i]-ty))/v1;        }        for(int i=0;i&lt;=tot;i++)        {            for(int j=0;j&lt;=tot;j++)            {                dist[i][j]=a[i][j];            }        }        for(int k=0;k&lt;=tot;k++)        {            for(int i=0;i&lt;=tot;i++)            {                for(int j=0;j&lt;=tot;j++)                {                    dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);                }            }        }        int ans=dist[0][tot]+0.5;        printf(&quot;%d\n&quot;,ans);        return 0;}</code></pre>        <div id="aplayer-DtAphVYy" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DtAphVYy"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1062</title>
    <link href="/2020/02/07/POJ-1062/"/>
    <url>/2020/02/07/POJ-1062/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1062 昂贵的聘礼</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1062#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1062#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一个人要买1号物品，而此物品可以通过直接购买或者到别人的手中买别的东西+一些金币来得到。但是需要注意：如果两人地位等级差距超过了delt，就不可以进行间接交易，即该交易圈的人两两之间等级差异不可大于delt。问要得到1号物品至少要花费多少钱？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>建立一个源点，它与所有物品建边，即s—&gt;i（边权为物品原价），因为每个物品除了直接购买，还可以间接购买，设间接购买物品为j，则建边方式为j—&gt;i（边权为额外金币）然后跑最短路，注意最短路的条件不再是dist[edge[i].to]&gt;dist[x]+edge[i].w，因为当价格相等时也需要进入队列来进行松弛，所以应变为dist[edge[i].to]&gt;dist[x]+edge[i].w;然后就是等级限制的判断了。刚开始的s的等级需要从最低到最高都设置一次，意味着跑n次spfa，s就是这次spfa的最低等级，因此a[edge[i].to].l&gt;=limit&amp;&amp;edge[i].to]-limit&lt;=delt||x==0||delt==0；delt==0意味着没有等级限制。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int n,delt,head[maxn],vis[maxn],dist[maxn],k=1,liv[maxn],ans=0x3f3f3f3f;struct Node{    int p,l,x;}a[maxn];struct node{    int next,to,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(int limit){    queue&lt;int&gt;q;    for(int i=1;i&lt;=n;i++)dist[i]=a[i].p;    memset(vis,0,sizeof(vis));    vis[0]=1;dist[0]=0;    q.push(0);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;=dist[x]+edge[i].w&amp;&amp;(delt==0||(a[edge[i].to].l&gt;=limit&amp;&amp;a[edge[i].to].l-limit&lt;=delt)))            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }        }    ans=min(ans,dist[1]);}int main(){    scanf(&quot;%d%d&quot;,&amp;delt,&amp;n);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d%d%d&quot;,&amp;a[i].p,&amp;a[i].l,&amp;a[i].x);        liv[i]=a[i].l;        add(0,i,a[i].p);        for(int j=1;j&lt;=a[i].x;j++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            add(x,i,y);        }    }    sort(liv+1,liv+1+n);    for(int i=1;i&lt;=n;i++)    spfa(liv[i]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-YJxGLXjs" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-YJxGLXjs"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1847</title>
    <link href="/2020/02/07/POJ-1847/"/>
    <url>/2020/02/07/POJ-1847/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1847 Tram</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1847" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1847</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>输入n,a,b三个数，表示有n个点(1-n)，起点是a，终点是b，然后接下来有n行，每一行的第一个数m表示后面将会有m个数，输入结构是这样的，然后我再具体的解释一下。</p><p>3 2 1     3表示共有n个点，接下来有n行，2表示起点，1表示终点<br>2 2 3     第一个数2表示后面有2个数，因为这是第1行，所以后面两个数表示从1到2和从1到3的边<br>2 3 1     表示从2到3和从2到1的边<br>2 1 2     表示从3到1和从3到2的边</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=100，可以跑Floyd，dist初始化无穷大，每个结点所连接的第一个结点与它的距离为0，其余相连的为1，然后跑Floyd。dist[s][t]为最终的结果。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int n,s,t,dist[maxn][maxn];int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;s,&amp;t);    memset(dist,0x3f3f3f3f,sizeof(dist));    for(int i=1;i&lt;=n;i++)    {        int m;        scanf(&quot;%d&quot;,&amp;m);        for(int j=1;j&lt;=m;j++)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            if(j==1)            {                dist[i][x]=0;            }            else             {                dist[i][x]=1;            }        }    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);            }        }    }    if(dist[s][t]&lt;0x3f3f3f3f)    printf(&quot;%d\n&quot;,dist[s][t]);    else     printf(&quot;-1\n&quot;);    return 0;}</code></pre>        <div id="aplayer-bxrZCDvN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-bxrZCDvN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LightOJ1074</title>
    <link href="/2020/02/07/LightOJ-1074/"/>
    <url>/2020/02/07/LightOJ-1074/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>LightOJ - 1074 Extended Traffic</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/LightOJ-1074#author=bbisnouse" target="_blank" rel="noopener">https://vjudge.net/problem/LightOJ-1074#author=bbisnouse</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在一个堵车的城市中, 每个路口都有一个拥挤程度a[i], 从u驶向v得到一个数量, 值为(a[v]-a[u])^3, 给出Q组查询, 每组给出一个数, 求1到这个数的点的最小数量, 如果不可达输出 ？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始觉得n很小，可以直接跑floyd，但是后来WA了两发，发现可能存在负环，所以需要判断负环，因此选择spfa，一旦判断出了负环就dfs，找到负环可以达到的所有点。对于查询一一输出结果即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200005;int n,T,a[maxn],head[maxn],vis[maxn],dist[maxn],k=1,used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dfs(int x){    if(vis[x])return ;    vis[x]=1;dist[x]=0x3f3f3f3f;    for(int i=head[x];i;i=edge[i].next)    {        dfs(edge[i].to);    }}void spfa(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(used,0,sizeof(used));    dist[1]=0;vis[1]=1;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)                    {                        memset(vis,0,sizeof(vis));                        dfs(edge[i].to);                        return ;                    }                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=0;    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(a,0,sizeof(a));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);        int m;        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            int w=(a[y]-a[x])*(a[y]-a[x])*(a[y]-a[x]);            add(x,y,w);        }        spfa();        int p;        scanf(&quot;%d&quot;,&amp;p);        printf(&quot;Case %d:\n&quot;,opt);        for(int i=1;i&lt;=p;i++)        {            int t;            scanf(&quot;%d&quot;,&amp;t);            if(dist[t]==0x3f3f3f3f||dist[t]&lt;3)printf(&quot;?\n&quot;);            else printf(&quot;%d\n&quot;,dist[t]);        }    }    return 0;}</code></pre>        <div id="aplayer-CksjAwPK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CksjAwPK"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4725</title>
    <link href="/2020/02/07/HDU-4725/"/>
    <url>/2020/02/07/HDU-4725/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4725 The Shortest Path in Nya Graph</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4725#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4725#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>现在给你n个点 ，这些点的分布是层型分布的，你可以从第i层走到相邻的层（i+1，i-1）中，这样走的花费是c，接着他会给你m（从u-&gt;v）条小路，从小路走的花费 是w，问你从1-&gt;n所走的最小花费是多少。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>看到数据范围就不敢用spfa了，太过玄学，不想TLE，所以选择dijkstra，这题的难点在于建边。当然，很容易想到将层转化成点，比如第i个点的层数为deep[i],则转化为点deep[i]+n.对于给的小道就直接建边a—&gt;b权值为c,b—&gt;a权值为c（建双向边），将deep数组从小到大排列，对于deep[i] 和 deep[i-1] （i∈[2,n]），首先要判断它们是否刚好相差1，只有刚好相差1才可以建边，建边方式为add(deep[i-1]+n,deep[i]+n,c);add(deep[i]+n,deep[i-1]+n,c)，相邻层数可以相互移动，消耗为c。</p><p>如何将点和层联系起来呢？<br>点i与它本来层的关系：add(deep[i]+n,i,0)；<br>点i与它上一层的关系(deep[i]&gt;1)：add(i,deep[i]-1+n,c)<br>点i与它下一层的关系(deep[i]&lt;n)：add(i,deep[i]+1+n,c)</p><p>ps:不可以add(i,deep[i]+n,0)；<br>原因：<br>1<br>3 0 1<br>1 1 1<br>本身1是不可到达3的，如果强行add(i,deep[i]+n,0)就会导致同层所有点相连了！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;int n,m,T,k=1,c,head[maxn],vis[maxn],dist[maxn],deep[maxn];struct node{    int to,next,w;}edge[maxn*8];struct N{    int now,w;    bool operator &lt; (N x)const{return x.w&lt;w;}};void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    int now=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        now++;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(deep,0,sizeof(deep));        k=1;        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;c);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;deep[i]);//            add(i,n+deep[i],0);            add(n+deep[i],i,0);            if(deep[i]&gt;1)add(i,n+deep[i]-1,c);            if(deep[i]&lt;n)add(i,n+deep[i]+1,c);        }        sort(deep+1,deep+1+n);        for(int i=2;i&lt;=n;i++)        {            if(deep[i]-deep[i-1]!=1)continue;            add(deep[i-1]+n,deep[i]+n,c);            add(deep[i]+n,deep[i-1]+n,c);        }        for(int i=1;i&lt;=m;i++)        {            int a,b,w;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);            add(a,b,w);add(b,a,w);        }        dijkstra();        printf(&quot;Case #%d: &quot;,now);        if(dist[n]==0x3f3f3f3f)printf(&quot;-1\n&quot;);        else printf(&quot;%d\n&quot;,dist[n]);    }    return 0;}</code></pre>        <div id="aplayer-epjodska" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-epjodska"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3169</title>
    <link href="/2020/02/07/POJ-3169/"/>
    <url>/2020/02/07/POJ-3169/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3169 Layout</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3169#author=634579757" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3169#author=634579757</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有N头牛排队，多头牛可以在同一点。现有几对相互喜好的牛，他们不能超过一定距离，有几对相互厌恶的牛，他们至少隔开一定距离。求1和N最远相距多少。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这很显然是差分约束的题目。为了保证图能够联通，需要固定i，j的大小顺序。 对于前m1个a,b,c表示a和b之间的距离不超过c，不妨设a&gt;b，则应满足d[a]-d[b]&lt;=c，最短路的要求就是如此，所以建边：b—&gt;a 边权为c。对于后m2个a，b，c表示a和b之间的距离不小于c，不妨设a&gt;b，则应满足d[a]-d[b]&gt;=c，即d[b]&lt;=d[a]-c，所以建边：a—&gt;b边权为-c。然后开始跑spfa，期间要判断负环，如果有负环存在则说明无解；如果dist[n]==0x3f3f3f3f,说明n号可以无限远。其余的则dist[n]为答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int k=1,head[maxn],dist[maxn],vis[maxn],n,m1,m2,used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    dist[1]=0;vis[1]=1;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m1,&amp;m2);    for(int i=1;i&lt;=m1;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        if(b&gt;a)swap(a,b);        add(b,a,c);    }    for(int i=1;i&lt;=m2;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        if(b&gt;a)swap(a,b);        add(a,b,-c);    }    int x=spfa();    if(x==1)printf(&quot;-1\n&quot;);    else     {        if(dist[n]==0x3f3f3f3f)printf(&quot;-2\n&quot;);        else printf(&quot;%d\n&quot;,dist[n]);    }    return 0;}</code></pre>        <div id="aplayer-kKciIzgf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-kKciIzgf"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>差分约束</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4370</title>
    <link href="/2020/02/07/HDU-4370/"/>
    <url>/2020/02/07/HDU-4370/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4370 0 or 1</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4370#author=cjyl" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4370#author=cjyl</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出一个n×n的矩阵，求一个符合题意的n×n的只含有0和1的矩阵，使得两个矩阵位置对应的元素相乘后和最小。</p><p>题意要求01矩阵：</p><ol><li><p>X12+X13+…+X1n=1</p><p>2.X14+X24+…+X(n-1)n=1</p><p>3.∑Xki (1&lt;=k&lt;=n)=∑Xij (1&lt;=j&lt;=n).（1&lt;i&lt;n）</p></li></ol><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>对于条件1，可以说明1结点一定有且仅有一个出度，并且不是指向自己。<br>对于条件2，可以说明n结点一定有且仅有一个入度，并且该入度的发出者不是自己。<br>对于条件3，可以说明每个2-n-1的每一个结点的出度等于入度。<br>而题目要求求ΣCij * X ij最小值，即求最短路。<br>但是要分2种情况：<br>原因：结点1一定会指向结点i(i∈[2,n])，然后结点i一定指向别的结点，注意结点i不可以直接指向它自己，因为这样出度就不等于入读。最终会指向结点n，或者指向结点1形成自环。对于结点n来讲也是一样。</p><p>情况1：结点1最终指向结点n，则dist[n]就是最小值</p><p>情况2：结点1形成自环，那么结点n也必须形成自环。则dist[1]+dist[n]为答案。<br>针对情况2需要跑两次spfa，第一次spfa以1为起点，第二次spfa以n为起点。</p><p>最终答案为min(ans,d1+d2)其中ans=dist[n],d1=dist[1]，d2=dist[n]（这是第二次跑的spfa的结果）</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=30000+5;int n,c[305][305],head[maxn],vis[maxn],dist[maxn];struct node{    int to,next,w;}edge[maxn*2];void spfa(int s){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=n;i++)    {        if(i==s)        continue;        else         {            dist[i]=c[s][i];            q.push(i);            vis[i]=1;        }    }    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=1;i&lt;=n;i++)        {            if(dist[i]&gt;dist[x]+c[x][i])            {                dist[i]=dist[x]+c[x][i];                if(!vis[i])                {                    vis[i]=1;                    q.push(i);                }            }        }    }}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;c[i][j]);            }        }        spfa(1);        int ans=dist[n];        int d1=dist[1];        spfa(n);        int d2=dist[n];        printf(&quot;%d\n&quot;,min(ans,d1+d2));            }}</code></pre>        <div id="aplayer-ueeieqfy" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ueeieqfy"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA-10480</title>
    <link href="/2020/02/07/UVA-10480/"/>
    <url>/2020/02/07/UVA-10480/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>UVA - 10480 Sabotage</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/UVA-10480" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-10480</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个点，m条无向边，权值为wi。问从1到2，要割断的最小代价。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>1—&gt;2要进行割断并且要消耗最小，显然这是最小割问题。建边的时候要注意是双向边，起点s=1，终点t=2，跑dinic，最小割=最大流。<br>然后从s开始dfs，要edge[i].w&gt;0才开始继续，即s可到达的为一个集合，其余则为t可到达的。然后对于所有正向边，看是否u为s集合，v为t集合，<br>如果是就输出。<br>一开始想着这题和HDU - 4289 Control差不多，以为要拆点，结果就WA了。HDU - 4289 Control这道题由于是点权，将点转换成边，<br>所以需要拆点连边，而这道题说明了m条边的边权，所以不必拆点！<br>为什么割边的判断条件不是edge[i].w==0呢？原因是可能流量流过该边，并且最后该边edge[i].w==0但是实际上并没有割去这条边，<br>只是由于前面的流量影响了这条边！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int N=200+5;int k=1,head[maxn],deep[maxn],s,t,ans,n,m,vis[maxn];struct node{    int to,next,w,u;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].u=u;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}void DFS(int x){    if(vis[x])return ;    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(edge[i].w)        {            DFS(edge[i].to);            }    }}int main(){    while(1)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(vis,0,sizeof(vis));        ans=0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,0);            add(b,a,c);add(a,b,0);        }                s=1;t=2;        dinic();        DFS(s);        for(int i=2;i&lt;=k;i+=2)        {            if(vis[edge[i].u]==1&amp;&amp;vis[edge[i].to]==0)            {                int u=edge[i].u;int v=edge[i].to;                printf(&quot;%d %d\n&quot;,u,v);            }        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>        <div id="aplayer-htCbzIXQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-htCbzIXQ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3436</title>
    <link href="/2020/02/07/POJ-3436/"/>
    <url>/2020/02/07/POJ-3436/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3436 ACM Computer Factory</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3436#author=yupengju" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3436#author=yupengju</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有p种零件，n个工厂加工，第i个工厂一小时可以加工Qi个电脑，对于每一个工厂第一个数字表示一小时加工数量Qi，<br>然后有p个数字，若为0则表示不能有这个零件，1则表示必须有这个零件，2表示有没有都无所谓。最后p个数字，表示加工后电脑零件的存在情况，<br>只有p个零件都为1才表示电脑加工完成。问一小时最多生产多少电脑？生产线有几条？如何设计？（special judge）（1 ≤ P ≤ 10, 1 ≤ N ≤ 50, 1 ≤ Qi ≤ 10000）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>如果一开始直接想以零件为个体来建图就相当复杂，感觉无从下手，于是就从略大一点的个体出发，从工厂出发，s为起点，t为终点，如果一开始工厂要求的零件都没有，即p个数字都是0或者2，则s—&gt;i，边权为工厂容量或者无穷大。由于工厂自身一小时生产力有限，因此要对工厂进行拆点，i—&gt;i+N，边权为工厂容量。如果一个工厂生产后电脑的零件情况与另一个工厂生产前对零件的要求情况一致，则可以连边，i+N—&gt;j，边权为无穷大。如果工厂生产后电脑的零件情况均为1，则可以连边，i+N—&gt;t,边权为无穷大或者工厂容量。<br>这样跑dinic就可以求得最大流，但是还要输出生产线的情况。如何记录呢？在建边的时候记录一下工厂最开始的容量，和边的起点。<br>跑完dinic之后，对所有的偶数边（偶数边才是正向边）判断容量是否减少了，并且起点∈[1+N,n+N],终点∈[1,N],然后储存起点，终点，流量。<br>最后依次输出即可</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10000+5;const int N=52;int head[maxn],deep[maxn],k=1,s,t,p,n,ans,u[maxn],v[maxn],w[maxn];struct node{    int to,next,w,from,tot;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].from=u;edge[k].tot=w;}struct N{    int w,r[12],c[12];}a[maxn];bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;p,&amp;n)!=EOF)    {        k=1;s=0;t=4*N;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(u,0,sizeof(u));        memset(v,0,sizeof(v));        memset(w,0,sizeof(w));        memset(a,0,sizeof(a));        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i].w);            for(int j=1;j&lt;=p;j++)            {                scanf(&quot;%d&quot;,&amp;a[i].r[j]);            }            for(int j=1;j&lt;=p;j++)            {                scanf(&quot;%d&quot;,&amp;a[i].c[j]);            }        }        for(int i=1;i&lt;=n;i++)        {            int sign=0;            for(int k=1;k&lt;=p;k++)            {                if(a[i].r[k]==1)                {                    sign=1;                    break;                }            }            if(sign==0)            {                add(s,i,a[i].w);add(i,s,0);            }            add(i,i+N,a[i].w);add(i+N,i,0);            for(int j=1;j&lt;=n;j++)            {                sign=0;                if(i==j)continue;                for(int k=1;k&lt;=p;k++)                {                    if(a[i].c[k]!=a[j].r[k]&amp;&amp;a[j].r[k]!=2)                    {                        sign=1;                        break;                    }                }                if(sign==0)                {                    add(i+N,j,0x3f3f3f3f);add(j,i+N,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            int sign=0;            for(int k=1;k&lt;=p;k++)            {                if(a[i].c[k]!=1)                {                    sign=1;                    break;                }            }            if(sign==0)            {                add(i+N,t,a[i].w);add(t,i+N,0);            }        }        dinic();        int tot=0;        for(int i=2;i&lt;=k;i+=2)        {            if(edge[i].from&gt;=1+N&amp;&amp;edge[i].from&lt;=n+N&amp;&amp;edge[i].to&gt;=1&amp;&amp;edge[i].to&lt;=n&amp;&amp;edge[i].w&lt;edge[i].tot)            {                u[++tot]=edge[i].from-N;                v[tot]=edge[i].to;                w[tot]=edge[i].tot-edge[i].w;            }        }        printf(&quot;%d %d\n&quot;,ans,tot);        for(int i=1;i&lt;=tot;i++)        {            printf(&quot;%d %d %d\n&quot;,u[i],v[i],w[i]);        }    }    return 0;}</code></pre>        <div id="aplayer-pvQnZdUc" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-pvQnZdUc"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3281</title>
    <link href="/2020/02/07/POJ-3281/"/>
    <url>/2020/02/07/POJ-3281/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3281 Dining or  P2891 [USACO07OPEN]吃饭Dining</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3281" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3281</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有F种食物和D种饮料，每种食物或饮料只能供一头牛享用，且每头牛只享用一种食物和一种饮料。<br>现在有n头牛，每头牛都有自己喜欢的食物种类列表和饮料种类列表，问最多能使几头牛同时享用到自己喜欢的食物和饮料。（1 &lt;= f &lt;= 100, 1 &lt;= d &lt;= 100, 1 &lt;= n &lt;= 100）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>我一开始想到的办法稍微有点复杂。首先着很明显是最大流问题，难点就只有建图，<br>最开始我想到的建图是一个超级源点，指向牛，然后牛指向食物，由于食物只有一次使用机会，所以食物—&gt;食物’（流量为1）表示的是，<br>该食物的数量为1，然后食物’指向牛’，牛’指向饮料，饮料—&gt;饮料’（流量为1），然后饮料’指向超级汇点。但是这种方法有问题。<br>至于问题，我现在没找到，之后再想想。</p><p>ps:后面想通了，由于牛—&gt;食物，食物—&gt;食物’，食物’—&gt;牛’；这样单次经过的牛可能不是同一头牛，会导致错乱，当然答案不对。</p><p>正确做法：显然上面的建图有点复杂了，对于牛来讲，它必须满足食物和饮料均有，所以将牛放在中间，超级源点指向牛，而每种牛只有一条，<br>所以牛—&gt;牛’（容量为1），牛’—&gt;饮料，饮料指向超级源点，跑网络流dinic就可以了</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=300000+5;const int N=101;int n,k=1,head[maxn],vis[maxn],deep[maxn],f,d,s,t,ans;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}int dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }    return ans;}int main(){//    freopen(&quot;P2891_3.in&quot;,&quot;r&quot;,stdin);    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d);    s=0;t=10*N;    for(int i=1;i&lt;=f;i++)    {        add(s,i,1);add(i,s,0);    }    for(int i=1;i&lt;=d;i++)    {        add(i+3*N,t,1);add(t,i+3*N,0);    }    for(int i=1;i&lt;=n;i++)    {        int fi,di;        scanf(&quot;%d%d&quot;,&amp;fi,&amp;di);        for(int j=1;j&lt;=fi;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(x,i+N,1);add(i+N,x,0);        }        add(i+N,i+2*N,1);add(i+2*N,i+N,0);        for(int j=1;j&lt;=di;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+2*N,x+3*N,1);add(x+3*N,i+2*N,0);        }    }    /*for(int i=1;i&lt;=n;i++)    {        add(s,i,1);add(i,s,0);    }    for(int i=1;i&lt;=n;i++)    {        int fi,di;        scanf(&quot;%d%d&quot;,&amp;fi,&amp;di);        for(int j=1;j&lt;=fi;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i,x+N,1);add(x+N,i,0);            add(x+2*N,i+3*N,1);add(i+3*N,x+2*N,0);        }        for(int j=1;j&lt;=di;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+3*N,x+4*N,1);add(x+4*N,i+3*N,0);            add(x+5*N,i+6*N,1);add(i+6*N,x+5*N,0);        }    }    for(int i=1;i&lt;=f;i++)    {        add(i+N,i+2*N,1);add(i+2*N,i+N,0);    }    for(int i=1;i&lt;=d;i++)    {        add(i+4*N,i+5*N,1);add(i+5*N,i+4*N,0);    }    for(int i=1;i&lt;=n;i++)    {        add(i+6*N,t,1);add(t,i+6*N,0);    }*/    dinic();    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>        <div id="aplayer-BmAAQCyR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-BmAAQCyR"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2516</title>
    <link href="/2020/02/07/POJ-2516/"/>
    <url>/2020/02/07/POJ-2516/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2516 Minimum Cost</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2516" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2516</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有 n 个商店，k种物品和 m 个供货商，让你求进满足商店需求的货物的最小花费？<br>有必要说一下输入数据。<br>首先n ，k ，m。<br>然后是一个n<em>m的矩阵，n个商店对每种货物的需求，表示第 i 个商店需要第 j 种货物 x个?<br>然后是m </em> k 的矩阵，m个供货商可以供k种货物的数量，表示第 i 个供货商 提供第 j 中货物 x 个<br>接下来是 k 个 n * m 的矩阵，表示第 i 个货物，由 k 供应商发货给 j 商店的价格x<br>（注意如果供不应求的或输出-1）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始将商店分成很多，对于商品1有1-n商店，对于商品2有n+1-2<em>n商店，对于商品k有n</em>（k-1）-n<em>k商店。<br>对于供货商也是同理，s为起点，与商店连接，边权为商店对该物品的需求，费用为0，t为终点，供货商与t连接，边权为供货商能提供的量，费用为0，然后有后面k个矩阵可以建图，商店与供货商连接，注意要一一对应，因为商店和供货商相当于拆了点了，边权为无穷大，费用为价格。<br>但是最后跑费用流就凉了，TLE！！！难受！<br>然后看了一下题解，题解的办法是对于每次的商品来跑费用流，就不需要对商店和供货商进行拆点，跑k次费用流。<br>如果maxflow==需求，就输出mincost，否则就输出-1<br>TLE原因：SPFA费用流算法在稠密图上运行比较慢。可以将一个稠密大图拆成多个小图，虽然小图依然是稠密图，但是减少的幅度是非常大的。<br>从2500</em>2500到50*50.这样，只需建K次图，跑K遍SPFA费用流即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N=3000+5;const int maxn=40000+5;int k=1,sign,ans,n,m,q,s,t,head[maxn],dist[maxn],vis[maxn],flow[maxn],pre[maxn],last[maxn],maxflow,mincost,rd[52][52],cd[52][52];struct node{    int to,next,w,dis;}edge[maxn*2];void add(int u,int v,int w,int dis){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].dis=dis;}bool spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(flow,0x3f3f3f3f,sizeof(flow));    memset(vis,0,sizeof(vis));    memset(pre,0,sizeof(pre));    memset(last,0,sizeof(last));    vis[s]=1;dist[s]=0;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].dis&amp;&amp;edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].dis;                pre[edge[i].to]=x;                last[edge[i].to]=i;                flow[edge[i].to]=min(flow[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return pre[t];}void MCMF(){    while(spfa())    {        maxflow+=flow[t];        mincost+=flow[t]*dist[t];        int now=t;        while(now!=s)        {            edge[last[now]].w-=flow[t];            edge[last[now]^1].w+=flow[t];            now=pre[now];        }    }}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q)!=EOF)    {        s=0;t=N*5;        k=1;ans=0;sign=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        maxflow=0;mincost=0;        if(n==0&amp;&amp;m==0&amp;&amp;q==0)break;        int tot=0;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=q;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                tot+=x;                rd[i][j]=x;            }        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=q;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                cd[i][j]=x;            }        }        for(int i=1;i&lt;=q;i++)        {            k=1;            memset(head,0,sizeof(head));            memset(edge,0,sizeof(edge));            maxflow=0;mincost=0;            for(int j=1;j&lt;=n;j++)            {                add(s,j,rd[j][i],0);add(j,s,0,0);            }            for(int j=1;j&lt;=m;j++)            {                add(j+N,t,cd[j][i],0);add(t,j+N,0,0);            }            for(int j=1;j&lt;=n;j++)            {                for(int p=1;p&lt;=m;p++)                {                    int x;scanf(&quot;%d&quot;,&amp;x);                    add(j,p+N,0x3f3f3f3f,x);add(p+N,j,0,-x);                }            }            MCMF();            ans+=mincost;            sign+=maxflow;        }        if(sign==tot)        printf(&quot;%d\n&quot;,ans);        else         printf(&quot;-1\n&quot;);    }    return 0;}</code></pre>        <div id="aplayer-DznjOXSp" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DznjOXSp"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2195</title>
    <link href="/2020/02/07/POJ-2195/"/>
    <url>/2020/02/07/POJ-2195/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2195 Going Home</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2195#author=hrbustacm" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2195#author=hrbustacm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>免费送房子，m表示人，H表示房子，每个房子只能进一个人，房子数等于人数。<br>黄弘毅为了方便起见决定要让所有人到自己的房子的距离和最小，请问这个距离和是多少？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>距离和，这个问题一看显然就是费用流问题，而此题就是最小费用流的裸题，将人和房子统计出来，然后s与人连边，边权为1，费用dis为0，房子与t连边，边权为0，费用dis为0，人与房子连边，边权为1，费用dis为曼哈顿距离。然后跑MCMF就可以了。</p><p>ps：我麻烦了一点，对房子进行了拆点，其实可以不拆，毕竟与t相连，流量固定了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int n,m,k=1,s,t,head[maxn],flow[maxn],dist[maxn],x1[maxn],x2[maxn],y1[maxn],y2[maxn];int vis[maxn],maxflow,mincost,pre[maxn],last[maxn];struct node{    int to,next,w,dis;}edge[maxn*2];void add(int u,int v,int w,int dis){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].dis=dis;}bool spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(flow,0x3f3f3f3f,sizeof(flow));    memset(vis,0,sizeof(vis));    memset(pre,0,sizeof(pre));    memset(last,0,sizeof(last));    vis[s]=1;dist[s]=0;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].dis&amp;&amp;edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].dis;                pre[edge[i].to]=x;                last[edge[i].to]=i;                flow[edge[i].to]=min(flow[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return pre[t];}void MCMF(){    while(spfa())    {        maxflow+=flow[t];        mincost+=flow[t]*dist[t];        int now=t;        while(now!=s)        {            edge[last[now]].w-=flow[t];            edge[last[now]^1].w+=flow[t];            now=pre[now];        }    }}int main(){    while(1)    {        s=0,t=4*N;        int tot1=0,tot2=0;        maxflow=0;mincost=0;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(x1,0,sizeof(x1));        memset(x2,0,sizeof(x2));        memset(y1,0,sizeof(y1));        memset(y2,0,sizeof(y2));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=0;j&lt;x.length();j++)            {                if(x[j]==&#39;m&#39;)                {                    tot1++;x1[tot1]=j+1;y1[tot1]=i;                }                else if(x[j]==&#39;H&#39;)                {                    tot2++;x2[tot2]=j+1;y2[tot2]=i;                }            }        }        for(int i=1;i&lt;=tot1;i++)        {            add(s,i,1,0);add(i,s,0,0);            for(int j=1;j&lt;=tot2;j++)            {                int w=abs(x1[i]-x2[j])+abs(y1[i]-y2[j]);                add(i,j+N,1,w);add(j+N,i,0,-w);            }        }        for(int i=1;i&lt;=tot2;i++)        {            add(i+N,t,1,0);add(t,i+N,0,0);        }        MCMF();        printf(&quot;%d\n&quot;,mincost);    }    return 0;}</code></pre>        <div id="aplayer-ORQnwjWX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ORQnwjWX"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1459</title>
    <link href="/2020/02/07/POJ-1459/"/>
    <url>/2020/02/07/POJ-1459/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1459 Power Network</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1459#author=alexandleo" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1459#author=alexandleo</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>每组测试数据给出N，Np，Nc，M。N代表结点数量，M代表边的数量，Np代表结点中电站的数量（只产电，不耗电），<br>Nc代表消费者数量（只耗电，不产电），其他结点代表中转站（不产电，不耗电）。<br>接着M组（u，v）w数据，代表u到v容量为w，接着Np组（u）w，代表结点u产电w，接着Nc组（u）w，代表结点u耗电w。<br>求电网中能消耗的最大电能值。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>求最大电能，显然这是最大流问题，s与所有的电站连接，边权为产电量，t与所有的消费者连接，边权为耗电量，然后根据m条边的信息，<br>如果u，v属于电站，则值不变，如果不是电站，那么需要+N，成为另一个集合，再建边，边权为容量w，然后跑网络流dinic。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=205;int k=1,s,t,head[maxn],deep[maxn],n,m,np,nc,ans,vis[maxn],u[maxn],v[maxn],w[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;np,&amp;nc,&amp;m)!=EOF)    {        ans=0;        k=1;        memset(head,0,sizeof(head));        memset(vis,0,sizeof(vis));        t=N*5;s=t+1;        for(int i=1;i&lt;=m;i++)        {            char x,y,z;            int a,b,c;            cin&gt;&gt;x&gt;&gt;a&gt;&gt;y&gt;&gt;b&gt;&gt;z&gt;&gt;c;            u[i]=a;v[i]=b;w[i]=c;        }        for(int i=1;i&lt;=np;i++)        {            int b,c;char x,y;            cin&gt;&gt;x&gt;&gt;b&gt;&gt;y&gt;&gt;c;            add(s,b,c);add(b,s,0);            vis[b]=1;        }        for(int i=1;i&lt;=m;i++)        {            if(!vis[u[i]])u[i]+=N;            if(!vis[v[i]])v[i]+=N;            add(u[i],v[i],w[i]);add(v[i],u[i],0);        }        for(int i=1;i&lt;=nc;i++)        {            int b,c;char x,y;            cin&gt;&gt;x&gt;&gt;b&gt;&gt;y&gt;&gt;c;            add(b+N,t,c);add(t,b+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-YwVWyPdQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-YwVWyPdQ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1087</title>
    <link href="/2020/02/07/POJ-1087/"/>
    <url>/2020/02/07/POJ-1087/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1087 A Plug for UNIX</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1087#author=cjyl" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1087#author=cjyl</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>宾馆里有几种插座，分别有其对应型号，你携带了几种用电器（手机，电脑一类的），也有其对应型号；<br>可是不一定用电器就能和插座匹配上，于是宾馆的商店里提供了一些转换器，这些转换器可以将某一型号电源转换成另一型号的。<br>问，你的用电器最少会有多少种无法充电 。注意插座型号是字符串形式，长度小于24，用电器名称也是字符串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是最大流问题。先说一下细节，插座和用电器的数量肯定都只有一个，但是转换器的数量是无限的。<br>建图：设起点为s，终点为t，首先s与所有的用电器相连，边权为1，（一开始还想着拆点，我怕是个哈批啊，对于两边的点，边权就是容量，<br>不需要去拆点！），t与所有的插座相连。如果型号相同，就可以二者之间进行连边。然后对于转换器，转换器之间可以相连，并且转换可以实现A—&gt;B，<br>也可以实现B—&gt;A。所以，对于用电器型号=A||B的都可以连边，对于插座型号=A||B的都可以连边，边权为1，对于转换器之间可以相连的，直接连接，<br>由于容量无穷大，因此不必拆点！</p><p>代码：</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;const int maxn=300000+5;const int N=200+5;int s,t,n,k=1,m,q,ans,head[maxn],deep[maxn];char r[maxn][25],mr[maxn][25],mc[maxn][25];struct node{    int to,next,w;}edge[maxn*2];struct N{    char s[40];char r[25];}a[maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        s=0;t=4*N;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,r[i]);        }        scanf(&quot;%d&quot;,&amp;q);        for(int i=1;i&lt;=q;i++)        {            add(s,i,1);add(i,s,0);            char x;            scanf(&quot;%s%s&quot;,a[i].s,a[i].r);        }        for(int i=1;i&lt;=q;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(strcmp(a[i].r,r[j])==0)                {                    add(i,j+N,1);add(j+N,i,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            add(i+N,t,1);add(t,i+N,0);        }        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%s%s&quot;,mr[i],mc[i]);            for(int j=1;j&lt;=q;j++)            {                if(strcmp(a[j].r,mr[i])==0||strcmp(a[j].r,mc[i])==0)                {                    add(j,i+2*N,1);add(i+2*N,j,0);                }            }            for(int j=1;j&lt;=n;j++)            {                if(strcmp(r[j],mc[i])==0||strcmp(r[j],mr[i])==0)                {                    add(i+2*N,j+N,1);add(j+N,i+2*N,0);                }            }        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=m;j++)            {                if(i!=j&amp;&amp;strcmp(mc[i],mr[j])==0)                {                    add(i+2*N,j+2*N,0x3f3f3f3f);add(j+2*N,i+2*N,0);                }            }            for(int j=1;j&lt;=m;j++)            {                if(i!=j&amp;&amp;strcmp(mr[i],mc[j])==0)                {                    add(i+2*N,j+2*N,0x3f3f3f3f);add(j+2*N,i+2*N,0);                }            }        }        dinic();        printf(&quot;%d\n&quot;,q-ans);    }    return 0;}</code></pre>        <div id="aplayer-cAsLfbPL" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-cAsLfbPL"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4292</title>
    <link href="/2020/02/07/HDU-4292/"/>
    <url>/2020/02/07/HDU-4292/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4292 Food</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4292#author=yupengju" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4292#author=yupengju</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>昊妈决定只给每个人一种食物和一种饮料，而且每种饮料和食物都只能提供有限次。现在给出每个人喜欢的食物种类和饮料种类，<br>昊妈可以最多让多少人得到满足呢？第一行给出N F D表示人数，食物种类数，饮料种类数第二行给出F个数字表示第i种食物有几个第三行给出D个数字<br>表示第i种饮料有几个接下来N行分别给出第i个人对第j种食物的喜爱情况，Y是喜欢N是不喜欢，再来N行对饮料的</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题是最大流问题，重点自然就是建图，一个人要满足，必须同时拥有食物和饮料。而一个人也最多可以满足一次，<br>而且饮料和食物的容量也是有限的。最简单的自然是食物连向起点，边权为食物的容量；饮料连向中点，边权为饮料的容量；如果某人i喜欢食物j，<br>那么二者就要连边，即j—&gt;i+N，边权为1，并且人位于中间必须拆点，即i+N—&gt;i+2<em>N,边权为1。如果某人i喜欢饮料j，那么i+2</em>N—&gt;j+3*N，边权为1<br>建好后跑dinic。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int k=1,n,f,d,deep[maxn],head[maxn],ans,s,t;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(edge[i].w&amp;&amp;!deep[edge[i].to])            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d)!=EOF)    {        k=1;s=0;t=5*N;ans=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=f;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(s,i,x);add(i,s,0);        }        for(int i=1;i&lt;=d;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+3*N,t,x);add(t,i+3*N,0);        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=1;j&lt;=f;j++)            {                if(x[j-1]==&#39;Y&#39;)                {                    add(j,i+N,1);add(i+N,j,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=1;j&lt;=d;j++)            {                if(x[j-1]==&#39;Y&#39;)                {                    add(i+2*N,j+3*N,1);add(j+3*N,i+2*N,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            add(i+N,i+2*N,1);add(i+2*N,i+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-QqTfLtZN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-QqTfLtZN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4289</title>
    <link href="/2020/02/07/HDU-4289/"/>
    <url>/2020/02/07/HDU-4289/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4289 Control</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4289" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4289</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个无向图，有些不法分子要从S点T点，现在要抓住所有的不法分子阻止他们去T，那么就要控制某一些城市等待他们，<br>控制每个城市花费不同，问最少花费是多少。第一行是两个整数N，M（2&lt;=N&lt;=200，1&lt;=M&lt;=20000）,分别表示城市数量和道路数量，<br>城市的编号为1到N。 第二行是两个整数S，T（1&lt;=S,T&lt;=N）,分别表示起点和终点的位置。 接下来以下N行，分别表示控制第每一个城市的成本costi<br>（cost&lt;10^7）。 接下来M行，每行有两个整数A，B表示城市A和B之间存在一条双向道路。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>根据题意，要设法将S，T分割开，求最小花费，显然是求图的最小割，即求最大流。一开始想着单独将S，T隔开，<br>无向边u，v建边：u+N—&gt;v,边权0x3f3f3f3f，v+N-&gt;u，边权0x3f3f3f3f，当然回路也要建立。然后跑dinic，然后将跑出来的最大流和单独隔离s、单独隔离t三者取最小。但是这样跑出来不对。</p><p>错误原因就是：这是双向图，s可以作为起点，也可以作为中间点。</p><p>正确做法是：无向边u，v建边：u+N—&gt;v,边权0x3f3f3f3f，v+N-&gt;u，边权0x3f3f3f3f，当然回路也要建立，然后u—&gt;u+N,边权为cost。<br>然后从s—&gt;t+N，跑dinic，求最大流。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=50000+5;const int N=200+5;int k=1,n,m,s,t,ans,head[maxn],deep[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F-f));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        k=1;ans=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);t+=N;        for(int i=1;i&lt;=n;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i,i+N,x);add(i+N,i,0);        }        for(int i=1;i&lt;=m;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a+N,b,0x3f3f3f3f);add(b,a+N,0);            add(b+N,a,0x3f3f3f3f);add(a,b+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-lXTdpdkN" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-lXTdpdkN"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4280</title>
    <link href="/2020/02/07/HDU-4280/"/>
    <url>/2020/02/07/HDU-4280/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4280 Island Transport</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4280#author=smilestruggler" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4280#author=smilestruggler</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在n个岛屿中，有m条双向航线，航线有单位时间内的运输上限，现在求从最左侧到最右侧的最大运输</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题意含明显它是最大流的模板题，直接建边，然后找到起点s和终点t就可以了，然后直接跑dinic。但是n=100000，m=100000，数据规模大，<br>dinic容易超时，但是我们可以做优化。</p><p>优化1：bfs只要跑到t就返回1，开始dfs。</p><p>优化2；dfs内每次min(F-f,edge[i].w），f表示之前已经流过的流量，F-f表示剩余可流的流量，一旦F==f就break，表示满流了！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int T,n,m,s,t,head[maxn],deep[maxn],k=1,ans;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        ans=0;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        int minn=0x3f3f3f3f,maxx=-0x3f3f3f3f;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            if(minn&gt;x)            {                minn=x;                s=i;            }            if(maxx&lt;x)            {                maxx=x;                t=i;            }        }        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);            add(b,a,c);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>        <div id="aplayer-CGpkyCcM" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CGpkyCcM"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3605</title>
    <link href="/2020/02/07/HDU-3605/"/>
    <url>/2020/02/07/HDU-3605/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3605 Escape</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3605" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3605</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个人，m个星球，前n行，每一行有m个数字，分别表示第i个星球是否适合这个人。最后一行有m个，表示每个星球的最多居住人数。n (1 &lt;= n &lt;= 100000), m (1 &lt;= m &lt;= 10)</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始想多没想就开始建裸图，心里想：别看着图稠密，边多，实际上一跑就出结果了。事实证明自己太天真，n<em>n</em>m的数据量早就TLE！<br>正确做法有点意思：由于m很小，就可以考虑状态压缩。对于第i个人，m个星球的居住情况已知，转换为二进制储存，所有的状态也不过才2^10而已，<br>起点s连向状态，边权为这种状态的总人数，然后10个星球与这种状态匹配，若星球属于这个状态，则状态连向星球，边权为无穷大，<br>然后星球与终点t连接，边权为星球的最大居住人数。然后就可以跑dinic了，若ans==n，就YES，否则就NO。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=5000;int k=1,head[maxn],deep[maxn],n,m,s,t,ans,now[1&lt;&lt;11];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        s=0,t=2*N;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(now,0,sizeof(now));        ans=0;        for(int i=1;i&lt;=n;i++)        {            int state=0;            for(int j=1;j&lt;=m;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                if(x==1)                {                    state=state|(1&lt;&lt;(j-1));                }            }            now[state]++;        }        for(int i=0;i&lt;=(1&lt;&lt;m)-1;i++)        {            if(now[i])            {                add(s,i,now[i]);add(i,s,0);                for(int j=1;j&lt;=m;j++)                {                    if((i&amp;(1&lt;&lt;(j-1)))&gt;0)                    {                        add(i,N+j,0x3f3f3f3f);add(N+j,i,0);                    }                }            }        }        for(int i=1;i&lt;=m;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(N+i,t,x);add(t,N+i,0);        }        dinic();        if(n==ans)        {            printf(&quot;YES\n&quot;);        }        else         {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>        <div id="aplayer-LgkdvWxm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-LgkdvWxm"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3081</title>
    <link href="/2020/02/07/HDU-3081/"/>
    <url>/2020/02/07/HDU-3081/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3081 Marriage Match II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3081" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3081</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有N个女孩要与N个男孩玩配对游戏.每个女孩有一个可选男孩的集合(即该女孩可以选自己集合中的任意一个男孩作为该轮的搭档).<br>然后从第一轮开始,每个女孩都要和一个不同的男孩配对.如果第一轮N个女孩都配对成功,那么就开始第二轮配对,女孩依然从自己的备选男孩集合中选择,<br>但是不能选那些已经被该女孩在前几轮选择中选过的男孩了(比如i女孩在第一轮选了j男孩,那么i在第二轮就不能选j男孩了). 问你游戏最多能进行多少轮?</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>女生:1~n;男生:(n+1)~(n*2)。对于女生u，她可以直接连向不讨厌的男生，边权为1。</p><p>假设我们当前二分尝试的轮数为K(即能够进行K轮匹配):首先如果女孩i可能选择男孩j,那么就有边(i, j+n, 1).且源点到每个女孩i有边(s,i,K),<br>每个男孩j到汇点t有边(j+n,t,K).</p><p>如果最大流==K*n,那么就表示可以进行最少K轮匹配.</p><p>证明：如果满流,那么每个女生肯定选择了K个不同的男孩,每个男孩肯定被K个不同的女孩选择了(因为一个女孩到一个男孩边容量只为1,所以该女孩最多只能选该男孩一次).<br> 那么上面这样就能保证这个游戏可以进行K轮吗?可以的,假设当前图的流量为0,说明任何女孩都没选男孩. 你可以想象假如此时从S到所有女孩有流量1<br>(虽然容量是K,但是目前我们只放出1流量)流出,那么这些流量肯定会汇集到t(因为最大流为K<em>n,而我们此时只不过n流量).<br>这个汇集的过程就是第一轮女孩选择了各自不同男孩的结果. 现在从S到所有女孩又有流量1流出(即第二轮开始了),<br>这些流量肯定又经过了n个男孩汇集到t点了 且 如果上一轮i女孩的流量走到j男孩,这一轮i女孩的流量肯定不走j男孩了(因为i女孩到j男孩的边只有1容量).<br>综上所述,只要最大流==K</em>n,那么就能进行K轮.</p><p>即如果女孩{1,2,3,4,5,6,7,8,9}是朋友的话,且2号女孩能选择男孩3,我们如果标记来使得其他所有女孩都能选择男孩3呢?<br>我选择的是闭包传递，当然也可以用并查集。<br>ps：不要把男孩也算进,比如女孩1与男孩2能选,女孩3与男孩2能选,但是女孩1与女孩3可不是朋友,她们不属于同一个并查集。<br>一开始这里就出了问题。如果我们dist[a][b+N]=1,而dist[b+N][a]不管，就不存在问题了！</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int k=1,head[maxn],deep[maxn],s,t,n,m,ans,T,f,dist[N][N];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}bool solve(int mid){        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        ans=0;        for(int i=1;i&lt;=n;i++)        {            add(s,i,mid);add(i,s,0);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=n+1;j&lt;=2*n;j++)            {                if(dist[i][j]==0x3f3f3f3f)continue;                add(i,j,1);add(j,i,0);            }        }        for(int i=1+n;i&lt;=n*2;i++)        {            add(i,t,mid);add(t,i,0);        }        dinic();        if(ans==mid*n)return 1;        return 0;}int main(){    //1-ngirl,(n+1)-(2*n)boy    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        ans=0;        s=0,t=8*N;        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;f);        memset(dist,0x3f3f3f3f,sizeof(dist));        for(int i=1;i&lt;=m;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b+n]=1;        }        for(int i=1;i&lt;=f;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b]=dist[b][a]=1;        }        for(int K=1;K&lt;=2*n;K++)        {            for(int i=1;i&lt;=2*n;i++)            {                for(int j=1;j&lt;=2*n;j++)                {                    if(dist[i][K]==1&amp;&amp;dist[K][j]==1)                    {                        dist[i][j]=1;                    }                }            }        }        int l=0,r=n,ANS=0;        while(l&lt;=r)        {            int mid=(l+r)/2;            if(solve(mid))            {                ANS=mid;                l=mid+1;            }            else r=mid-1;        }        printf(&quot;%d\n&quot;,ANS);    }    return 0;}</code></pre>        <div id="aplayer-KuAYFfvT" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KuAYFfvT"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>二分</tag>
      
      <tag>闭包传递</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2732</title>
    <link href="/2020/02/07/HDU-2732/"/>
    <url>/2020/02/07/HDU-2732/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h3><p>HDU - 2732 Leapin’ Lizards</p><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://vjudge.net/problem/HDU-2732" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2732</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>题目是说一个n*m的迷宫中，有每个格子有柱子。柱子高度为0~3，高度为0的柱子是不能站的（高度为0就是没有柱子）<br>在一些有柱子的格子上有一些蜥蜴，一次最多跳距离d,相邻格子的距离是1，只要跳出迷宫就是安全的。这个距离是曼哈顿距离（好像是的）<br>。蜥蜴一次最多跳距离d,但是起跳的地方的柱子高度会减一，一个柱子同一时间只能有一个蜥蜴要求最少几个不能逃出迷宫。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最大流问题，求出dinic跑出的最大流，然后总数-ans就是剩余的数。建图方法：</p><p>1.每个柱子有容纳量，超过了就塌了。u—&gt;u’ 边权为容纳量</p><p>2.有蜥蜴的柱子与起点s相连，即s—&gt;u,边权为1</p><p>3.边界上可以跳出界的与终点相连，条件(x1&lt;=p||y1&lt;=p||n-x1+1&lt;=p||len-y1+1&lt;=p)&amp;&amp;h[x1][y1]，u’—&gt;t,边权0x3f3f3f3f</p><p>4.任意两个有容纳量的柱子，且曼哈顿距离&lt;=d，可以相连，即u’—&gt;v,v’-&gt;u，边权为0x3f3f3f3f.</p><p>ps：1.注意输出时候单复数！<br>2.注意是j+(i-1)*len(len 表示一行的列数！！！）一开始写成了n，WA了一片。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int N=500+5;int k=1,head[maxn],deep[maxn],s,t,n,m,T,ans,p,h[30][N*10];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=0;    while(T--)    {        opt++;        k=1;ans=0;s=0;t=5*N;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(h,0,sizeof(h));        scanf(&quot;%d%d&quot;,&amp;n,&amp;p);        int len=0;int tot=0;        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;len=x.length();            for(int j=1;j&lt;=len;j++)            {                int w=x[j-1]-&#39;0&#39;;h[i][j]=w;                if(w)                {                    add(j+(i-1)*len,j+(i-1)*len+N,w);add(j+(i-1)*len+N,j+(i-1)*len,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;len=x.length();            for(int j=1;j&lt;=len;j++)            {                if(x[j-1]==&#39;L&#39;)                {                    tot++;                    add(s,j+(i-1)*len,1);add(j+(i-1)*len,s,0);                }            }        }        for(int x1=1;x1&lt;=n;x1++)        {            for(int y1=1;y1&lt;=len;y1++)            {                for(int x2=1;x2&lt;=n;x2++)                {                    for(int y2=1;y2&lt;=len;y2++)                    {                        if(x1==x2&amp;&amp;y1==y2)continue;                        if(abs(x1-x2)+abs(y1-y2)&gt;p)continue;                        if(!h[x1][y1]||!h[x2][y2])continue;                        add(y1+(x1-1)*len+N,y2+(x2-1)*len,0x3f3f3f3f);add(y2+(x2-1)*len,y1+(x1-1)*len+N,0);                        add(y2+(x2-1)*len+N,y1+(x1-1)*len,0x3f3f3f3f);add(y1+(x1-1)*len,y2+(x2-1)*len+N,0);                    }                }            }        }        for(int x1=1;x1&lt;=n;x1++)        {            for(int y1=1;y1&lt;=len;y1++)            {                if((x1&lt;=p||y1&lt;=p||n-x1+1&lt;=p||len-y1+1&lt;=p)&amp;&amp;h[x1][y1])                {                    add(y1+(x1-1)*len+N,t,0x3f3f3f3f);add(t,y1+(x1-1)*len+N,0);                }            }        }        dinic();        printf(&quot;Case #%d: &quot;,opt);        if(ans==tot)        {            printf(&quot;no lizard was left behind.\n&quot;);            continue;        }        else if(tot-ans==1)        {            printf(&quot;1 lizard was left behind.\n&quot;);        }        else         {            printf(&quot;%d lizards were left behind.\n&quot;,tot-ans);        }    }    return 0;}</code></pre>        <div id="aplayer-IjwQupIJ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-IjwQupIJ"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那年",              author: "枯木逢春",              url: "https://cdn.jsdelivr.net/gh/Phoenix-ZH/CDN/1.mp3",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
