<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UVA-10480</title>
    <link href="/2020/02/07/UVA-10480/"/>
    <url>/2020/02/07/UVA-10480/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>UVA - 10480 Sabotage</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/UVA-10480" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-10480</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个点，m条无向边，权值为wi。问从1到2，要割断的最小代价。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>1–&gt;2要进行割断并且要消耗最小，显然这是最小割问题。建边的时候要注意是双向边，起点s=1，终点t=2，跑dinic，最小割=最大流。<br>然后从s开始dfs，要edge[i].w&gt;0才开始继续，即s可到达的为一个集合，其余则为t可到达的。然后对于所有正向边，看是否u为s集合，v为t集合，<br>如果是就输出。<br>一开始想着这题和HDU - 4289 Control差不多，以为要拆点，结果就WA了。HDU - 4289 Control这道题由于是点权，将点转换成边，<br>所以需要拆点连边，而这道题说明了m条边的边权，所以不必拆点！<br>为什么割边的判断条件不是edge[i].w==0呢？原因是可能流量流过该边，并且最后该边edge[i].w==0但是实际上并没有割去这条边，<br>只是由于前面的流量影响了这条边！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int N=200+5;int k=1,head[maxn],deep[maxn],s,t,ans,n,m,vis[maxn];struct node{    int to,next,w,u;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].u=u;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}void DFS(int x){    if(vis[x])return ;    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(edge[i].w)        {            DFS(edge[i].to);            }    }}int main(){    while(1)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(vis,0,sizeof(vis));        ans=0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,0);            add(b,a,c);add(a,b,0);        }                s=1;t=2;        dinic();        DFS(s);        for(int i=2;i&lt;=k;i+=2)        {            if(vis[edge[i].u]==1&amp;&amp;vis[edge[i].to]==0)            {                int u=edge[i].u;int v=edge[i].to;                printf(&quot;%d %d\n&quot;,u,v);            }        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3436</title>
    <link href="/2020/02/07/POJ-3436/"/>
    <url>/2020/02/07/POJ-3436/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3436 ACM Computer Factory</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3436#author=yupengju" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3436#author=yupengju</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有p种零件，n个工厂加工，第i个工厂一小时可以加工Qi个电脑，对于每一个工厂第一个数字表示一小时加工数量Qi，<br>然后有p个数字，若为0则表示不能有这个零件，1则表示必须有这个零件，2表示有没有都无所谓。最后p个数字，表示加工后电脑零件的存在情况，<br>只有p个零件都为1才表示电脑加工完成。问一小时最多生产多少电脑？生产线有几条？如何设计？（special judge）（1 ≤ P ≤ 10, 1 ≤ N ≤ 50, 1 ≤ Qi ≤ 10000）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>如果一开始直接想以零件为个体来建图就相当复杂，感觉无从下手，于是就从略大一点的个体出发，从工厂出发，s为起点，t为终点，如果一开始工厂要求的零件都没有，即p个数字都是0或者2，则s–&gt;i，边权为工厂容量或者无穷大。由于工厂自身一小时生产力有限，因此要对工厂进行拆点，i–&gt;i+N，边权为工厂容量。如果一个工厂生产后电脑的零件情况与另一个工厂生产前对零件的要求情况一致，则可以连边，i+N–&gt;j，边权为无穷大。如果工厂生产后电脑的零件情况均为1，则可以连边，i+N–&gt;t,边权为无穷大或者工厂容量。<br>这样跑dinic就可以求得最大流，但是还要输出生产线的情况。如何记录呢？在建边的时候记录一下工厂最开始的容量，和边的起点。<br>跑完dinic之后，对所有的偶数边（偶数边才是正向边）判断容量是否减少了，并且起点∈[1+N,n+N],终点∈[1,N],然后储存起点，终点，流量。<br>最后依次输出即可</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10000+5;const int N=52;int head[maxn],deep[maxn],k=1,s,t,p,n,ans,u[maxn],v[maxn],w[maxn];struct node{    int to,next,w,from,tot;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].from=u;edge[k].tot=w;}struct N{    int w,r[12],c[12];}a[maxn];bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;p,&amp;n)!=EOF)    {        k=1;s=0;t=4*N;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(u,0,sizeof(u));        memset(v,0,sizeof(v));        memset(w,0,sizeof(w));        memset(a,0,sizeof(a));        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i].w);            for(int j=1;j&lt;=p;j++)            {                scanf(&quot;%d&quot;,&amp;a[i].r[j]);            }            for(int j=1;j&lt;=p;j++)            {                scanf(&quot;%d&quot;,&amp;a[i].c[j]);            }        }        for(int i=1;i&lt;=n;i++)        {            int sign=0;            for(int k=1;k&lt;=p;k++)            {                if(a[i].r[k]==1)                {                    sign=1;                    break;                }            }            if(sign==0)            {                add(s,i,a[i].w);add(i,s,0);            }            add(i,i+N,a[i].w);add(i+N,i,0);            for(int j=1;j&lt;=n;j++)            {                sign=0;                if(i==j)continue;                for(int k=1;k&lt;=p;k++)                {                    if(a[i].c[k]!=a[j].r[k]&amp;&amp;a[j].r[k]!=2)                    {                        sign=1;                        break;                    }                }                if(sign==0)                {                    add(i+N,j,0x3f3f3f3f);add(j,i+N,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            int sign=0;            for(int k=1;k&lt;=p;k++)            {                if(a[i].c[k]!=1)                {                    sign=1;                    break;                }            }            if(sign==0)            {                add(i+N,t,a[i].w);add(t,i+N,0);            }        }        dinic();        int tot=0;        for(int i=2;i&lt;=k;i+=2)        {            if(edge[i].from&gt;=1+N&amp;&amp;edge[i].from&lt;=n+N&amp;&amp;edge[i].to&gt;=1&amp;&amp;edge[i].to&lt;=n&amp;&amp;edge[i].w&lt;edge[i].tot)            {                u[++tot]=edge[i].from-N;                v[tot]=edge[i].to;                w[tot]=edge[i].tot-edge[i].w;            }        }        printf(&quot;%d %d\n&quot;,ans,tot);        for(int i=1;i&lt;=tot;i++)        {            printf(&quot;%d %d %d\n&quot;,u[i],v[i],w[i]);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3281</title>
    <link href="/2020/02/07/POJ-3281/"/>
    <url>/2020/02/07/POJ-3281/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3281 Dining or  P2891 [USACO07OPEN]吃饭Dining</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3281" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3281</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有F种食物和D种饮料，每种食物或饮料只能供一头牛享用，且每头牛只享用一种食物和一种饮料。<br>现在有n头牛，每头牛都有自己喜欢的食物种类列表和饮料种类列表，问最多能使几头牛同时享用到自己喜欢的食物和饮料。（1 &lt;= f &lt;= 100, 1 &lt;= d &lt;= 100, 1 &lt;= n &lt;= 100）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>我一开始想到的办法稍微有点复杂。首先着很明显是最大流问题，难点就只有建图，<br>最开始我想到的建图是一个超级源点，指向牛，然后牛指向食物，由于食物只有一次使用机会，所以食物–&gt;食物’（流量为1）表示的是，<br>该食物的数量为1，然后食物’指向牛’，牛’指向饮料，饮料–&gt;饮料’（流量为1），然后饮料’指向超级汇点。但是这种方法有问题。<br>至于问题，我现在没找到，之后再想想。</p><p>ps:后面想通了，由于牛–&gt;食物，食物–&gt;食物’，食物’–&gt;牛’；这样单次经过的牛可能不是同一头牛，会导致错乱，当然答案不对。</p><p>正确做法：显然上面的建图有点复杂了，对于牛来讲，它必须满足食物和饮料均有，所以将牛放在中间，超级源点指向牛，而每种牛只有一条，<br>所以牛–&gt;牛’（容量为1），牛’–&gt;饮料，饮料指向超级源点，跑网络流dinic就可以了</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=300000+5;const int N=101;int n,k=1,head[maxn],vis[maxn],deep[maxn],f,d,s,t,ans;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}int dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }    return ans;}int main(){//    freopen(&quot;P2891_3.in&quot;,&quot;r&quot;,stdin);    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d);    s=0;t=10*N;    for(int i=1;i&lt;=f;i++)    {        add(s,i,1);add(i,s,0);    }    for(int i=1;i&lt;=d;i++)    {        add(i+3*N,t,1);add(t,i+3*N,0);    }    for(int i=1;i&lt;=n;i++)    {        int fi,di;        scanf(&quot;%d%d&quot;,&amp;fi,&amp;di);        for(int j=1;j&lt;=fi;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(x,i+N,1);add(i+N,x,0);        }        add(i+N,i+2*N,1);add(i+2*N,i+N,0);        for(int j=1;j&lt;=di;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+2*N,x+3*N,1);add(x+3*N,i+2*N,0);        }    }    /*for(int i=1;i&lt;=n;i++)    {        add(s,i,1);add(i,s,0);    }    for(int i=1;i&lt;=n;i++)    {        int fi,di;        scanf(&quot;%d%d&quot;,&amp;fi,&amp;di);        for(int j=1;j&lt;=fi;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i,x+N,1);add(x+N,i,0);            add(x+2*N,i+3*N,1);add(i+3*N,x+2*N,0);        }        for(int j=1;j&lt;=di;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+3*N,x+4*N,1);add(x+4*N,i+3*N,0);            add(x+5*N,i+6*N,1);add(i+6*N,x+5*N,0);        }    }    for(int i=1;i&lt;=f;i++)    {        add(i+N,i+2*N,1);add(i+2*N,i+N,0);    }    for(int i=1;i&lt;=d;i++)    {        add(i+4*N,i+5*N,1);add(i+5*N,i+4*N,0);    }    for(int i=1;i&lt;=n;i++)    {        add(i+6*N,t,1);add(t,i+6*N,0);    }*/    dinic();    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2516</title>
    <link href="/2020/02/07/POJ-2516/"/>
    <url>/2020/02/07/POJ-2516/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2516 Minimum Cost</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2516" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2516</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有 n 个商店，k种物品和 m 个供货商，让你求进满足商店需求的货物的最小花费？<br>有必要说一下输入数据。<br>首先n ，k ，m。<br>然后是一个n*m的矩阵，n个商店对每种货物的需求，表示第 i 个商店需要第 j 种货物 x个?<br>然后是m * k 的矩阵，m个供货商可以供k种货物的数量，表示第 i 个供货商 提供第 j 中货物 x 个<br>接下来是 k 个 n * m 的矩阵，表示第 i 个货物，由 k 供应商发货给 j 商店的价格x<br>（注意如果供不应求的或输出-1）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始将商店分成很多，对于商品1有1-n商店，对于商品2有n+1-2<em>n商店，对于商品k有n</em>（k-1）-n<em>k商店。<br>对于供货商也是同理，s为起点，与商店连接，边权为商店对该物品的需求，费用为0，t为终点，供货商与t连接，边权为供货商能提供的量，费用为0，然后有后面k个矩阵可以建图，商店与供货商连接，注意要一一对应，因为商店和供货商相当于拆了点了，边权为无穷大，费用为价格。<br>但是最后跑费用流就凉了，TLE！！！难受！<br>然后看了一下题解，题解的办法是对于每次的商品来跑费用流，就不需要对商店和供货商进行拆点，跑k次费用流。<br>如果maxflow==需求，就输出mincost，否则就输出-1<br>TLE原因：SPFA费用流算法在稠密图上运行比较慢。可以将一个稠密大图拆成多个小图，虽然小图依然是稠密图，但是减少的幅度是非常大的。<br>从2500</em>2500到50*50.这样，只需建K次图，跑K遍SPFA费用流即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N=3000+5;const int maxn=40000+5;int k=1,sign,ans,n,m,q,s,t,head[maxn],dist[maxn],vis[maxn],flow[maxn],pre[maxn],last[maxn],maxflow,mincost,rd[52][52],cd[52][52];struct node{    int to,next,w,dis;}edge[maxn*2];void add(int u,int v,int w,int dis){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].dis=dis;}bool spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(flow,0x3f3f3f3f,sizeof(flow));    memset(vis,0,sizeof(vis));    memset(pre,0,sizeof(pre));    memset(last,0,sizeof(last));    vis[s]=1;dist[s]=0;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].dis&amp;&amp;edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].dis;                pre[edge[i].to]=x;                last[edge[i].to]=i;                flow[edge[i].to]=min(flow[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return pre[t];}void MCMF(){    while(spfa())    {        maxflow+=flow[t];        mincost+=flow[t]*dist[t];        int now=t;        while(now!=s)        {            edge[last[now]].w-=flow[t];            edge[last[now]^1].w+=flow[t];            now=pre[now];        }    }}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q)!=EOF)    {        s=0;t=N*5;        k=1;ans=0;sign=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        maxflow=0;mincost=0;        if(n==0&amp;&amp;m==0&amp;&amp;q==0)break;        int tot=0;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=q;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                tot+=x;                rd[i][j]=x;            }        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=q;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                cd[i][j]=x;            }        }        for(int i=1;i&lt;=q;i++)        {            k=1;            memset(head,0,sizeof(head));            memset(edge,0,sizeof(edge));            maxflow=0;mincost=0;            for(int j=1;j&lt;=n;j++)            {                add(s,j,rd[j][i],0);add(j,s,0,0);            }            for(int j=1;j&lt;=m;j++)            {                add(j+N,t,cd[j][i],0);add(t,j+N,0,0);            }            for(int j=1;j&lt;=n;j++)            {                for(int p=1;p&lt;=m;p++)                {                    int x;scanf(&quot;%d&quot;,&amp;x);                    add(j,p+N,0x3f3f3f3f,x);add(p+N,j,0,-x);                }            }            MCMF();            ans+=mincost;            sign+=maxflow;        }        if(sign==tot)        printf(&quot;%d\n&quot;,ans);        else         printf(&quot;-1\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2195</title>
    <link href="/2020/02/07/POJ-2195/"/>
    <url>/2020/02/07/POJ-2195/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2195 Going Home</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2195#author=hrbustacm" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2195#author=hrbustacm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>免费送房子，m表示人，H表示房子，每个房子只能进一个人，房子数等于人数。<br>黄弘毅为了方便起见决定要让所有人到自己的房子的距离和最小，请问这个距离和是多少？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>距离和，这个问题一看显然就是费用流问题，而此题就是最小费用流的裸题，将人和房子统计出来，然后s与人连边，边权为1，费用dis为0，房子与t连边，边权为0，费用dis为0，人与房子连边，边权为1，费用dis为曼哈顿距离。然后跑MCMF就可以了。</p><p>ps：我麻烦了一点，对房子进行了拆点，其实可以不拆，毕竟与t相连，流量固定了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int n,m,k=1,s,t,head[maxn],flow[maxn],dist[maxn],x1[maxn],x2[maxn],y1[maxn],y2[maxn];int vis[maxn],maxflow,mincost,pre[maxn],last[maxn];struct node{    int to,next,w,dis;}edge[maxn*2];void add(int u,int v,int w,int dis){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].dis=dis;}bool spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(flow,0x3f3f3f3f,sizeof(flow));    memset(vis,0,sizeof(vis));    memset(pre,0,sizeof(pre));    memset(last,0,sizeof(last));    vis[s]=1;dist[s]=0;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].dis&amp;&amp;edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].dis;                pre[edge[i].to]=x;                last[edge[i].to]=i;                flow[edge[i].to]=min(flow[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return pre[t];}void MCMF(){    while(spfa())    {        maxflow+=flow[t];        mincost+=flow[t]*dist[t];        int now=t;        while(now!=s)        {            edge[last[now]].w-=flow[t];            edge[last[now]^1].w+=flow[t];            now=pre[now];        }    }}int main(){    while(1)    {        s=0,t=4*N;        int tot1=0,tot2=0;        maxflow=0;mincost=0;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(x1,0,sizeof(x1));        memset(x2,0,sizeof(x2));        memset(y1,0,sizeof(y1));        memset(y2,0,sizeof(y2));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=0;j&lt;x.length();j++)            {                if(x[j]==&#39;m&#39;)                {                    tot1++;x1[tot1]=j+1;y1[tot1]=i;                }                else if(x[j]==&#39;H&#39;)                {                    tot2++;x2[tot2]=j+1;y2[tot2]=i;                }            }        }        for(int i=1;i&lt;=tot1;i++)        {            add(s,i,1,0);add(i,s,0,0);            for(int j=1;j&lt;=tot2;j++)            {                int w=abs(x1[i]-x2[j])+abs(y1[i]-y2[j]);                add(i,j+N,1,w);add(j+N,i,0,-w);            }        }        for(int i=1;i&lt;=tot2;i++)        {            add(i+N,t,1,0);add(t,i+N,0,0);        }        MCMF();        printf(&quot;%d\n&quot;,mincost);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1459</title>
    <link href="/2020/02/07/POJ-1459/"/>
    <url>/2020/02/07/POJ-1459/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1459 Power Network</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1459#author=alexandleo" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1459#author=alexandleo</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>每组测试数据给出N，Np，Nc，M。N代表结点数量，M代表边的数量，Np代表结点中电站的数量（只产电，不耗电），<br>Nc代表消费者数量（只耗电，不产电），其他结点代表中转站（不产电，不耗电）。<br>接着M组（u，v）w数据，代表u到v容量为w，接着Np组（u）w，代表结点u产电w，接着Nc组（u）w，代表结点u耗电w。<br>求电网中能消耗的最大电能值。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>求最大电能，显然这是最大流问题，s与所有的电站连接，边权为产电量，t与所有的消费者连接，边权为耗电量，然后根据m条边的信息，<br>如果u，v属于电站，则值不变，如果不是电站，那么需要+N，成为另一个集合，再建边，边权为容量w，然后跑网络流dinic。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=205;int k=1,s,t,head[maxn],deep[maxn],n,m,np,nc,ans,vis[maxn],u[maxn],v[maxn],w[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;np,&amp;nc,&amp;m)!=EOF)    {        ans=0;        k=1;        memset(head,0,sizeof(head));        memset(vis,0,sizeof(vis));        t=N*5;s=t+1;        for(int i=1;i&lt;=m;i++)        {            char x,y,z;            int a,b,c;            cin&gt;&gt;x&gt;&gt;a&gt;&gt;y&gt;&gt;b&gt;&gt;z&gt;&gt;c;            u[i]=a;v[i]=b;w[i]=c;        }        for(int i=1;i&lt;=np;i++)        {            int b,c;char x,y;            cin&gt;&gt;x&gt;&gt;b&gt;&gt;y&gt;&gt;c;            add(s,b,c);add(b,s,0);            vis[b]=1;        }        for(int i=1;i&lt;=m;i++)        {            if(!vis[u[i]])u[i]+=N;            if(!vis[v[i]])v[i]+=N;            add(u[i],v[i],w[i]);add(v[i],u[i],0);        }        for(int i=1;i&lt;=nc;i++)        {            int b,c;char x,y;            cin&gt;&gt;x&gt;&gt;b&gt;&gt;y&gt;&gt;c;            add(b+N,t,c);add(t,b+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1087</title>
    <link href="/2020/02/07/POJ-1087/"/>
    <url>/2020/02/07/POJ-1087/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1087 A Plug for UNIX</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1087#author=cjyl" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1087#author=cjyl</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>宾馆里有几种插座，分别有其对应型号，你携带了几种用电器（手机，电脑一类的），也有其对应型号；<br>可是不一定用电器就能和插座匹配上，于是宾馆的商店里提供了一些转换器，这些转换器可以将某一型号电源转换成另一型号的。<br>问，你的用电器最少会有多少种无法充电 。注意插座型号是字符串形式，长度小于24，用电器名称也是字符串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是最大流问题。先说一下细节，插座和用电器的数量肯定都只有一个，但是转换器的数量是无限的。<br>建图：设起点为s，终点为t，首先s与所有的用电器相连，边权为1，（一开始还想着拆点，我怕是个哈批啊，对于两边的点，边权就是容量，<br>不需要去拆点！），t与所有的插座相连。如果型号相同，就可以二者之间进行连边。然后对于转换器，转换器之间可以相连，并且转换可以实现A–&gt;B，<br>也可以实现B–&gt;A。所以，对于用电器型号=A||B的都可以连边，对于插座型号=A||B的都可以连边，边权为1，对于转换器之间可以相连的，直接连接，<br>由于容量无穷大，因此不必拆点！</p><p>代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;const int maxn=300000+5;const int N=200+5;int s,t,n,k=1,m,q,ans,head[maxn],deep[maxn];char r[maxn][25],mr[maxn][25],mc[maxn][25];struct node{    int to,next,w;}edge[maxn*2];struct N{    char s[40];char r[25];}a[maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        s=0;t=4*N;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,r[i]);        }        scanf(&quot;%d&quot;,&amp;q);        for(int i=1;i&lt;=q;i++)        {            add(s,i,1);add(i,s,0);            char x;            scanf(&quot;%s%s&quot;,a[i].s,a[i].r);        }        for(int i=1;i&lt;=q;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(strcmp(a[i].r,r[j])==0)                {                    add(i,j+N,1);add(j+N,i,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            add(i+N,t,1);add(t,i+N,0);        }        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%s%s&quot;,mr[i],mc[i]);            for(int j=1;j&lt;=q;j++)            {                if(strcmp(a[j].r,mr[i])==0||strcmp(a[j].r,mc[i])==0)                {                    add(j,i+2*N,1);add(i+2*N,j,0);                }            }            for(int j=1;j&lt;=n;j++)            {                if(strcmp(r[j],mc[i])==0||strcmp(r[j],mr[i])==0)                {                    add(i+2*N,j+N,1);add(j+N,i+2*N,0);                }            }        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=m;j++)            {                if(i!=j&amp;&amp;strcmp(mc[i],mr[j])==0)                {                    add(i+2*N,j+2*N,0x3f3f3f3f);add(j+2*N,i+2*N,0);                }            }            for(int j=1;j&lt;=m;j++)            {                if(i!=j&amp;&amp;strcmp(mr[i],mc[j])==0)                {                    add(i+2*N,j+2*N,0x3f3f3f3f);add(j+2*N,i+2*N,0);                }            }        }        dinic();        printf(&quot;%d\n&quot;,q-ans);    }    return 0;}    </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4292</title>
    <link href="/2020/02/07/HDU-4292/"/>
    <url>/2020/02/07/HDU-4292/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4292 Food</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4292#author=yupengju" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4292#author=yupengju</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>昊妈决定只给每个人一种食物和一种饮料，而且每种饮料和食物都只能提供有限次。现在给出每个人喜欢的食物种类和饮料种类，<br>昊妈可以最多让多少人得到满足呢？第一行给出N F D表示人数，食物种类数，饮料种类数第二行给出F个数字表示第i种食物有几个第三行给出D个数字<br>表示第i种饮料有几个接下来N行分别给出第i个人对第j种食物的喜爱情况，Y是喜欢N是不喜欢，再来N行对饮料的</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题是最大流问题，重点自然就是建图，一个人要满足，必须同时拥有食物和饮料。而一个人也最多可以满足一次，<br>而且饮料和食物的容量也是有限的。最简单的自然是食物连向起点，边权为食物的容量；饮料连向中点，边权为饮料的容量；如果某人i喜欢食物j，<br>那么二者就要连边，即j–&gt;i+N，边权为1，并且人位于中间必须拆点，即i+N–&gt;i+2<em>N,边权为1。如果某人i喜欢饮料j，那么i+2</em>N–&gt;j+3*N，边权为1<br>建好后跑dinic。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int k=1,n,f,d,deep[maxn],head[maxn],ans,s,t;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(edge[i].w&amp;&amp;!deep[edge[i].to])            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d)!=EOF)    {        k=1;s=0;t=5*N;ans=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=f;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(s,i,x);add(i,s,0);        }        for(int i=1;i&lt;=d;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+3*N,t,x);add(t,i+3*N,0);        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=1;j&lt;=f;j++)            {                if(x[j-1]==&#39;Y&#39;)                {                    add(j,i+N,1);add(i+N,j,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=1;j&lt;=d;j++)            {                if(x[j-1]==&#39;Y&#39;)                {                    add(i+2*N,j+3*N,1);add(j+3*N,i+2*N,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            add(i+N,i+2*N,1);add(i+2*N,i+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4289</title>
    <link href="/2020/02/07/HDU-4289/"/>
    <url>/2020/02/07/HDU-4289/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4289 Control</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4289" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4289</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个无向图，有些不法分子要从S点T点，现在要抓住所有的不法分子阻止他们去T，那么就要控制某一些城市等待他们，<br>控制每个城市花费不同，问最少花费是多少。第一行是两个整数N，M（2&lt;=N&lt;=200，1&lt;=M&lt;=20000）,分别表示城市数量和道路数量，<br>城市的编号为1到N。 第二行是两个整数S，T（1&lt;=S,T&lt;=N）,分别表示起点和终点的位置。 接下来以下N行，分别表示控制第每一个城市的成本costi<br>（cost&lt;10^7）。 接下来M行，每行有两个整数A，B表示城市A和B之间存在一条双向道路。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>根据题意，要设法将S，T分割开，求最小花费，显然是求图的最小割，即求最大流。一开始想着单独将S，T隔开，<br>无向边u，v建边：u+N–&gt;v,边权0x3f3f3f3f，v+N-&gt;u，边权0x3f3f3f3f，当然回路也要建立。然后跑dinic，然后将跑出来的最大流和单独隔离s、单独隔离t三者取最小。但是这样跑出来不对。</p><p>错误原因就是：这是双向图，s可以作为起点，也可以作为中间点。</p><p>正确做法是：无向边u，v建边：u+N–&gt;v,边权0x3f3f3f3f，v+N-&gt;u，边权0x3f3f3f3f，当然回路也要建立，然后u–&gt;u+N,边权为cost。<br>然后从s–&gt;t+N，跑dinic，求最大流。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=50000+5;const int N=200+5;int k=1,n,m,s,t,ans,head[maxn],deep[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F-f));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        k=1;ans=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);t+=N;        for(int i=1;i&lt;=n;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i,i+N,x);add(i+N,i,0);        }        for(int i=1;i&lt;=m;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a+N,b,0x3f3f3f3f);add(b,a+N,0);            add(b+N,a,0x3f3f3f3f);add(a,b+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4280</title>
    <link href="/2020/02/07/HDU-4280/"/>
    <url>/2020/02/07/HDU-4280/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4280 Island Transport</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4280#author=smilestruggler" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4280#author=smilestruggler</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在n个岛屿中，有m条双向航线，航线有单位时间内的运输上限，现在求从最左侧到最右侧的最大运输</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题意含明显它是最大流的模板题，直接建边，然后找到起点s和终点t就可以了，然后直接跑dinic。但是n=100000，m=100000，数据规模大，<br>dinic容易超时，但是我们可以做优化。</p><p>优化1：bfs只要跑到t就返回1，开始dfs。</p><p>优化2；dfs内每次min(F-f,edge[i].w），f表示之前已经流过的流量，F-f表示剩余可流的流量，一旦F==f就break，表示满流了！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int T,n,m,s,t,head[maxn],deep[maxn],k=1,ans;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        ans=0;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        int minn=0x3f3f3f3f,maxx=-0x3f3f3f3f;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            if(minn&gt;x)            {                minn=x;                s=i;            }            if(maxx&lt;x)            {                maxx=x;                t=i;            }        }        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);            add(b,a,c);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3605</title>
    <link href="/2020/02/07/HDU-3605/"/>
    <url>/2020/02/07/HDU-3605/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3605 Escape</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3605" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3605</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个人，m个星球，前n行，每一行有m个数字，分别表示第i个星球是否适合这个人。最后一行有m个，表示每个星球的最多居住人数。n (1 &lt;= n &lt;= 100000), m (1 &lt;= m &lt;= 10)</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始想多没想就开始建裸图，心里想：别看着图稠密，边多，实际上一跑就出结果了。事实证明自己太天真，n<em>n</em>m的数据量早就TLE！<br>正确做法有点意思：由于m很小，就可以考虑状态压缩。对于第i个人，m个星球的居住情况已知，转换为二进制储存，所有的状态也不过才2^10而已，<br>起点s连向状态，边权为这种状态的总人数，然后10个星球与这种状态匹配，若星球属于这个状态，则状态连向星球，边权为无穷大，<br>然后星球与终点t连接，边权为星球的最大居住人数。然后就可以跑dinic了，若ans==n，就YES，否则就NO。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=5000;int k=1,head[maxn],deep[maxn],n,m,s,t,ans,now[1&lt;&lt;11];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        s=0,t=2*N;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(now,0,sizeof(now));        ans=0;        for(int i=1;i&lt;=n;i++)        {            int state=0;            for(int j=1;j&lt;=m;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                if(x==1)                {                    state=state|(1&lt;&lt;(j-1));                }            }            now[state]++;        }        for(int i=0;i&lt;=(1&lt;&lt;m)-1;i++)        {            if(now[i])            {                add(s,i,now[i]);add(i,s,0);                for(int j=1;j&lt;=m;j++)                {                    if((i&amp;(1&lt;&lt;(j-1)))&gt;0)                    {                        add(i,N+j,0x3f3f3f3f);add(N+j,i,0);                    }                }            }        }        for(int i=1;i&lt;=m;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(N+i,t,x);add(t,N+i,0);        }        dinic();        if(n==ans)        {            printf(&quot;YES\n&quot;);        }        else         {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3081</title>
    <link href="/2020/02/07/HDU-3081/"/>
    <url>/2020/02/07/HDU-3081/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3081 Marriage Match II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3081" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3081</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有N个女孩要与N个男孩玩配对游戏.每个女孩有一个可选男孩的集合(即该女孩可以选自己集合中的任意一个男孩作为该轮的搭档).<br>然后从第一轮开始,每个女孩都要和一个不同的男孩配对.如果第一轮N个女孩都配对成功,那么就开始第二轮配对,女孩依然从自己的备选男孩集合中选择,<br>但是不能选那些已经被该女孩在前几轮选择中选过的男孩了(比如i女孩在第一轮选了j男孩,那么i在第二轮就不能选j男孩了). 问你游戏最多能进行多少轮?</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>女生:1<del>n;男生:(n+1)</del>(n*2)。对于女生u，她可以直接连向不讨厌的男生，边权为1。</p><p>假设我们当前二分尝试的轮数为K(即能够进行K轮匹配):首先如果女孩i可能选择男孩j,那么就有边(i, j+n, 1).且源点到每个女孩i有边(s,i,K),<br>每个男孩j到汇点t有边(j+n,t,K).</p><p>如果最大流==K*n,那么就表示可以进行最少K轮匹配.</p><p>证明：如果满流,那么每个女生肯定选择了K个不同的男孩,每个男孩肯定被K个不同的女孩选择了(因为一个女孩到一个男孩边容量只为1,所以该女孩最多只能选该男孩一次).<br> 那么上面这样就能保证这个游戏可以进行K轮吗?可以的,假设当前图的流量为0,说明任何女孩都没选男孩. 你可以想象假如此时从S到所有女孩有流量1<br>(虽然容量是K,但是目前我们只放出1流量)流出,那么这些流量肯定会汇集到t(因为最大流为K<em>n,而我们此时只不过n流量).<br>这个汇集的过程就是第一轮女孩选择了各自不同男孩的结果. 现在从S到所有女孩又有流量1流出(即第二轮开始了),<br>这些流量肯定又经过了n个男孩汇集到t点了 且 如果上一轮i女孩的流量走到j男孩,这一轮i女孩的流量肯定不走j男孩了(因为i女孩到j男孩的边只有1容量).<br>综上所述,只要最大流==K</em>n,那么就能进行K轮.</p><p>即如果女孩{1,2,3,4,5,6,7,8,9}是朋友的话,且2号女孩能选择男孩3,我们如果标记来使得其他所有女孩都能选择男孩3呢?<br>我选择的是闭包传递，当然也可以用并查集。<br>ps：不要把男孩也算进,比如女孩1与男孩2能选,女孩3与男孩2能选,但是女孩1与女孩3可不是朋友,她们不属于同一个并查集。<br>一开始这里就出了问题。如果我们dist[a][b+N]=1,而dist[b+N][a]不管，就不存在问题了！</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int k=1,head[maxn],deep[maxn],s,t,n,m,ans,T,f,dist[N][N];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}bool solve(int mid){        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        ans=0;        for(int i=1;i&lt;=n;i++)        {            add(s,i,mid);add(i,s,0);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=n+1;j&lt;=2*n;j++)            {                if(dist[i][j]==0x3f3f3f3f)continue;                add(i,j,1);add(j,i,0);            }        }        for(int i=1+n;i&lt;=n*2;i++)        {            add(i,t,mid);add(t,i,0);        }        dinic();        if(ans==mid*n)return 1;        return 0;}int main(){    //1-ngirl,(n+1)-(2*n)boy    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        ans=0;        s=0,t=8*N;        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;f);        memset(dist,0x3f3f3f3f,sizeof(dist));        for(int i=1;i&lt;=m;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b+n]=1;        }        for(int i=1;i&lt;=f;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b]=dist[b][a]=1;        }        for(int K=1;K&lt;=2*n;K++)        {            for(int i=1;i&lt;=2*n;i++)            {                for(int j=1;j&lt;=2*n;j++)                {                    if(dist[i][K]==1&amp;&amp;dist[K][j]==1)                    {                        dist[i][j]=1;                    }                }            }        }        int l=0,r=n,ANS=0;        while(l&lt;=r)        {            int mid=(l+r)/2;            if(solve(mid))            {                ANS=mid;                l=mid+1;            }            else r=mid-1;        }        printf(&quot;%d\n&quot;,ANS);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>二分</tag>
      
      <tag>闭包传递</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2732</title>
    <link href="/2020/02/07/HDU-2732/"/>
    <url>/2020/02/07/HDU-2732/</url>
    
    <content type="html"><![CDATA[<h3 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h3><p>HDU - 2732 Leapin’ Lizards</p><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://vjudge.net/problem/HDU-2732" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2732</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>题目是说一个n*m的迷宫中，有每个格子有柱子。柱子高度为0~3，高度为0的柱子是不能站的（高度为0就是没有柱子）<br>在一些有柱子的格子上有一些蜥蜴，一次最多跳距离d,相邻格子的距离是1，只要跳出迷宫就是安全的。这个距离是曼哈顿距离（好像是的）<br>。蜥蜴一次最多跳距离d,但是起跳的地方的柱子高度会减一，一个柱子同一时间只能有一个蜥蜴要求最少几个不能逃出迷宫。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最大流问题，求出dinic跑出的最大流，然后总数-ans就是剩余的数。建图方法：</p><p>1.每个柱子有容纳量，超过了就塌了。u–&gt;u’ 边权为容纳量</p><p>2.有蜥蜴的柱子与起点s相连，即s–&gt;u,边权为1</p><p>3.边界上可以跳出界的与终点相连，条件(x1&lt;=p||y1&lt;=p||n-x1+1&lt;=p||len-y1+1&lt;=p)&amp;&amp;h[x1][y1]，u’–&gt;t,边权0x3f3f3f3f</p><p>4.任意两个有容纳量的柱子，且曼哈顿距离&lt;=d，可以相连，即u’–&gt;v,v’-&gt;u，边权为0x3f3f3f3f.</p><p>ps：1.注意输出时候单复数！<br>2.注意是j+(i-1)*len(len 表示一行的列数！！！）一开始写成了n，WA了一片。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int N=500+5;int k=1,head[maxn],deep[maxn],s,t,n,m,T,ans,p,h[30][N*10];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=0;    while(T--)    {        opt++;        k=1;ans=0;s=0;t=5*N;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(h,0,sizeof(h));        scanf(&quot;%d%d&quot;,&amp;n,&amp;p);        int len=0;int tot=0;        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;len=x.length();            for(int j=1;j&lt;=len;j++)            {                int w=x[j-1]-&#39;0&#39;;h[i][j]=w;                if(w)                {                    add(j+(i-1)*len,j+(i-1)*len+N,w);add(j+(i-1)*len+N,j+(i-1)*len,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;len=x.length();            for(int j=1;j&lt;=len;j++)            {                if(x[j-1]==&#39;L&#39;)                {                    tot++;                    add(s,j+(i-1)*len,1);add(j+(i-1)*len,s,0);                }            }        }        for(int x1=1;x1&lt;=n;x1++)        {            for(int y1=1;y1&lt;=len;y1++)            {                for(int x2=1;x2&lt;=n;x2++)                {                    for(int y2=1;y2&lt;=len;y2++)                    {                        if(x1==x2&amp;&amp;y1==y2)continue;                        if(abs(x1-x2)+abs(y1-y2)&gt;p)continue;                        if(!h[x1][y1]||!h[x2][y2])continue;                        add(y1+(x1-1)*len+N,y2+(x2-1)*len,0x3f3f3f3f);add(y2+(x2-1)*len,y1+(x1-1)*len+N,0);                        add(y2+(x2-1)*len+N,y1+(x1-1)*len,0x3f3f3f3f);add(y1+(x1-1)*len,y2+(x2-1)*len+N,0);                    }                }            }        }        for(int x1=1;x1&lt;=n;x1++)        {            for(int y1=1;y1&lt;=len;y1++)            {                if((x1&lt;=p||y1&lt;=p||n-x1+1&lt;=p||len-y1+1&lt;=p)&amp;&amp;h[x1][y1])                {                    add(y1+(x1-1)*len+N,t,0x3f3f3f3f);add(t,y1+(x1-1)*len+N,0);                }            }        }        dinic();        printf(&quot;Case #%d: &quot;,opt);        if(ans==tot)        {            printf(&quot;no lizard was left behind.\n&quot;);            continue;        }        else if(tot-ans==1)        {            printf(&quot;1 lizard was left behind.\n&quot;);        }        else         {            printf(&quot;%d lizards were left behind.\n&quot;,tot-ans);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
