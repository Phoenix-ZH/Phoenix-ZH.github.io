<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HDU-1054</title>
    <link href="/2020/02/11/HDU-1054/"/>
    <url>/2020/02/11/HDU-1054/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1054 Strategic Game</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1054#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1054#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>Bob非常享受玩电脑游戏的过程，尤其是策略游戏，但是在有些时候，他因为不能在第一时间找到最佳的策略而十分伤心。 现在，他遇到了一个问题。他必须保卫一个中世纪的城市，有很多道路将整个城市连起来，整体上看上去像一棵树。Bob需要放置尽可能少的士兵，保卫树上所有的边。士兵只能放在节点上，但是却可以保卫所有与这个节点相邻的边。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题目要求很明确，就是要最少的点覆盖所有的边，即最小定点覆盖问题。 <strong>最小顶点覆盖要求用最少的点，让每条边都至少和其中一个点关联。即</strong>点集里面的点能覆盖所有的边 。</p><p><strong>knoig定理</strong>： <strong>二分图的最小顶点覆盖数=二分图的最大匹配数。</strong> </p><p><strong>证明</strong>：</p><p>要证明<strong>最小顶点覆盖数==最大匹配数</strong>，即证明<strong>最小顶点覆盖数&gt;=最大匹配数</strong>，并且<strong>最大匹配数&gt;=最小顶点覆盖数</strong>。设<strong>最小顶点覆盖数</strong>为S，<strong>最大匹配数</strong>为M。</p><p> <strong>①</strong> <strong>最小顶点覆盖数&gt;=最大匹配数</strong>：</p><p>假设最大匹配数为n，那么我们就得到了n条互不相邻的边，光覆盖这些边就至少需要n个顶点。由于最大匹配数为n，那么就可能存在一些边不在最大匹配的集合中，这样的话要覆盖这些边就还需要顶点，因此<strong>最小顶点覆盖数&gt;=最大匹配数</strong>。</p><p> <strong>②</strong> <strong>最大匹配数&gt;=最小顶点覆盖数</strong>：</p><p>假设匹配边a–&gt;b在最大匹配的集合中，如果a相连的边有未匹配点x，b相连的边有未匹配点y，那么x-a<strong>-</strong>b-y是一条增广路，而这就与M是<strong>最大匹配数</strong>矛盾了。所以a,b不可能同时相连为匹配点。</p><p>因此a，b中有非匹配边相连的点假设是a，那么选择a就可以覆盖a-b以及a-？(非匹配边)。并且M中没有孤立的非匹配边，每一条边一定会跟一个匹配点相连。这就意味着，每一个非匹配边的出发点一定同时连接了一条匹配边，这样非匹配边不可能单独存在。那么，从最大匹配边中选择M个点一定可以覆盖所有的边。所以<strong>最大匹配数&gt;=最小顶点覆盖数</strong>。</p><p>综上所述：<strong>最大匹配数==最小顶点覆盖数</strong>。</p><p>而此题就是要求最少的点将所有的边覆盖，就是<strong>最小点覆盖</strong>的模板题了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1500+5;int k=1,n,head[maxn],cy[maxn],vis[maxn];struct node{    int to,next;}edge[maxn*maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=n;i++)        {            int u,tot;            scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;tot);            for(int j=1;j&lt;=tot;j++)            {                int v;                scanf(&quot;%d&quot;,&amp;v);                add(u+1,v+1);add(v+1,u+1);            }        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        ans/=2;        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
      <tag>最小顶点覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3020</title>
    <link href="/2020/02/11/POJ-3020/"/>
    <url>/2020/02/11/POJ-3020/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ-3020  Antenna Placement </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3020" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3020</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，每一组数据是hxw的矩阵，矩阵中的每一个方格有o或者*组成,问用1x2的矩阵 (横着或竖着都可以)来覆盖所有的 * ，问至少需要多少个这样的矩阵？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题和HDU4185 Oil Skimming 很相似。观察之后发现，将所有的 * 先预处理出它的编号，然后对于 * 的上下左右若为 * 就可以建边，然后跑匈牙利算法，求出最大匹配，对于这样求出来的最大匹配ans应该要÷2，即ans/=2，因为我们建的双向边。ans * 2表示的是已经覆盖了的点，temp-ans * 2就是剩余的美誉覆盖的点，这些点只能单独覆盖了，所以最终答案是 temp-ans * 2+ans。</p><p><strong>ps</strong>：WA了几次，注意 * 的数量&lt;=40 * 10=400，边就是400 * 400 * 4，数组要够，不然就是TLE或者WA。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=400+5;const int maxm=400*400+5;int T,n,m,k=1,head[maxn],s[maxn][maxn],cy[maxn],vis[maxn];char a[maxn][maxn];struct node{    int to,next;}edge[maxm*4];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        int temp=0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,a[i]);            for(int j=0;j&lt;=m-1;j++)            {                if(a[i][j]==&#39;*&#39;)                {                    s[i][j]=++temp;                }            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=0;j&lt;=m-1;j++)            {                if(a[i][j]==&#39;*&#39;)                {                    if(j&lt;=m-2&amp;&amp;a[i][j+1]==&#39;*&#39;)                    {                        add(s[i][j],s[i][j+1]);                    }                    if(j&gt;=1&amp;&amp;a[i][j-1]==&#39;*&#39;)                    {                        add(s[i][j],s[i][j-1]);                    }                    if(i&lt;=n-1&amp;&amp;a[i+1][j]==&#39;*&#39;)                    {                        add(s[i][j],s[i+1][j]);                    }                    if(i&gt;=2&amp;&amp;a[i-1][j]==&#39;*&#39;)                    {                        add(s[i][j],s[i-1][j]);                    }                }            }        }        int ans=0;        for(int i=1;i&lt;=temp;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        ans/=2;        int yu=temp-ans*2;        printf(&quot;%d\n&quot;,ans+yu);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4185</title>
    <link href="/2020/02/11/HDU-4185/"/>
    <url>/2020/02/11/HDU-4185/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 4185  Oil Skimming </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4185" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4185</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有K组数据，每组数据是N*N的方阵，每个方格由.或者#组成，问有多少个互相不重叠的##(横着或竖着)。</p><p>  (1 &lt;= K &lt;= 100)  (1 &lt;= N &lt;= 600) </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最开始的思路是每个点只判断它下方或者右方是不是#，如果是就连边，但是这个方法存在一个问题：横着的##和竖着的##如果重叠会导致计数重复，又没有一个比较好的办法来规范。于是换了一个想法，一个点若为#就像它上下左右为#的点都连边，最后答案/2就可以避免重复。枚举所有的点，预处理#点的编号temp记录，然后开始跑匈牙利算法，最后ans/2.</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1200+5;const int maxm=360000+5;const int N=360000;int k=1,T,n,head[maxm],vis[maxm],cy[maxm],s[605][605];char a[605][605];struct node{    int to,next;}edge[maxm*4];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){     vis[x]=0;    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        scanf(&quot;%d&quot;,&amp;n);        opt++;        k=1;        memset(cy,0,sizeof(cy));        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(s,0,sizeof(s));        int temp=0;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,a[i]);            for(int j=0;j&lt;n;j++)            {                if(a[i][j]==&#39;#&#39;)                {                    s[i][j]=++temp;                }            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=0;j&lt;n;j++)            {                if(a[i][j]==&#39;#&#39;)                {                    if(j&lt;=n-2&amp;&amp;a[i][j+1]==&#39;#&#39;)                    {                        add(s[i][j],s[i][j+1]);                    }                    if(j&gt;=1&amp;&amp;a[i][j-1]==&#39;#&#39;)                    {                        add(s[i][j],s[i][j-1]);                    }                    if(i&lt;=n-1&amp;&amp;a[i+1][j]==&#39;#&#39;)                    {                        add(s[i][j],s[i+1][j]);                    }                    if(i&gt;=2&amp;&amp;a[i-1][j]==&#39;#&#39;)                    {                        add(s[i][j],s[i-1][j]);                    }                }            }        }        int ans=0;        for(int i=1;i&lt;=temp;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;Case %d: %d\n&quot;,opt,ans/2);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2389</title>
    <link href="/2020/02/10/HDU-2389/"/>
    <url>/2020/02/10/HDU-2389/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2389  Rain on your Parade </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2389" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2389</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有T组数据，每组数据第一行是t，表示到t时下雨，第二行是m，表示有m个客人，接下来m行，每行3个数字，依次为x,y,v(速度)，然后是n，表示有n把伞，接下来n行，每行2个数字，依次为x，y，每一把伞只能由一个人使用，从开始每个客人出发拿伞，到t时间结束，问最多有几个人拿到了伞。   (1 &lt;= m，n &lt;= 3000) </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>1-m客人，N+1-N+n伞</p><p>依次枚举客人和伞，在规定时间内t*v&gt;=距离就可能拿到这把伞，就可以建边客人–&gt;伞。</p><p>一开始跑匈牙利算法，但是匈牙利算法时间复杂度较大，要TLE。</p><p>这时候需要用<strong>hopcroft-karp</strong>来优化，这里介绍一下<strong>hopcroft-karp</strong>：</p><p><strong>hopcroft-karp</strong>的时间复杂度为 <strong>O（n^0.5*m）</strong>。</p><p>思路：</p><p> HK算法分为三步 ：假设我们将集合分为两个，一个是左边的x集合，右面的y集合； </p><p> 1） ：首先x集合中没有匹配的元素入队列； </p><p> 2） ：以队列中的每一个元素作为起始点然后向他们相邻的点进行BFS就是在寻找增广路或者说是将其他的点根据我们的起始点来分层，如果与队列中的元素（x集合）相连的元素（y集合）没有匹配的话我们就找到了一条增广路（就是一个可能的匹配） </p><p> 3）如果这个元素与x集合中的元素匹配了那么我么就要将x集合中的元素入队列； </p><p> 假设我们有 1–2  1–3 1–4  2–5  2–6 3–5这六条边那么我们的HK算法过程是这样</p><p>集合   x ： 1    2     3</p><p>集合   y ：  2   3    4    5   6  </p><p> 1）在入队了的时候是 1  2  3  </p><p> 2）　　u=1　　 to:　　２　　３　　４　　因为ｙ集合中的２，３，４在ｘ集中没有匹配的元素所以找到了一条增广路 </p><p>​                              dy :　　１　　１　　１　 </p><p>​                u=2     to :     5     6         同上；</p><p>​                              dy:    1     1  </p><p>​                 u=3    to :     5 </p><p>​                             dy:     1 //             这里的深度是在2的时候就更新好了 </p><p>3）</p><p>最后就是朴素的匈牙利匹配算法了：首先1-2成功，2匹配5成功，3匹配5的时候不成功，但是我们我们可以将集合y中5的x集合中 的匹配元素2在找一个匹配正好找到y集合中的6，所以问题中的最大匹配是3 </p><h4 id="匈牙利算法代码："><a href="#匈牙利算法代码：" class="headerlink" title="匈牙利算法代码："></a>匈牙利算法代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=3000*3000+5;const int maxm=6000+5;const int N=3000;struct node{    int to,next;}edge[maxn];struct node1{    double v,x,y;}a[maxm];struct node2{    double x,y;}b[maxm];int k=1,head[maxn],t,T,n,m,cy[maxm],vis[maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        scanf(&quot;%d&quot;,&amp;t);        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%lf%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].v);        }        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%lf%lf&quot;,&amp;b[i].x,&amp;b[i].y);        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=n;j++)            {                if((sqrt((a[i].x-b[i].x)*(a[i].x-b[i].x)+(a[i].y-b[i].y)*(a[i].y-b[i].y)))&lt;=a[i].v*t)                {                    add(i,j+N);                }            }        }        int ans=0;        for(int i=1;i&lt;=m;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,ans);    }    return</code></pre><h4 id="hopcroft-karp算法的代码："><a href="#hopcroft-karp算法的代码：" class="headerlink" title="hopcroft-karp算法的代码："></a>hopcroft-karp算法的代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;const int maxn=3000*3000+5;const int maxm=6000+5;const int N=3000;struct node{    int to,next;}edge[maxn];struct node1{    int v,x,y;}a[maxm];struct node2{    int x,y;}b[maxm];int k=1,head[maxn],t,T,n,m,cy[maxm],dx[maxm],dy[maxm],cx[maxm];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(dy[edge[i].to]==dx[x]+1)        {            dy[edge[i].to]=0;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                cx[x]=edge[i].to;                return 1;            }        }    }    return 0;}int bfs(){    queue&lt;int&gt;q;    memset(dx,0,sizeof(dx));    memset(dy,0,sizeof(dy));    for(int i=1;i&lt;=m;i++)    {        if(!cx[i])            {            q.push(i);        }    }    int ans=0;    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!dy[edge[i].to])            {                dy[edge[i].to]=dx[x]+1;                if(!cy[edge[i].to])ans=1;                else                 {                    dx[cy[edge[i].to]]=dy[edge[i].to]+1;q.push(cy[edge[i].to]);                }            }        }    }    return ans;}int main(){    int opt=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        memset(cx,0,sizeof(cx));        scanf(&quot;%d&quot;,&amp;t);        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].v);        }        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d%d&quot;,&amp;b[i].x,&amp;b[i].y);        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(((a[i].x-b[j].x)*(a[i].x-b[j].x)+(a[i].y-b[j].y)*(a[i].y-b[j].y))&lt;=a[i].v*t*a[i].v*t)                {                    add(i,j+N);                }            }        }        int ans=0;        while(bfs())        {            for(int i=1;i&lt;=m;i++)            {                ans+=dfs(i);            }            }        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(hopcroft-karp)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2819</title>
    <link href="/2020/02/10/HDU-2819/"/>
    <url>/2020/02/10/HDU-2819/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2819 Swap</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2819" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2819</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个n*n的方阵，每一个格子(i,j)由0/1组成，问能否使得斜对角线即i==j,（i∈[1,n]），如果不能就输出-1，否则请输出方案。R表示交换行，C表示交换列。</p><hr><p><strong>这里有一点需要说明，就是说题目的交换，其实是将原来图的某一行移到最后图的某一行，而不是指先交换两行，得到一个新图，再交换新图的两行。</strong> </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>首先是关于能否得到斜对角线全为1的方阵，假如一个方阵的斜对角线全为1，那么这个方阵的秩为n，那么如果一个方阵的秩小于n那一定就不可以。那么如何得到方阵的秩呢？受到前面几个二分图的题的影响，凡是方格类的题目都可以将行和列分开，将数字为1的方格就行连边，即行i–&gt;列j，最后求最大匹配，一旦最大匹配为n那就可以，否则输出-1。由矩阵的运算性质可以知道，所有的列变换都可以用行变换来替代，所有的行变换都可以用列变换来替代，于是我们不妨全部都用列变换来替换，已知cy[i]表示第i列和cy[i]行来配对，从1-n列开始枚举，然后枚举得到第一个cy[j]==i的列，说明i列与j列应该替换，然后这一层循环就应该终止！必须终止！否则答案会变多。储存交换的列。最后一个个输出。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+5;const int maxm=100+5;const int N=100+5;int n,a[maxm][maxm],k=1,head[maxn],cy[maxn],l1[maxn],l2[maxn],vis[maxn]; struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;a[i][j]);            }        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(a[i][j])                {                    add(i,j+N);                }            }        }            int ans=0;            for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        if(ans==n)        {            int tot=0;            for(int i=1;i&lt;=n;i++)            {                for(int j=1;j&lt;=n;j++)                {                    if(cy[j+N]!=i)continue;                    if(i!=j)//交换i，j列                     {                        tot++;                        l1[tot]=i;l2[tot]=j;                        swap(cy[j+N],cy[i+N]);                        break;                    }                }            }            printf(&quot;%d\n&quot;,tot);            for(int i=1;i&lt;=tot;i++)            {                printf(&quot;C %d %d\n&quot;,l1[i],l2[i]);            }        }        else         {            printf(&quot;-1\n&quot;);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1281</title>
    <link href="/2020/02/10/HDU-1281/"/>
    <url>/2020/02/10/HDU-1281/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1281 棋盘游戏</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1281" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1281</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在N*M的棋盘上，在p个位置上允许放车，每一行每一列最多放一个车，并且在不允许放车的位置并不会影响车的攻击。重要点：要使车的数量最大，该点必须放车。问最多有多少个重要点、最多允许放多少个车？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题和Fire Net的区别在于，Fire Net不允许放置的点是一堵墙，会隔离攻击，而这道题不会影响攻击。所以Fire Net那道题需要进行分区域块，这样就可以分离开。但是这道题不会影响攻击，因此直接按点分，X集合为行，Y集合为列，只要当a[i][j]==1才可以让i行与j列连边，相当于点(i,j)可以放车。这样跑匈牙利算法可以得到最大匹配即最大的车的放置量。对于重要点的求解需要暴力求解，对于每一个可放置车的点需要去除它，然后跑匈牙利算法，如果最大匹配变小了，说明这是重要点，当然对于前向星链表，要记录出发点u，这样就可以进行标记了，vis数组不可以开大了，容易TLE。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int maxm=300+5;const int N=100+5;int head[maxn],k=1,n,m,p,a[maxm][maxm],cy[maxn],vis[maxm];struct node{    int to,next,u;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].u=u;}int dfs(int x,int sign1,int sign2){    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(edge[i].to==sign2&amp;&amp;edge[i].u==sign1)continue;        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to],sign1,sign2))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    int opt=0;    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p)!=EOF)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(a,0,sizeof(a));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=p;i++)        {            int X,Y;            scanf(&quot;%d%d&quot;,&amp;X,&amp;Y);            a[X][Y]=1;        }        int ans1=0,ans2=0,tot=0;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=m;j++)            {                if(a[i][j])                {                    add(i,j+N);                }            }        }        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans2+=dfs(i,0,0);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=m;j++)            {                ans1=0;                memset(cy,0,sizeof(cy));                for(int w=1;w&lt;=n;w++)                {                    memset(vis,0,sizeof(vis));                    ans1+=dfs(w,i,j+N);                }                if(ans1!=ans2)                    tot++;            }        }        printf(&quot;Board %d have %d important blanks for %d chessmen.\n&quot;,opt,tot,ans2);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1083</title>
    <link href="/2020/02/09/HDU-1083/"/>
    <url>/2020/02/09/HDU-1083/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 1083Courses</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1083#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1083#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 一共有N个学生跟P门课程,一个学生可以任意选一 门或多门课,问是否达成:</p><p>1.每个学生选的都是不同的课(即不能有两个学生选同一门课)</p><p>2.每门课都有一个代表(即P门课都被成功选过)</p><p> 若能满足上面两个要求这输出”YES”,否则为”NO”  注意：是课程匹配的学生，学生没课上没事….. </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最终问题就是问能否所有的课程都被人选，并且没有两个及以上的人选同一门课。换言之，二分图的最大匹配数是否==p。建图时课程–&gt;学生，课程(1-P)，学生(N+1-N+n)，跑匈牙利算法。</p><p><strong>ps</strong>：数组开小了不会RE，它会TLE！因为一开始只开了10000的边，实际上时100*300，然后TLE了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=30000+5;const int N=300+5;struct node{    int to,next;}edge[maxn*2];int k=1,T,p,n,head[maxn],vis[maxn],cy[maxn];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int dfs(int x){    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        scanf(&quot;%d%d&quot;,&amp;p,&amp;n);        for(int i=1;i&lt;=p;i++)        {            int num;            scanf(&quot;%d&quot;,&amp;num);            for(int j=1;j&lt;=num;j++)            {                int x;                scanf(&quot;%d&quot;,&amp;x);                add(i,x+N);            }        }        int ans=0;        for(int i=1;i&lt;=p;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        if(ans==p)        {            printf(&quot;YES\n&quot;);        }        else         {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2444</title>
    <link href="/2020/02/09/HDU-2444/"/>
    <url>/2020/02/09/HDU-2444/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 2444 The Accomodation of Students</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2444#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2444#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个关系，他们之间某些人相互认识。这样的人有m对。<br>你需要把人分成2组，使得每组人内部之间是相互不认识的。<br>如果可以，就可以安排他们住宿了。安排住宿时，住在一个房间的两个人应该相互认识。<br>最多的能有多少个房间住宿的两个相互认识。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题分为两个问题，第一个问题就是问是否可以分成两组，每一组内部任意两人都互相不认识；第二个问题是最多有几组两人之间相互认识，注意一人只能选择一次。第一个问题很显然就是判断这个图是否可以形成一个二分图，第二个问题是在该图是二分图的条件下的最大匹配数。二分图的判断方法就染色法，用bfs，将相邻的点全部染成相反的颜色，一旦该点与相邻点颜色相同就说明不能形成二分图，最后如果无矛盾就说明可以形成二分图。注意我们建图全部小–&gt;大，而条件给的数据也是如此，这样一定是从小的点出发，bfs起点就为1。求最大匹配时候，我们注意这图是单向的所以直接跑匈牙利。当然保险的是建双向边，求出最大匹配后，注意ans/2就可以了，因为对称，1认识2 与 2认识1 属同一情况。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;struct node{    int to,next;}edge[maxn*2];int k=1,head[maxn],vis[maxn],cy[maxn],n,m;void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}bool bfs(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(vis[edge[i].to]==vis[x])return 0;            if(vis[x]==1)vis[edge[i].to]=2;            else vis[edge[i].to]=1;            q.push(edge[i].to);        }    }    return 1;}int dfs(int x){    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||dfs(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        k=1;        memset(edge,0,sizeof(edge));        memset(head,0,sizeof(head));        memset(cy,0,sizeof(cy));        for(int i=1;i&lt;=m;i++)        {            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a,b);        }        int pd=bfs();        if(pd==0)        {            printf(&quot;No\n&quot;);            continue;        }        int ans=0;        for(int i=1;i&lt;=n;i++)        {            memset(vis,0,sizeof(vis));            ans+=dfs(i);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1045</title>
    <link href="/2020/02/09/HDU-1045/"/>
    <url>/2020/02/09/HDU-1045/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p> HDU - 1045 Fire Net</p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://vjudge.net/problem/HDU-1045#author=Codeblocksm" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1045#author=Codeblocksm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 现在有一个N*N的地图，地图上有一些围墙。你的任务是在没有围墙的空白地方建尽可能多的炮台。 假设炮台可以向“上下左右”四个方向发射子弹，子弹可以穿越任何距离并可在途中摧毁一个另一个炮台。而墙壁结构坚固，可以阻止子弹。 问最多可以建设多少个炮台？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>刚开始做二分图的最大匹配问题，没有什么思路啊，没想到如何将一块区域弄来建图，后来看了一下别人的思路，将同一列的联通区域求出来，当然同一联通区域有且只有一个炮台，否则不合题意；将同一行的联通区域求出来，也只能存在一个炮台。如何将列和行结合起来呢？然后列中第i个连通块与行中第j个连通块有交点，说明交点处可以建炮台，判断方法：y[j].h&gt;=x[i].s&amp;&amp;y[j].h&lt;=x[i].t&amp;&amp;x[i].l&gt;=y[j].s&amp;&amp;x[i].l&lt;=y[j].t。那么可以add(i,j+N)。这样建了图后用匈牙利算法来求最大匹配就可以了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;const int N=500;char a[maxn][maxn];int vis[maxn],cy[maxn],n,k=1,head[maxn];struct node1{    int l,s,t;}x[maxn];//表示列块 struct node2{    int h,s,t;}y[maxn];//表示行块 struct node{    int to,next;}edge[maxn*2];void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int check(int x){    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!cy[edge[i].to]||check(cy[edge[i].to]))            {                cy[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=0)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(cy,0,sizeof(cy));        memset(a,0,sizeof(a));        memset(x,0,sizeof(x));        memset(y,0,sizeof(y));        int tot1=0,tot2=0;        for(int i=1;i&lt;=n;i++)            scanf(&quot;%s&quot;,a[i]+1);        for(int i=1;i&lt;=n;i++)        {            int s=1;            while(s&lt;=n)            {                if((s&gt;1&amp;&amp;a[s-1][i]==&#39;X&#39;&amp;&amp;a[s][i]==&#39;.&#39;)||(s==1&amp;&amp;a[s][i]==&#39;.&#39;))                {                    tot1++;                    x[tot1].l=i;x[tot1].s=s;x[tot1].t=s;                }                if(a[s][i]==&#39;.&#39;)x[tot1].t=s;                s++;            }        }        for(int i=1;i&lt;=n;i++)        {            int s=1;            while(s&lt;=n)            {                if((s&gt;1&amp;&amp;a[i][s-1]==&#39;X&#39;&amp;&amp;a[i][s]==&#39;.&#39;)||(s==1&amp;&amp;a[i][s]==&#39;.&#39;))                {                    tot2++;                    y[tot2].h=i;y[tot2].s=s;y[tot2].t=s;                }                if(a[i][s]==&#39;.&#39;)y[tot2].t=s;                s++;            }        }        for(int i=1;i&lt;=tot1;i++)        {            for(int j=1;j&lt;=tot2;j++)            {                if(y[j].h&gt;=x[i].s&amp;&amp;y[j].h&lt;=x[i].t&amp;&amp;x[i].l&gt;=y[j].s&amp;&amp;x[i].l&lt;=y[j].t)                {                    add(i,j+N);                }            }        }        int ans=0;        for(int i=1;i&lt;=tot1;i++)        {            memset(vis,0,sizeof(vis));            ans+=check(i);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2255</title>
    <link href="/2020/02/09/HDU-2255/"/>
    <url>/2020/02/09/HDU-2255/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-2255  奔小康赚大钱 </p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2255#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2255#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>n个居民n个房子，每个居民会给不同的房子不同的钱，问如何分配使得钱最多？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>KM的模板题，KM的具体介绍由blog的KM讲解中提供</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300+5;int Map[maxn][maxn],visx[maxn],visy[maxn],cx[maxn],cy[maxn],n,wx[maxn],wy[maxn],minn;int dfs(int x){    visx[x]=1;    for(int i=1;i&lt;=n;i++)    {        if(!visy[i]&amp;&amp;Map[x][i]!=0x3f3f3f3f)        {            int t=wx[x]+wy[i]-Map[x][i];            if(t==0)            {                visy[i]=1;                if(!cy[i]||dfs(cy[i]))                {                    cy[i]=x;                    cx[x]=i;                    return 1;                }                    }            else             {                minn=min(minn,t);            }        }    }    return 0;}int KM(){    memset(visx,0,sizeof(visx));    memset(visy,0,sizeof(visy));    memset(cx,0,sizeof(cx));    memset(cy,0,sizeof(cy));    memset(wx,0,sizeof(wx));    memset(wy,0,sizeof(wy));    minn=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(Map[i][j]!=0x3f3f3f3f)            {                wx[i]=max(wx[i],Map[i][j]);            }        }    }    for(int i=1;i&lt;=n;i++)    {        while(1)        {            memset(visx,0,sizeof(visx));            memset(visy,0,sizeof(visy));            minn=0x3f3f3f3f;            if(dfs(i))break;            for(int i=1;i&lt;=n;i++)            {                if(visx[i])                {                    wx[i]-=minn;                }            }            for(int i=1;i&lt;=n;i++)            {                if(visy[i])                {                    wy[i]+=minn;                }            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        if(cx[i]!=0)ans+=Map[i][cx[i]];    }    return ans;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(Map,0x3f3f3f3f,sizeof(Map));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;Map[i][j]);            }        }        int ans=KM();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>KM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KM算法详解</title>
    <link href="/2020/02/09/KM%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/02/09/KM%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h1><p>以<strong><em>匈牙利算法</em></strong>为基础，改善后用于求解带权二分图的<strong><em>最佳匹配</em></strong>问题</p><h2 id="完备匹配："><a href="#完备匹配：" class="headerlink" title="完备匹配："></a>完备匹配：</h2><p>如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，<strong>或者</strong>Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。 </p><h2 id="完美匹配："><a href="#完美匹配：" class="headerlink" title="完美匹配："></a>完美匹配：</h2><p>若二分图X部的每一个顶点都与Y中的一个顶点匹配，<strong>并且</strong>Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完美匹配。 </p><p>即： 一个二分图，X部和Y部的顶点数相等，存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。  </p><h2 id="最大权匹配："><a href="#最大权匹配：" class="headerlink" title="最大权匹配："></a>最大权匹配：</h2><p>带权二分图的边权重和最大的匹配，如图，最大和为102</p><p> <img src="https://img-blog.csdnimg.cn/20181105155320651.png" srcset="/img/loading.gif" alt="img"> </p><h2 id="最佳匹配："><a href="#最佳匹配：" class="headerlink" title="最佳匹配："></a>最佳匹配：</h2><p>带权二分图的边权重和最大的完备匹配，如图</p><p> <img src="https://img-blog.csdnimg.cn/2018110515570130.png" srcset="/img/loading.gif" alt="img"> </p><p>显然最大权匹配和最佳匹配不完全相同，最大权匹配由于不一定是最大匹配，所以无法等同于最佳匹配。</p><p>但是如果把剩余的边补上，并且设置边权为0，那么二者可以统一起来。如图</p><p> <img src="https://img-blog.csdnimg.cn/20181105160925184.png" srcset="/img/loading.gif" alt="img"> </p><h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><p>km算法用于求最佳匹配，而不是最大权匹配。换言之，km算法用来求完备匹配下的最大权匹配。</p><p><u>如果不存在完备匹配，km算法会求最大匹配，如果最大匹配存在多种，那么结果就是最大匹配中权重和最大的。</u></p><hr><p>在一个二分图中，左顶点为X，右顶点为Y，现在对于每组左右连接XiYi有权Wij，求最大匹配，并且使得该匹配中所有Wij的和最大。</p><p>该算法通过给每一个顶点一个标号(称为顶标)来把求最大权匹配的问题转换为求完备匹配的问题。</p><p>设顶点Xi的顶标为A[i]，顶点Yi的顶标为B[i]，顶点Xi和Yi之间的边权为W[i][j]，在整个过程中任意一条边&lt;i,j&gt;，始终满足A[i]+B[j]&gt;=W[i][j].</p><h2 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h2><p>图G中每一条边有左右两个顶标，<strong><em>相等子图</em></strong>就是那些顶标和等于边权重的边构成的子图，如图例</p><p> <img src="https://img-blog.csdnimg.cn/20181105162845589.png" srcset="/img/loading.gif" alt="img"> </p><h2 id="KM算法的正确性"><a href="#KM算法的正确性" class="headerlink" title="KM算法的正确性"></a>KM算法的正确性</h2><p><strong>定理</strong>：若二分图中，A[i]+B[j]&gt;=W[i][j],并且存在某个相等子图有完备匹配，那么这个完备匹配就是二分图的最大权匹配</p><p><strong>证明</strong>：因为这个完备匹配存在于相等子图中，因此，这个匹配所有边满足于：A[i]+B[j]==W[i][j],同时由于完备匹配包含所有的顶点，因此这个属于相等子图的完备匹配的总权重等于所有顶标的和。</p><p>如果这个二分图存在另外一个完备匹配，如果它不完全属于相等子图，即存在某条边：A[i]+B[j]&gt;W[i][j],那么该匹配的权重和就小于所有顶标的和，即小于上述属于相等子图的完备匹配的权重和。</p><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ul><li><p>首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。</p><p><img src="https://img-blog.csdnimg.cn/20181105161921533.png" srcset="/img/loading.gif" alt="img"> </p></li><li><p>对于X部中的每个顶点，在<strong><em>相等子图</em></strong>中利用<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">匈牙利算法</a>找一条<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">增广路径</a>，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配是最大权重的完备匹配，即为二分图的最佳匹配。</p><p><strong>匈牙利算法</strong>对左边第一个顶点，在<strong><em>相等子图</em></strong>中进行增广路径搜索，找到路径1-C后进行<a href="https://blog.csdn.net/qq_25379821/article/details/83721379" target="_blank" rel="noopener">匹配增广操作</a>，如下图所示 </p><p><img src="https://img-blog.csdnimg.cn/20181105163243917.png" srcset="/img/loading.gif" alt="img"> </p></li></ul><p>接着<strong>匈牙利算法</strong>对左边第二个顶点，在<strong><em>相等子图</em></strong>中进行增广路径搜索，结果是没有找到增广路径！这时需要修改顶标值，<strong>扩大</strong>相等子图，左边的顶标减少d，右边的顶标增加d，这里产生两个问题： </p><ul><li>哪些顶标需要修改</li><li>d是多少</li></ul><p><strong>question1：</strong> 注意在保持相等子图原来的边符合相等子图要求的同时，让新加的边也满足相等子图的要求。 </p><p>那么在增广路径搜索时，我们知道，如果下面这些紫色边任意一条加入相等子图后，都可以在相等子图中使用<strong>匈牙利算法</strong>找到一条增广路径2-A（or 2-B or 2-C-1-A）： </p><p> <img src="https://img-blog.csdnimg.cn/20181105165825707.png" srcset="/img/loading.gif" alt="img"> </p><p><strong>question2</strong>： <strong>KM算法</strong>选择上述三条紫色边中，顶标和与边权重差值最小的边1-A或者2-A，以该最小差值为d </p><p><strong>ps</strong>： 为什么选最小那个 ？</p><p><strong>回答</strong>：如果比这个还小就不能扩大相等子图了，如果大了，就不能保证A[i]+B[j]&gt;=W[i][j]总是成立了。 比如上图选择了2-B边 ，则差值d就为2，1-A就有A[i]+B[j]=2+0&lt;3=W[i][j].</p><p><strong>KM算法</strong>中需要修改的顶标是<strong>匈牙利算法</strong>增广路径搜索时，产生一棵交错树，为了保证A[i]+B[j]&gt;=W[i][j]总是成立，交错树上所有的顶标都需要进行修改。</p><p>比如在第二个顶点搜索增广路时，产生如图所示的橙色顶标集合{1,2,C}</p><p> <img src="https://img-blog.csdnimg.cn/20181105165032976.png" srcset="/img/loading.gif" alt="img"> </p><p> <strong>修改顶标</strong>后产生如下图所示的结果： </p><p> <img src="https://img-blog.csdnimg.cn/20181105183106680.png" srcset="/img/loading.gif" alt="img"> </p><p> 在该相等子图上以顶点2为开始点，<strong>搜索增广路径</strong>2-A（or 2-C-1-A），<strong>进行增广</strong>操作: </p><p> <img src="https://img-blog.csdnimg.cn/20181105183544455.png" srcset="/img/loading.gif" alt="img"> </p><p> 同样对左边第三个点： </p><p> <img src="https://img-blog.csdnimg.cn/20181105185155651.png" srcset="/img/loading.gif" alt="img"> </p><p><strong>ps</strong>:为什么修改橙色顶标而不去修改顶标A(找到最小差对应的边的右边顶标)？修改顶标A的值为-1， 那么边1-A也可以加入<strong>相等子图</strong>了。但是这样就无法保证A[i]+B[j]&gt;=W[i][j]恒成立了。如下图所示结果，修改顶标A，边3-A就不满足该条件了。除非在修改顶标A的同时，增加顶标3的值，但是需要修改的顶标集合需要额外的搜索算法，而修改橙色顶标所需要的<strong>交错树</strong>在增广路径搜索时可以一并产生。 </p><p> <img src="https://img-blog.csdnimg.cn/20181106152548762.png" srcset="/img/loading.gif" alt="img"> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300+5;int Map[maxn][maxn],visx[maxn],visy[maxn],cx[maxn],cy[maxn],n,wx[maxn],wy[maxn],minn;int dfs(int x){    visx[x]=1;    for(int i=1;i&lt;=n;i++)    {        if(!visy[i]&amp;&amp;Map[x][i]!=0x3f3f3f3f)        {            int t=wx[x]+wy[i]-Map[x][i];            if(t==0)            {                visy[i]=1;                if(!cy[i]||dfs(cy[i]))                {                    cy[i]=x;                    cx[x]=i;                    return 1;                }                    }            else             {                minn=min(minn,t);            }        }    }    return 0;}int KM(){    memset(visx,0,sizeof(visx));    memset(visy,0,sizeof(visy));    memset(cx,0,sizeof(cx));    memset(cy,0,sizeof(cy));    memset(wx,0,sizeof(wx));    memset(wy,0,sizeof(wy));    minn=0x3f3f3f3f;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(Map[i][j]!=0x3f3f3f3f)            {                wx[i]=max(wx[i],Map[i][j]);            }        }    }    for(int i=1;i&lt;=n;i++)    {        while(1)        {            memset(visx,0,sizeof(visx));            memset(visy,0,sizeof(visy));            minn=0x3f3f3f3f;            if(dfs(i))break;            for(int i=1;i&lt;=n;i++)            {                if(visx[i])                {                    wx[i]-=minn;                }            }            for(int i=1;i&lt;=n;i++)            {                if(visy[i])                {                    wy[i]+=minn;                }            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        if(cx[i]!=0)ans+=Map[i][cx[i]];    }    return ans;}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(Map,0x3f3f3f3f,sizeof(Map));        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;Map[i][j]);            }        }        int ans=KM();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>KM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu-3386</title>
    <link href="/2020/02/08/luogu-3386/"/>
    <url>/2020/02/08/luogu-3386/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>luogu-P3386 二分图匹配模板</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://www.luogu.com.cn/problem/P3386" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3386</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定一个二分图，结点个数分别为n,m，边数为e，求二分图最大匹配数 </p><p> 因为数据有坑，可能会遇到 v&gt;m 或者 u&gt;n的情况。请把 v&gt;m 或者 u&gt;n的数据自觉过滤掉。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是二分图最大匹配匹配的模板题。</p><p>这里简述一下二分图的匈牙利算法：</p><p>给出下图，要求最大匹配数</p><p> <img src="https://img-blog.csdn.net/20130503155150538" srcset="/img/loading.gif" alt="img"> </p><p> 匈牙利算法的工作模式 如下：</p><p> <strong>一：</strong> 先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，got it，连上一条蓝线 </p><p> <img src="https://img-blog.csdn.net/20130503155256629" srcset="/img/loading.gif" alt="img"> </p><p> <strong>二</strong>：接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主，got it  <img src="https://img-blog.csdn.net/20130503155344972" srcset="/img/loading.gif" alt="img"> </p><p> <strong>三</strong>：接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？ </p><p> 我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。 </p><p> (黄色表示这条边被临时拆掉) </p><p> <img src="https://img-blog.csdn.net/20130503155428908" srcset="/img/loading.gif" alt="img"> </p><p> 与1号男生相连的第二个女生是2号女生，但是2号女生也有主了，怎么办呢？我们再试着给2号女生的原配  重新找个妹子 </p><p> <img src="https://img-blog.csdn.net/20130503155441032" srcset="/img/loading.gif" alt="img"> </p><p> 此时发现2号男生还能找到3号女生，那么之前的问题迎刃而解了，回溯回去 ：</p><p> 2号男生可以找3号妹子     </p><p> <img src="https://img-blog.csdn.net/20130503155453501" srcset="/img/loading.gif" alt="img"> </p><p>  1号男生可以找2号妹子了 </p><p> <img src="https://img-blog.csdn.net/20130503155626560" srcset="/img/loading.gif" alt="img"> </p><p> 3号男生可以找1号妹子 </p><p> <img src="https://img-blog.csdn.net/20130503162147840" srcset="/img/loading.gif" alt="img"> </p><p> 所以第三步最后的结果就是： </p><p> <img src="https://img-blog.csdn.net/20130503160156253" srcset="/img/loading.gif" alt="img"> </p><p> <strong>四</strong>： 接下来是4号男生，很遗憾，按照第三步的节奏我们没法给4号男生腾出来一个妹子 。</p><p>综上所诉：</p><p>我们对于左边(即X集合)每一个点都进行一次dfs，寻找可匹配的点(Y集合)，注意每一轮的dfs每一个点只可遍历一次，对于vis数组每轮开始要清空，然后遍历时，注意!girl[edge[i].to]||check(girl[edge[i].to])意味着有增广路，也就是说匹配数可以增加1.此时Y集合对应的X集合的点就变了。、</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000000+5;struct node{    int to,next;}edge[maxn];int n,m,e,vis[maxn],girl[maxn],head[maxn],k=1;void add(int u,int v){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;}int check(int x){    for(int i=head[x];i;i=edge[i].next)    {        if(!vis[edge[i].to])        {            vis[edge[i].to]=1;            if(!girl[edge[i].to]||check(girl[edge[i].to]))            {                girl[edge[i].to]=x;                return 1;            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;e);    for(int i=1;i&lt;=e;i++)    {        int u,v;        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        if(u&gt;n||v&gt;m)continue;        add(u,v+n);    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        memset(vis,0,sizeof(vis));        ans+=check(i);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>二分图(匈牙利算法)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3416</title>
    <link href="/2020/02/07/HDU-3416/"/>
    <url>/2020/02/07/HDU-3416/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-3416 Marriage Match IV</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3416" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3416</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> n 个点 m 条边带权有向图，问每条边最多只能走一次时从 A 到 B 的最短路径数量。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>问题是问从s–&gt;t有多少种完全不同的最短路径。首先要想办法找到哪些边属于最短路径里面的边，于是先正向跑一遍spfa，再反向跑一遍spfa，设smin为s–&gt;t的最短路的长度，那如果一条边属于最短路，那它一定满足dist1[x[i]]+dist2[y[i]]+w[i]==smin&amp;&amp;x[i]!=y[i]。这样就可以找到最短路径的所有边，然后建边时注意，x[i]–&gt;y[i],边权为1，跑dinic，得到的最大流ans就是答案。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200010+5;int T,n,m,s,t,head[maxn],dist2[maxn],dist1[maxn],vis[maxn],k=1,k2=1,head2[maxn],deep[maxn],x[maxn],y[maxn],w[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa1(int s)//dist1[i]表示从A--i的距离,spfa1跑正边 {    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist1,0x3f3f3f3f,sizeof(dist1));    dist1[s]=0;vis[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)            {                dist1[edge[i].to]=dist1[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void spfa2(int s)//dist2[i]表示从i--B的距离,spfa2跑反边 {    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist2,0x3f3f3f3f,sizeof(dist2));    dist2[s]=0;vis[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)            {                dist2[edge[i].to]=dist2[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    q.push(s);deep[s]=1;    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}int dinic(){    int ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }    return ans;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(x,0,sizeof(x));        memset(y,0,sizeof(y));        memset(w,0,sizeof(w));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;x[i],&amp;y[i],&amp;w[i]);        }        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);        for(int i=1;i&lt;=m;i++)        {            add(x[i],y[i],w[i]);        }        spfa1(s);        int smin=dist1[t];        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=m;i++)        {            add(y[i],x[i],w[i]);        }        spfa2(t);        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=m;i++)        {        //    cout&lt;&lt;dist1[x[i]]&lt;&lt;&#39; &#39;&lt;&lt;dist2[y[i]]&lt;&lt;&#39; &#39;&lt;&lt;w[i]&lt;&lt;&#39; &#39;&lt;&lt;smin&lt;&lt;endl;            if(dist1[x[i]]+dist2[y[i]]+w[i]==smin&amp;&amp;x[i]!=y[i])            {                add(x[i],y[i],1);add(y[i],x[i],0);            }        }        int ans=dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu-2764</title>
    <link href="/2020/02/07/luogu-2764/"/>
    <url>/2020/02/07/luogu-2764/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>luogu2764-最小路径覆盖问题</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p> 给定有向图 G=(V,E)<em>G</em>=(<em>V</em>,<em>E</em>) 。设 P是 G 的一个简单路(顶点不相交)的集合。如果 V 中每个定点恰好在P<em>P</em>的一条路上，则称 P 是 G的一个路径覆盖。P<em>P</em>中路径可以从 V 的任何一个定点开始，长度也是任意的，特别地，可以为 0 。G 的最小路径覆盖是 G所含路径条数最少的路径覆盖。设计一个有效算法求一个 GAP (有向无环图) G的最小路径覆盖 </p><p> 从第1 行开始，每行输出一条路径。文件的最后一行是最少路径数。 </p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>要求的是最少路径数将所有的点都覆盖掉。</p><p>由konig定理知：最小点覆盖=最大匹配数；<br>而该题抽出模型就成了：最小路径覆盖；<br>最小路径覆盖=点数-最大匹配数；</p><p>如何理解这个结论呢？(这个解释并不严谨，只是为了帮助理解，请勿喷)<br>    加入1–&gt;2–&gt;3;<br>    可以转化为1–&gt;2’;2–&gt;3’;<br>    1,2,3在X中，1’,2’,3’在Y中；路径数=3-2；符合结论；<br>    再举例1–&gt;2,1–&gt;3,2–&gt;4,3–&gt;4;<br>    可以转化为1–&gt;2’,1–&gt;3’,2–&gt;4’,3–&gt;4’;最大匹配数为2；最少路径数为2.符合结论<br>由上面的例子可以分析一下：<br>    x与x’都处于匹配边中时，说明点x处于一条路径中；而一条路径中的开头点与结尾点的x和x’只能选择其中一个。此时(该路径中的)点个数-边数=1;<br>那么有多少个“1”就说明有多少条路径。就可以说明最小路径覆盖=点数-最大匹配数；</p><p>证明了以上的结论后，就可以考虑建模了：<br>    把一个点拆成x，x’，s向所有的x连边，所有的x’ 向t连边， 如果x1–&gt;y1，就将x1向y1’连边，所有的边容量为1(反边容量为0)；<br>    然后开始跑最大流，实际上跑出来的最大流就是最大匹配数，那么最小边覆盖=n-ans；<br>接着要开始说明每一条路径：<br>    从1-n都枚举一边，每一个点连向的是x’,并且如果最大流流向了x’(流向了x’就说明该边流量为0），然后输出该值，继续dfs。<br>    注意要排除s，t的点；</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt; using namespace std;const int maxn=600000+5;int n,m,k=1,head[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int s,t,ans,deep[maxn];bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(edge[i].w&amp;&amp;!deep[edge[i].to])            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    if(deep[t])return 1;    return 0;}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;            }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int vis[maxn];void work(int x){    for(int i=head[x];i;i=edge[i].next)    {        int TO=edge[i].to;        if(TO&gt;2*n)continue;        if(TO&gt;n)TO-=n;        if(edge[i].w==0&amp;&amp;!vis[TO])        {            int x=edge[i].to;            if(x&gt;n)x-=n;            cout&lt;&lt;x&lt;&lt;&#39; &#39;;            vis[x]=1;            work(x);        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    s=2*n+1;t=s+1;    for(int i=1;i&lt;=n;i++)add(s,i,1),add(i,s,0);    for(int i=1;i&lt;=m;i++)    {        int a,b;        cin&gt;&gt;a&gt;&gt;b;        add(a,b+n,1);add(b+n,a,0);    }    for(int i=1;i&lt;=n;i++)add(i+n,t,1),add(t,i+n,0);    dinic();    for(int i=1;i&lt;=n;i++)    {        if(!vis[i])        {            vis[i]=1;            cout&lt;&lt;i&lt;&lt;&#39; &#39;;            work(i);            cout&lt;&lt;endl;        }    }    cout&lt;&lt;n-ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3336</title>
    <link href="/2020/02/07/HDU-3336/"/>
    <url>/2020/02/07/HDU-3336/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3336 Count the string</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3336#author=cust_acm" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3336#author=cust_acm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个字符串，求它所有子串(包括自身)出现的总次数之</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>该题目需要比较完善地理解Next数组地含义与作用。当匹配到i失败时，就会返回到Next[i]。则匹配到i时，应该记录了子串s[0…i]，以及与子串s[0…Next[i]]。于是就可以得到动态转移方程dp[i]=dp[Next[i]]+1.然后求和dp数组，同时取模。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;const int Mod=10007;int T,len1,len2,Next[maxn],dp[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        int ans=0;        memset(s2,0,sizeof(s2));        memset(Next,0,sizeof(Next));        memset(dp,0,sizeof(dp));        scanf(&quot;%d&quot;,&amp;len2);        scanf(&quot;%s&quot;,s2);        next_pre();        for(int i=1;i&lt;=len2;i++)        {            if(Next[i]!=-1)                dp[i]=dp[Next[i]]+1;        }        for(int i=1;i&lt;=len2;i++)            ans=(ans+dp[i])%Mod;        printf(&quot;%d\n&quot;,ans);    }        return 0;} </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4300</title>
    <link href="/2020/02/07/HDU-4300/"/>
    <url>/2020/02/07/HDU-4300/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-4300 Clairewd’s message</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4300" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4300</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>第一行给的是26个字母对应的翻译密码，而第二行给的是文本串，该文本串前面部分为加密后的内容，而后部分(可能不完整)为未加密的内容。求：一行字符串前一半为加密后的内容，后一半为未加密的内容。一一对应的关系。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>由题意可知，文本串前一部分是加密过后的内容，后一部分是未加密的内容，而这一部分可能是不完整的。则可理解为s=stringA+stringB。可以根据第一行给的加密方式将s整体当作加密内容，将其转化为整体未加密的内容，即字符串s转化成了t。这时候将原s的所有后缀与t匹配，这个过程实际上就是ex-kmp，将t作为子串，s作为母串，求t与s的所有后缀的公共前缀的长度extend[]。如果extend[i]+i==len(s)&amp;&amp;i&gt;=extend[i].即以i为分界点，s[0…i-1]作为stringA，s[i…len-1]作为stringB，即stringB就是原文本内容。(i&gt;=extend[i]的原因：如果stringB与t的公共连续子串的长度大于了i，这就与extend[i]的定义矛盾了。)选择最近的符合条件的点作为答案。分两部分输出即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000+5;const int maxm=1000+5;int T,len1,len2,Next[maxn],Extend[maxn],t[maxm],q[maxm];char S[maxn],s1[maxn],s2[maxn];void next_pre(){    int i=0,po=0;    while(s1[i]==s1[i+1]&amp;&amp;i+1&lt;len2)i++;    Next[0]=len2;Next[1]=i;po=1;    for(int i=2;i&lt;len1;i++)    {        if(Next[i-po]+i&lt;Next[po]+po)            Next[i]=Next[i-po];        else         {            int j=Next[po]+po-i;            if(j&lt;0)j=0;            while(s1[i+j]==s1[j]&amp;&amp;i+j&lt;len2)j++;            Next[i]=j;            po=i;        }    }}void extend_pre(){    int i=0,po=0;    while(s2[i]==s1[i]&amp;&amp;i&lt;len2)i++;    Extend[0]=i;    for(int i=1;i&lt;len2;i++)    {        if(Next[i-po]+i&lt;Extend[po]+po)            Extend[i]=Next[i-po];        else         {            int j=Extend[po]+po-i;            if(j&lt;0)j=0;//            cout&lt;&lt;j&lt;&lt;&#39; &#39;&lt;&lt;i+j&lt;&lt;endl;//            cout&lt;&lt;s1[j]&lt;&lt;&#39; &#39;&lt;&lt;s2[i+j]&lt;&lt;endl;            while(s2[i+j]==s1[j]&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len2)j++;            Extend[i]=j;            po=i;        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(Next,0,sizeof(Next));        memset(Extend,0,sizeof(Extend));        memset(t,0,sizeof(t));        memset(q,0,sizeof(q));        memset(S,0,sizeof(S));        memset(s1,0,sizeof(s1));        memset(s2,0,sizeof(s2));        scanf(&quot;%s%s&quot;,S,s2);        len1=strlen(s2);len2=strlen(s2);        for(int i=0;i&lt;26;i++)        {            t[i]=S[i]-&#39;a&#39;;//a,b,c...z分别转化为s1[0],s1[1],s1[2]...s1[25]             q[S[i]-&#39;a&#39;]=i;//再转化回去，形成映射         }        for(int i=0;i&lt;len2;i++)        {            s1[i]=q[s2[i]-&#39;a&#39;]+&#39;a&#39;;        }        s1[len2]=&#39;\0&#39;;//        cout&lt;&lt;s1&lt;&lt;endl;        next_pre();        extend_pre();//        for(int i=0;i&lt;len2;i++)cout&lt;&lt;Next[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;//        for(int i=0;i&lt;len2;i++)cout&lt;&lt;Extend[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;        int opt=0;        for(int i=0;i&lt;len2;i++)        {            if(Extend[i]+i==len2&amp;&amp;i&gt;=Extend[i])            {                opt=i;                break;            }        }//        cout&lt;&lt;opt&lt;&lt;endl;        for(int i=0;i&lt;opt;i++)printf(&quot;%c&quot;,s2[i]);        for(int i=0;i&lt;opt;i++)printf(&quot;%c&quot;,q[s2[i]-&#39;a&#39;]+&#39;a&#39;);        if(opt==0)        {            printf(&quot;%s&quot;,s2);            for(int i=0;i&lt;len2;i++)printf(&quot;%c&quot;,q[s2[i]-&#39;a&#39;]+&#39;a&#39;);        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ex-kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-1238</title>
    <link href="/2020/02/07/HDU-1238/"/>
    <url>/2020/02/07/HDU-1238/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU-1238 Substrings</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-1238#author=organicsalt" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1238#author=organicsalt</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给n个字符串，问是否存在一个子串(或将该子串reverse)为所有字符串的子串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>将第一个字符串的所有子串与其余子串匹配一遍，如果有一个匹配失败，就将该子串reverse再匹配。这里使用reverse会更快，用kmp加速。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;int n,T,Next[maxn],len1,len2;string s[105],s2;void next_pre(int len){    int i=0,j=1;Next[0]=-1;    while(j&lt;len)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int next_work(int opt,int len){    int i=0,j=0;len2=s[opt].length();    while(i&lt;len2)    {        if(s2[j]==s[opt][i]||j==-1)i++,j++;        else j=Next[j];        if(j==len)        {            return 1;        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(Next,0,sizeof(Next));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];        len1=s[1].length();        for(int i=len1;i&gt;=0;i--)        {            int sign=0;            for(int l=0;l+i-1&lt;len1;l++)            {                int r=l+i-1;                s2=s[1].substr(l,i);                memset(Next,0,sizeof(Next));                next_pre(i);                sign=0;                for(int k=2;k&lt;=n;k++)                {                    int x1=next_work(k,i);                    if(x1==0)                    {                        reverse(s2.begin(),s2.end());                        memset(Next,0,sizeof(Next));                        next_pre(i);                        int x2=next_work(k,i);                        if(x2==0)                        {                            sign=1;                            break;                        }                    }                    else continue;                }                if(sign==0)                {                    printf(&quot;%d\n&quot;,i);                    break;                }            }            if(sign==0)            {                break;            }        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2328</title>
    <link href="/2020/02/07/HDU-2328/"/>
    <url>/2020/02/07/HDU-2328/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 2328 Corporate Identity</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2328" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2328</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求n个字符串的最长公共子串，若有多个则输出字典序最小的，若没有就输出“IDENTITY LOST”。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题就相当简单了，直接暴力枚举第一个字符串的所有子串，用kmp与所有别的字符串匹配，看它们是否都包含了这个子串，将符合条件的子串存进数组，在排序sort一下，输出第一个字符串即可。用到substr函数。<br>不过数据可能比较水，理论上时间复杂度是不够的，以为会TLE，结果可以过，甚至暴力都可以过。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=4000+5;int len1,len2,Next[maxn],n,ans;string s1[maxn],s2,Ans[maxn];void next_pre(int len){    int i=0,j=1;Next[0]=-1;    while(j&lt;len)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int next_work(int opt,int len){    int i=0,j=0;int len2=s1[opt].length();    while(i&lt;len2)    {        if(s1[opt][i]==s2[j]||j==-1)i++,j++;        else j=Next[j];        if(j==len)        {            return 1;        }    }    return 0;}int cmp(string x,string y){    return x&lt;y;}int main(){    while(1)    {        memset(Next,0,sizeof(Next));        ans=0;        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;s1[i];        len1=s1[1].length();        for(int l=len1;l&gt;=1;l--)        {            int sign=0;            for(int i=0;i+l-1&lt;len1;i++)            {                sign=0;                int r=i+l-1;                s2=s1[1].substr(i,l);                memset(Next,0,sizeof(Next));                next_pre(l);                for(int k=2;k&lt;=n;k++)                {                    int x=next_work(k,l);                    if(x==0)                    {                        sign=1;                        break;                    }                }                if(sign==0)                {                    ans++;                    Ans[ans]=s2;                }            }            if(ans)            break;        }        if(ans==0)        {            printf(&quot;IDENTITY LOST\n&quot;);            continue;        }        else         {            sort(Ans+1,Ans+1+ans,cmp);            cout&lt;&lt;Ans[1]&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3374</title>
    <link href="/2020/02/07/HDU-3374/"/>
    <url>/2020/02/07/HDU-3374/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3374 String Problem</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3374" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3374</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>对于一个字符串，它可以每次左移一次，得到一个新的字符串，因此一个长度为n的字符串，可以得到n个字符串。问，字典序最小的字符串排第几位，一共有多少个，字典序最大的字符串排第几位，一共有多少个<br>ps:如果最大和最小的有多个，输出最先出现的那个。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>求有多少个相同的字符串相对简单，并且运用到了kmp的知识，只有内部循环的字符串才可能会重复，对于这种字符串来讲它的循环节T= n-Next[n]，出现次数times=n/T。如何求最大字符串和最小字符串呢？这个就需要用到字符串的最小表示法和最大表示法。这里简单描述一下字符串的最小表示法，至于字符串的最大表示法，可以将最小表示法照搬修改即可。<br>字符串的最小表示法：<br>设定一个opt1和一个opt2与k。初始opt1=0，opt2=1，k=0，一开始指向s[0],s[1]<br>如果s[opt1+k]==s[opt2+k]，则k++.注意opt2+k可能越界，所以要对len取模。当k==len时，说明每一个字符串都恰好等于，没有字符串比当前的小。就直接返回min(opt1,opt2)<br>如果s[opt1+k]&gt;s[opt2+k],说明s[opt1…..opt1+k]之间的每个字符都不可能作为最小字符串的起始点.于是opt1滑至opt1+k+1，k=0.<br>如果s[opt1+k]&lt;s[opt2+k],说明s[opt2…..opt2+k]之间的每个字符都不可能作为最小字符串的起始点.于是opt2滑至opt2+k+1，k=0.<br>如果opt1==opt2，则让刚才修改过的opt++；<br>最后返回min(opt1,opt2)就可以了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int len1,len2,Next[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int get_min(){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len2&amp;&amp;opt2&lt;len2&amp;&amp;k&lt;len2)    {        if(s2[(opt1+k)%len2]==s2[(opt2+k)%len2])k++;        else if(s2[(opt1+k)%len2]&gt;s2[(opt2+k)%len2])        {            opt1=opt1+k+1,k=0;            if(opt1==opt2)                opt1++;        }        else if(s2[(opt1+k)%len2]&lt;s2[(opt2+k)%len2])        {            opt2=opt2+k+1,k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int get_max(){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len2&amp;&amp;opt2&lt;len2&amp;&amp;k&lt;len2)    {        if(s2[(opt1+k)%len2]==s2[(opt2+k)%len2])k++;        else if(s2[(opt1+k)%len2]&lt;s2[(opt2+k)%len2])        {            opt1=opt1+k+1,k=0;            if(opt1==opt2)                opt1++;        }        else if(s2[(opt1+k)%len2]&gt;s2[(opt2+k)%len2])        {            opt2=opt2+k+1,k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int main(){    while(scanf(&quot;%s&quot;,s2)!=EOF)    {        len2=strlen(s2);        memset(Next,0,sizeof(Next));        next_pre();        int T=len2-Next[len2];int times=0;        if(len2%T==0)        {            times=len2/T;        }        else             times=1;        int x1=get_min();        int x2=get_max();        printf(&quot;%d %d %d %d\n&quot;,x1+1,times,x2+1,times);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
      <tag>字符串的最小(大)表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2609</title>
    <link href="/2020/02/07/HDU-2609/"/>
    <url>/2020/02/07/HDU-2609/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 2609 How many</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-2609" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2609</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给n个字符串，每个字符串可以滑动形成新的字符串，问有多少个不同的字符串。<br>ps：若一个字符串滑动后与另一个字符串相同，则这两个字符串相同。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>先将每个字符串的最小表示法找到，然后用string数组储存字符串的最小表示法，然后sort排序，匹配找到总数</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10000+5;const int maxm=100+5;int len2,Next[maxn],len1,n;string s[maxn];char a[maxn][maxm];int cmp(string x,string y){    return x&lt;y;}int get_min(int opt){    int opt1=0,opt2=1,k=0;    while(opt1&lt;len1&amp;&amp;opt2&lt;len1&amp;&amp;k&lt;len1)    {        if(s[opt][(opt1+k)%len1]==s[opt][(opt2+k)%len1])k++;        else if(s[opt][(opt1+k)%len1]&gt;s[opt][(opt2+k)%len1])        {            opt1=opt1+k+1;k=0;            if(opt1==opt2)                opt1++;        }        else if(s[opt][(opt1+k)%len1]&lt;s[opt][(opt2+k)%len1])        {            opt2=opt2+k+1;k=0;            if(opt1==opt2)                opt2++;        }    }    return min(opt1,opt2);}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(a,0,sizeof(a));//char  与 string不同，必须清空！string s[i] 清空：s[i].clear();         for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];        for(int i=1;i&lt;=n;i++)        {            len1=s[i].length();            int x=get_min(i);            int opt=0;            while(opt&lt;len1)            {                a[i][opt]=s[i][(x+opt)%len1];                opt++;            }        }        for(int i=1;i&lt;=n;i++)s[i]=a[i];        sort(s+1,s+1+n,cmp);        int ans=1;        for(int i=2;i&lt;=n;i++)        {            if(s[i]!=s[i-1])ans++;        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>字符串的最小(大)表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FZU-1901</title>
    <link href="/2020/02/07/FZU-1901/"/>
    <url>/2020/02/07/FZU-1901/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>FZU - 1901 Period II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/FZU-1901" target="_blank" rel="noopener">https://vjudge.net/problem/FZU-1901</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>对于一个正整数p，p&lt;=字符串的长度，使得任意的s[i]==s[i+p]，求出所有符合要求的p。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这个题和之前的某个题意很迷的密码题有点相似，那个题当时就是用的ex-kmp，做这个题开始时题意不理解，百度了一下题意。一开始想的就是用kmp，似乎网上用kmp的很多，但我一下子不知道如何运行Next，不过，我突然发现，令s2=s1，用s1的所有后缀匹配s2的结果让我意外，所有符合Extend[i]+i&gt;=len的都是p，当然len本身也是。很显然这个题可以用ex-kmp来做。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int T,len1,len2,Next[maxn],Extend[maxn],Ans[maxn];string s1,s2;//s1的所有后缀与s2匹配 void next_pre(){    int i=0,po=0;    while(s2[i]==s2[i+1]&amp;&amp;i+1&lt;len2)i++;    Next[0]=len2;Next[1]=i;po=1;    for(int i=2;i&lt;len2;i++)    {        if(Next[i-po]+i&lt;Next[po]+po)            Next[i]=Next[i-po];        else         {            int j=Next[po]+po-i;            if(j&lt;0)j=0;            while(s2[j+i]==s2[j]&amp;&amp;i+j&lt;len2)j++;            Next[i]=j;            po=i;        }    }} void extend_pre(){    int i=0,po=0;    while(s1[i]==s2[i]&amp;&amp;i&lt;len2&amp;&amp;i&lt;len1)i++;    Extend[0]=i;    for(int i=1;i&lt;len1;i++)    {        if(Next[i-po]+i&lt;Extend[po]+po)            Extend[i]=Next[i-po];        else         {            int j=Extend[po]+po-i;            if(j&lt;0)j=0;            while(s1[j+i]==s2[j]&amp;&amp;i+j&lt;len1&amp;&amp;j&lt;len2)j++;            Extend[i]=j;            po=i;        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);int now=0;    while(now&lt;T)    {        now++;        memset(Next,0,sizeof(Next));        memset(Extend,0,sizeof(Extend));        memset(Ans,0,sizeof(Ans));        cin&gt;&gt;s2;s1=s2;        len2=s2.length();len1=s1.length();        next_pre();        extend_pre();        int opt=0,res=0;int ans=0;        for(int i=0;i&lt;len2;i++)        {            if(Extend[i]+i&gt;=len2&amp;&amp;i!=0)            {                Ans[++ans]=i;            }            }        Ans[++ans]=len2;        printf(&quot;Case #%d: %d\n&quot;,now,ans);        for(int i=1;i&lt;ans;i++)printf(&quot;%d &quot;,Ans[i]);printf(&quot;%d\n&quot;,Ans[ans]);    }    return 0;}//注意数组不能太大，容易TLE //一开始找到第一个Extend[i]+i&gt;=len2就以为找到循环节了，实际上有问题。要线性枚举一遍才行！ </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ex-kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3068</title>
    <link href="/2020/02/07/HDU-3068/"/>
    <url>/2020/02/07/HDU-3068/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3068 最长回文</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3068" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3068</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求多组数据的最长回文的长度，就是Manacher的模板题</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>讲解一下Manacher算法<br>首先该算法的时间复杂度为O(N)，一个长度为len的字符串，len可能为奇数，也可能是偶数，那么中间点就不一样了，那对于长度L=2len+1呢？<br>显然它一定是奇数。具体操作为：<br>t[0]=’$’;<br>for(int i=1;i&lt;=len;i++)t[++len]=’#’,t[++len]=s[i-1];<br>t[++len]=’#’;<br>比如字符串 abccba 就转换成了 $#a#b#c#c#b#a#;</p><p>以上是初始化的过程，接下来是具体的操作过程：<br>对于p[i]，如果i&lt;mx，设j是i关于id对称点，如图所示，则基于以下三种情况，可以求出p[i]的值：</p><p>（1）以j为中心的回文串有一部分在以id为中心的回文串之外。因为mx是以id为中心的最长回文的右边界，所以以i为中心的回文串不可能会有字符在以id为中心的回文串之外；否则mx就不是以id为中心的最长回文的右边界。所以，在这种情况下，p[i]=mx–i。<br>具体阐释一下：此时s[id,id+1,…i-1,i]=s[id,id-1,…,j+1,j]，假如以i为中心的回文串有字符在以id为中心的回文串之外，显然mx不应该为右边界！</p><p>（2）以j为中心的回文串全部在以id为中心的回文串的内部，则p[i]=p[j]，而且p[i]不可能再增加。</p><p>（3）以j为中心的回文串的左端正好与以id为中心的回文串的左端重合。则p[i]=p[j]或p[i]=mx–i，并且p[i]还有可能会继续增加，即while (s_new[i-p[i]]==s_new[i+p[i]]) p[i]++;</p><p>所以，if (i &lt; mx) p[i] = min(p[2 * id - i], mx- i)；其中2*id - i为i关于id的对称点，即上面的j点，而p[j]表示以j为中心的最长回文半径，因此可以利用p[j]来加快求解p[i]。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=110000*2+100;char s[maxn],t[maxn];int len,p[maxn];int main(){    while(scanf(&quot;%s&quot;,s)!=EOF)    {        len=0;memset(p,0,sizeof(p));        memset(t,0,sizeof(t));        int L=strlen(s),ans=0;        t[0]=&#39;$&#39;;        for(int i=1;i&lt;=L;i++)        {            t[++len]=&#39;#&#39;;t[++len]=s[i-1];        }        t[++len]=&#39;#&#39;;        int id=0,mx=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]])p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;            }            ans=max(ans,p[i]-1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4513</title>
    <link href="/2020/02/07/HDU-4513/"/>
    <url>/2020/02/07/HDU-4513/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4513 吉哥系列故事——完美队形II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4513#author=hzoi2017_wty" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4513#author=hzoi2017_wty</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>假设有n个人按顺序的身高分别是h[1], h[2] … h[n]，从中挑出一些人形成一个新的队形，新的队形若满足以下要求，则就是新的完美队形：<br>　　1、连续的<br>　　2、形成回文串<br>　　3、从左到中间那个人，身高需保证不下降</p><p>　　　问有组成完美队形的最多人数</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>要求连续的并且是回文串，这很明显就是回文串的题，应该用Manacher算法，但是又要求从左到中间，身高不下降，就需要修改一下判定条件：    while(t[i+p[i]]==t[i-p[i]]&amp;&amp;(t[i-p[i]]==0||t[i-p[i]]&lt;=t[i-p[i]+2]))p[i]++;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000*2+15;int T,n,p[maxn],s[maxn],t[maxn];int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        memset(p,0,sizeof(p));        memset(t,0,sizeof(t));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;s[i]);        int len=0;        t[0]=10000;        for(int i=1;i&lt;=n;i++)        {            t[++len]=0;t[++len]=s[i];        }        t[++len]=0;        int id=0,mx=0,ans=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]]&amp;&amp;(t[i-p[i]]==0||t[i-p[i]]&lt;=t[i-p[i]+2]))p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;            }            ans=max(ans,p[i]-1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3294</title>
    <link href="/2020/02/07/HDU-3294/"/>
    <url>/2020/02/07/HDU-3294/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3294 Girls’ research</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3294#author=asasas5d" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3294#author=asasas5d</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>先给一个字符x，然后给一个 字符串，表示字符串中所有字符x变成’a’，其余的字符依次往前变换。例如b babad就转换成azazc。让寻找第一个最长回文串，长度若小于2，则输出No solution!，否则输出起点，终点和转换后的最长回文串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最长回文串问题，当然就是用Manacher，先计算出字符x与‘a’的差值，然后将字符串进行转换。然后直接跑Manacher，更新ans时注意更新储存一下终点和起点</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200000*2+105;int p[maxn],len,a[maxn],S,T;char s[maxn],t[maxn],x[3];int main(){    while(scanf(&quot;%s&quot;,x)!=EOF)    {        len=0;S=0;T=0;        scanf(&quot;%s&quot;,&amp;s);        int delt=x[0]-&#39;a&#39;;        int L=strlen(s);        for(int i=0;i&lt;L;i++)        {            a[i]=s[i]-&#39;a&#39;-delt;            if(a[i]&lt;0)a[i]+=26;            s[i]=a[i]+&#39;a&#39;;        }        t[0]=&#39;$&#39;;        for(int i=1;i&lt;=L;i++)        {            t[++len]=&#39;#&#39;;t[++len]=s[i-1];        }        t[++len]=&#39;#&#39;;        int mx=0,id=0,ans=0;        for(int i=1;i&lt;=len;i++)        {            if(i&lt;mx)p[i]=min(p[id*2-i],mx-i);            else p[i]=1;            while(t[i+p[i]]==t[i-p[i]])p[i]++;            if(i+p[i]&gt;mx)            {                mx=i+p[i];                id=i;                if(ans&lt;p[i]-1)                {                    ans=p[i]-1;                    T=(mx-1)/2;                    S=T-ans+1;                    T--;S--;                }            }        }        if(ans&lt;2)        {            printf(&quot;No solution!\n&quot;);        }        else         {            printf(&quot;%d %d\n&quot;,S,T);            for(int i=S;i&lt;=T;i++)            printf(&quot;%c&quot;,s[i]);cout&lt;&lt;endl;        }    }    return 0;}</code></pre><p>//注意读入时要！=EOF，否则TLE</p>]]></content>
    
    
    
    <tags>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4763</title>
    <link href="/2020/02/07/HDU-4763/"/>
    <url>/2020/02/07/HDU-4763/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4763 Theme Section</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4763#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4763#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>字符串E是字符串S的前缀和后缀，同时也出现在字符串S的中间，不与前缀后缀重合，问字符串S中符合要求的字符串E的最大长度。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这题显示是kmp问题，kmp中Next[i]表示字符串s从0…..i-1中前缀与后缀的最大公共子串，而问题就是求EAEBE，A，B长度任意(可以为0)，显然E最长为Next[len]，于是可以从len-Next[len]开始往前看Next[now]与E的大小关系，now&gt;=2*E，因为不可以重叠，如果找不到呢，E就应该缩小，理论是E–，所以E=Next[E]，继续寻找，直到找到或者无法继续。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5;int n,len1,len2,Next[maxn];char s1[maxn],s2[maxn];void next_pre(){    int i=0,j=1;Next[0]=-1;    while(j&lt;len2)    {        while(Next[i]!=-1&amp;&amp;s2[i]!=s2[j])i=Next[i];        if(s2[i]==s2[j])Next[j+1]=i+1,i++;        j++;    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        memset(Next,0,sizeof(Next));        scanf(&quot;%s&quot;,s2);        len2=strlen(s2);        next_pre();        int L=Next[len2];        int sign=0;        while(L)        {            int now=len2-L;            while(Next[now]==0&amp;&amp;now&gt;=2*L)now--;            while(now&gt;=2*L)            {                if(Next[now]&gt;=L)                {                    break;                }                else now--;            }            if(Next[now]&gt;=L&amp;&amp;now&gt;=2*L)            {                sign=1;                printf(&quot;%d\n&quot;,L);                break;            }            L=Next[L];        }        if(sign==0)        {            printf(&quot;0\n&quot;);            continue;        }    }    return 0;}</code></pre><p>//注意要判定now&gt;=2*L！</p>]]></content>
    
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2387</title>
    <link href="/2020/02/07/POJ-2387/"/>
    <url>/2020/02/07/POJ-2387/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2387 Til the Cows Come Home</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2387#author=ght5160" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2387#author=ght5160</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求从1到n的最短距离</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最短路模板，spfa或者dijkstra+堆优化。<br>朴素Dijkstra：时间复杂度o(n^2)<br>堆优化Dijkstra：时间复杂度o(（V+E）logV）</p><p>spfa在稀疏图O（E），稠密图O（VE）</p><p>dijkstra+堆优化的代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=2000+5;int n,m,k=1,dist[maxn],vis[maxn],head[maxn];struct node{    int to,next,w;}edge[maxn*2];struct N{    int now,w;    bool operator &lt; (N x)const{return x.w&lt;w;}};void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(!vis[edge[i].to]&amp;&amp;dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);add(a,b,c);add(b,a,c);    }    dijkstra();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre><p>spfa的代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=2000+5;int n,m,k=1,head[maxn],dist[maxn],vis[maxn]; struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(){    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    queue&lt;int&gt;q;    dist[1]=0;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    q.push(edge[i].to);                    vis[edge[i].to]=1;                }            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);add(a,b,c);add(b,a,c);    }    spfa();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2253</title>
    <link href="/2020/02/07/POJ-2253/"/>
    <url>/2020/02/07/POJ-2253/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2253 Frogger</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2253#author=dusenlin" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2253#author=dusenlin</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>两块石头之间的青蛙距离被定义为两块石头之间所有可能路径上的最小必要跳跃距离，某条路径的必要跳跃距离即这条路径中单次跳跃的最远跳跃距离。求1到2的最小必要跳跃距离。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>数据很小，符合Floyd算法。每一次更新的时候需要调整一下：<br>dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));<br>因为必要跳跃距离是指整个路径单次跳跃的最远距离，所以取max</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn=200+5;int n;double dist[maxn][maxn],x[maxn],y[maxn];int main(){    int opt=0;    while(1)    {        opt++;        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                dist[i][j]=0x3f3f3f3f;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(i!=j)                dist[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));            }        }        for(int k=1;k&lt;=n;k++)        {            for(int i=1;i&lt;=n;i++)            {                for(int j=1;j&lt;=n;j++)                {                    dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));                }            }            }        printf(&quot;Scenario #%d\n&quot;,opt);        printf(&quot;Frog Distance = %.3lf\n&quot;,dist[1][2]);        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1797</title>
    <link href="/2020/02/07/POJ-1797/"/>
    <url>/2020/02/07/POJ-1797/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1797 Heavy Transportation</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1797#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1797#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>求1-n路径上边权最小值最大。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最短路径的变形题，用spfa来实现<br>原本的dist[edge[i].to]=min(dist[edge[i].to],dist[x]+edge[i].w)<br>修改为dist[edge[i].to]=max(dist[edge[i].to],min(dist[x],edge[i].w)<br>注意初始化dist全为0，由于收缩，dist[1] =0x3f3f3f3f;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000000+5;const int maxm=1000+5;int k=1,T,n,m,head[maxm],vis[maxm],dist[maxm];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    dist[1]=0x3f3f3f3f;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;min(dist[x],edge[i].w))            {                dist[edge[i].to]=min(dist[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);int opt=0;    while(T--)    {        opt++;        memset(head,0,sizeof(head));        k=1;memset(edge,0,sizeof(edge));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,c);        }        spfa();        printf(&quot;Scenario #%d:\n&quot;,opt);        printf(&quot;%d\n\n&quot;,dist[n]);    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3268</title>
    <link href="/2020/02/07/POJ-3268/"/>
    <url>/2020/02/07/POJ-3268/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3268 Silver Cow Party</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3268#author=Demon_de_Laplace" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3268#author=Demon_de_Laplace</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>N头牛，M条单行道，在s出举行聚会，每头牛出发和返回都是走最短路，问所有牛中走的路程最远的牛走了多远？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>建边的时候建双向边，k=2开始.<br>当边号为偶数时，说明是正边；<br>当边号为奇数时，说明时反边；<br>从s出发，跑正边，dist[i]存的是从s到i的最短距离；<br>从s出发，跑反边，dist[i]存的是从i到s的最短距离；<br>ans=max(ans,dist1[i]+dist2[i])</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int n,m,t,k=1,head[maxn],vis[maxn],dist1[maxn],dist2[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa1(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist1,0x3f3f3f3f,sizeof(dist1));    vis[t]=1;dist1[t]=0;    q.push(t);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(i%2==1)continue;            if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)            {                dist1[edge[i].to]=dist1[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void spfa2(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist2,0x3f3f3f3f,sizeof(dist2));    vis[t]=1;dist2[t]=0;    q.push(t);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(i%2==0)continue;            if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)            {                dist2[edge[i].to]=dist2[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);add(b,a,c);    }    spfa1();spfa2();    int ans=0;    for(int i=1;i&lt;=n;i++)    {        ans=max(ans,dist1[i]+dist2[i]);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1860</title>
    <link href="/2020/02/07/POJ-1860/"/>
    <url>/2020/02/07/POJ-1860/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1860 Currency Exchange</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1860#author=riba2534" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1860#author=riba2534</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出每两种货币之间交换的手续费和汇率，求出从当前货币s开始交换，能否赚。能赚输出YES，否则输出NO</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>运用spfa判断是否存在存在正环(类似于判负环)。和判负环一样，记录一下点出现的次数，一旦出现此次数&gt;n就可以作出判断。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10000+5;int n,m,s,k=1,head[maxn],vis[maxn],used[maxn];double w,dist[maxn];struct node{    int to,next;double w,q;}edge[maxn*2];void add(int u,int v,double q,double w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].q=q;}int spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    dist[s]=w;vis[s]=1;used[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;(dist[x]-edge[i].w)*edge[i].q)            {                dist[edge[i].to]=(dist[x]-edge[i].w)*edge[i].q;                if(!vis[edge[i].to])                {                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d%lf&quot;,&amp;n,&amp;m,&amp;s,&amp;w);    for(int i=1;i&lt;=m;i++)    {        int a,b;double w1,w2,q1,q2;        scanf(&quot;%d%d%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;q1,&amp;w1,&amp;q2,&amp;w2);        add(a,b,q1,w1);add(b,a,q2,w2);    }    int x=spfa();    if(x==1)printf(&quot;YES\n&quot;);    else printf(&quot;NO\n&quot;);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3259</title>
    <link href="/2020/02/07/POJ-3259/"/>
    <url>/2020/02/07/POJ-3259/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3259 Wormholes</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3259#author=chen_zhe" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3259#author=chen_zhe</a>_</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个教室，m条走廊(双向)，w条密道(单向)。走廊耗时&gt;0，密道可耗时&lt;0，问是否可以回到过去。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>密道耗时&lt;0，再根据题目要求，就是问该图是否存在负环。由于这是一个连通图，从哪个点出发效果都一样，不妨从1开始出发，判断是否存在负环，判断方法：每次进行收缩时记录次数++，一旦超过了n就可以作出判断。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=50000+5;int k=1,T,n,m,w,head[maxn],vis[maxn],dist[maxn],used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int spfa(){    queue&lt;int&gt;q;    memset(used,0,sizeof(used));    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    vis[1]=1;dist[1]=0;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;w);        for(int i=1;i&lt;=m;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,c);        }        for(int i=1;i&lt;=w;i++)        {            int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,-c);        }        int x=spfa();        if(x==1)printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1502</title>
    <link href="/2020/02/07/POJ-1502/"/>
    <url>/2020/02/07/POJ-1502/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1502 MPI Maelstrom</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1502#author=20175101008" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1502#author=20175101008</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出a[i][j]之间的值，若a[i][j]==’x’说明i，j之间不通，问从1开始同时向2…..n传递信息，需要多久全部结点都收到？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=100，显然可以用Floyd算法，读入时字符串读入，加以处理，得到a[i][j]之间的距离，i，j不通则将长度设为无穷大，然后开始跑Floyd，最后统计dist[1][i],i∈[2,n]的最大值，该值为答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200+5;int n,a[maxn][maxn],dist[maxn][maxn];int main(){    memset(dist,0x3f3f3f3f,sizeof(dist));    scanf(&quot;%d&quot;,&amp;n);    char x[10];    for(int i=2;i&lt;=n;i++)    {        for(int j=1;j&lt;i;j++)        {            scanf(&quot;%s&quot;,x);            if(x[0]==&#39;x&#39;)a[j][i]=a[i][j]=0x3f3f3f3f;            else             {                int sum=0;                for(int k=0;k&lt;=strlen(x)-1;k++)                {                    sum=sum*10+x[k]-&#39;0&#39;;                }                a[j][i]=a[i][j]=sum;            }        }    }    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            if(i==j)dist[i][j]=0;            else dist[i][j]=a[i][j];        }    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);            }        }    }    int ans=0;    for(int i=2;i&lt;=n;i++)    ans=max(ans,dist[1][i]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3660</title>
    <link href="/2020/02/07/POJ-3660/"/>
    <url>/2020/02/07/POJ-3660/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3660 Cow Contest</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3660#author=arasHi" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3660#author=arasHi</a>_</p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n头牛，m条比赛结果，每行两个数字，第一个数字表示的是胜利者。<br>问有几头牛的排名可以确定？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>排名可以确定，这该如何理解？对于结点i，如果箭头指向i所包含的结点数为ans1，i箭头指出所包含的结点数为ans2，若ans1+ans2==n-1就说明结点i的排名可以确定。问题在于如何确定ans1，ans2的值。<br>举个例子：若a可以到b，b可以到c，那么a就可以到c。这就是传递闭包了。<br><img src="https://img-blog.csdn.net/20170409190428811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3MTM3NjEyNDA2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt=""><br>如何进行传递闭包呢？以上例子，a可以到b，b可以到c，则dist[a][b]=1,dist[b][c]=1,则a可以到c，即dist[a][c]=1；用floyd进行收缩即可。然后每个结点是否可以到达剩余的n-1个结点，或者剩余n-1个结点能否到达该结点，即ans1+ans2==n。判断条件就是dist[i][j]==1||dist[j][i]==1;</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int n,m,dist[maxn][maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=m;i++)    {        int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        dist[a][b]=1;    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(dist[i][k]==1&amp;&amp;dist[k][j]==1)                dist[i][j]=1;            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)    {        int sign=0;        for(int j=1;j&lt;=n;j++)        {            if(i==j)continue;            if(dist[i][j]||dist[j][i])continue;            else sign=1;        }        if(sign==0)ans++;    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>闭包传递</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2240</title>
    <link href="/2020/02/07/POJ-2240/"/>
    <url>/2020/02/07/POJ-2240/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2240 Arbitrage</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2240#author=Andy_acmer" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2240#author=Andy_acmer</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n种货币，m条货币的汇率关系。比如：USDollar 0.5 BritishPound<br>说明1个USDollar货币，可以换成0.5个BritishPound货币，问是否可以通过这种关系来获利。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>由于货币名字使字符串，那么用map比较方便,map&lt;string,int&gt;q，可以将字符串映射成int型。然后跑spfa，看是否存在正环，与判断负环的方法一样。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;const int maxn=10000+5;int n,m,head[maxn],vis[maxn],used[maxn],k=1;double dist[maxn];map&lt;string,int&gt;q;struct node{    int to,next;double w;}edge[maxn*2];void add(int u,int v,double w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;    }int spfa(){    queue&lt;int&gt;q;    memset(dist,0,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    vis[1]=1;used[1]=1;dist[1]=1.0;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&lt;dist[x]*edge[i].w)            {                dist[edge[i].to]=dist[x]*edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    int now=0;    while(1)    {        now++;        k=1;memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        q.clear();        scanf(&quot;%d&quot;,&amp;n);        if(n==0)break;        int tot=0;        for(int i=1;i&lt;=n;i++)        {            string x;cin&gt;&gt;x;            q[x]=++tot;            }                scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            string a,b;double c;            cin&gt;&gt;a&gt;&gt;c&gt;&gt;b;            add(q[a],q[b],c);        }        int x=spfa();        printf(&quot;Case %d: &quot;,now);        if(x==1)printf(&quot;Yes\n&quot;);        else printf(&quot;No\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>判环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1511</title>
    <link href="/2020/02/07/POJ-1511/"/>
    <url>/2020/02/07/POJ-1511/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1511 Invitation Cards</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1511#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1511#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>n-1个人从1号点出发，到剩余n-1个宣传点，然后再回到1号点汇报结果，求所有人往返路径和的最小值。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>m条边，边号为偶数的表示正方向，边号为奇数的表示反方向。spfa1()沿着正方向跑，起点为1，则dist[i]表示的是从1到i的最短距离。spfa2()沿着反方向跑，起点为1，则dist2[i]表示的是从i到1的最短距离。最终答案就是dist1[i]+dist2[i]的总和，i∈[2,n]。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">    #include&lt;cstdio&gt;    #include&lt;cstring&gt;    #include&lt;iostream&gt;    #include&lt;algorithm&gt;    #include&lt;queue&gt;    using namespace std;    const long long maxn=1000000+5;    struct node    {        long long to,next,w;    }edge[maxn*2];    long long k=1,head[maxn],vis[maxn],dist1[maxn],dist2[maxn],T,n,m;    void add(long long u,long long v,long long w)    {        edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;    }    void spfa1()//1到其余所有点     {        queue&lt;long long&gt;q;        memset(vis,0,sizeof(vis));        memset(dist1,0x3f3f3f3f,sizeof(dist1));        dist1[1]=0;vis[1]=1;        q.push(1);        while(!q.empty())        {            long long x=q.front();q.pop();vis[x]=0;            for(long long i=head[x];i;i=edge[i].next)            {                if(i%2==1)continue;                if(dist1[edge[i].to]&gt;dist1[x]+edge[i].w)                {                    dist1[edge[i].to]=dist1[x]+edge[i].w;                    if(!vis[edge[i].to])                    {                        vis[edge[i].to]=1;                        q.push(edge[i].to);                    }                }            }        }    }    void spfa2()//其余所有点到1；     {        queue&lt;long long&gt;q;        memset(vis,0,sizeof(vis));        memset(dist2,0x3f3f3f3f,sizeof(dist2));        dist2[1]=0;vis[1]=1;        q.push(1);        while(!q.empty())        {            long long x=q.front();q.pop();vis[x]=0;            for(long long i=head[x];i;i=edge[i].next)            {                if(i%2==0)continue;                if(dist2[edge[i].to]&gt;dist2[x]+edge[i].w)                {                    dist2[edge[i].to]=dist2[x]+edge[i].w;                    if(!vis[edge[i].to])                    {                        vis[edge[i].to]=1;                        q.push(edge[i].to);                    }                }            }        }    }    int main()    {        scanf(&quot;%lld&quot;,&amp;T);        while(T--)        {            k=1;            memset(head,0,sizeof(head));            memset(edge,0,sizeof(edge));            scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);            for(long long i=1;i&lt;=m;i++)            {                long long a,b,c;                scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);                add(a,b,c);add(b,a,c);            }            spfa1();             spfa2();            long long ans=0;            for(long long i=2;i&lt;=n;i++)            {                ans+=dist1[i]+dist2[i];                }                printf(&quot;%lld\n&quot;,ans);        }        return 0;    }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3159</title>
    <link href="/2020/02/07/POJ-3159/"/>
    <url>/2020/02/07/POJ-3159/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3159 Candies</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3159#author=2018112767" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3159#author=2018112767</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个同学，m条信息，每条信息为a,b,c三个整数表示a相信b的糖果不会比自己多于c。问n同学最多比1同学多多少个糖果？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是差分约束的题目，由题知Have[b]-Have[a]&lt;=c;即<br>Have[b]&lt;=c+Have[a]；而最短路的更新条件是dist[edge[i].to]&gt;dist[x]+edge[i].w，就说明了dist[edge[i].to]&lt;=dist[x]+edge[i].w;于是建边就可以a—&gt;b,边权为c，跑最短路。dist[n]就是答案</p><p>ps：一开始跑spfa，TLE，此图有点稠密，用dijkstra+堆优化更保险！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=150000+5;struct node{    int to,next,w;}edge[maxn*2];int k=1,head[maxn],vis[maxn],dist[maxn],n,m;void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}struct N{    int now,w;    bool operator &lt; (N x) const{return x.w&lt;w;}};void spfa(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;vis[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=m;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);    }    dijkstra();    printf(&quot;%d\n&quot;,dist[n]);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>差分约束</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2502</title>
    <link href="/2020/02/07/POJ-2502/"/>
    <url>/2020/02/07/POJ-2502/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2502 Subway</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2502#author=1738160864" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2502#author=1738160864</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>小k要从家去学校，他可以选择步行或者地铁，步行的速度是10km/h，地铁的速度是40km/h。假设小k非常的幸运，每次他到地铁站就立刻会有地铁。小k可以随意上下地铁，并且可以在地铁线路之间转换。所有的地铁运行都是双向的。<br>注意地铁站不会重复出现。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=200，所以可以用Floyd。每次出现的新地铁站，先与起点更新时间花费，此时速度为v1，然后输入地铁线，此时速度为v2，可以更新相邻地铁站之间的时间花费，并且更新起点与地铁站之间的时间花费，此时速度为v1。最后地铁站输入完之后，tot++，这就是终点编号，所有结点与终点的时间花费需要更新。然后开始跑Floyd。最后dist[0][tot]储存答案，需要四舍五入，即int ans=dist[0][tot]+0.5;ans为最终答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int maxn=200+5;double v1=10*1000/60;double v2=40*1000/60;double dist[maxn][maxn],a[maxn][maxn],x[maxn],y[maxn],sx,sy,tx,ty;int main(){    int tot=1;int s=0;    memset(a,0x7f7f7f7f,sizeof(a));    memset(dist,0x7f7f7f7f,sizeof(dist));    scanf(&quot;%lf%lf%lf%lf&quot;,&amp;sx,&amp;sy,&amp;tx,&amp;ty);    while(scanf(&quot;%lf%lf&quot;,&amp;x[tot],&amp;y[tot])!=EOF)    {        a[tot][0]=a[0][tot]=sqrt((sx-x[tot])*(sx-x[tot])+(sy-y[tot])*(sy-y[tot]))/v1;        while(1)        {            tot++;            scanf(&quot;%lf%lf&quot;,&amp;x[tot],&amp;y[tot]);            if(x[tot]==-1&amp;&amp;y[tot]==-1)            {                break;            }            a[tot][tot-1]=a[tot-1][tot]=sqrt((x[tot]-x[tot-1])*(x[tot]-x[tot-1])+(y[tot]-y[tot-1])*(y[tot]-y[tot-1]))/v2;            a[tot][0]=a[0][tot]=sqrt((sx-x[tot])*(sx-x[tot])+(sy-y[tot])*(sy-y[tot]))/v1;                    }    }        for(int i=1;i&lt;=tot;i++)        {            for(int j=1;j&lt;=tot;j++)            {                a[i][j]=a[j][i]=min(a[i][j],sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))/v1);            }        }        tot++;        a[0][tot]=a[tot][0]=sqrt((sx-tx)*(sx-tx)+(sy-ty)*(sy-ty))/v1;        for(int i=1;i&lt;tot;i++)        {            a[i][tot]=a[tot][i]=sqrt((x[i]-tx)*(x[i]-tx)+(y[i]-ty)*(y[i]-ty))/v1;        }        for(int i=0;i&lt;=tot;i++)        {            for(int j=0;j&lt;=tot;j++)            {                dist[i][j]=a[i][j];            }        }        for(int k=0;k&lt;=tot;k++)        {            for(int i=0;i&lt;=tot;i++)            {                for(int j=0;j&lt;=tot;j++)                {                    dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);                }            }        }        int ans=dist[0][tot]+0.5;        printf(&quot;%d\n&quot;,ans);        return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1062</title>
    <link href="/2020/02/07/POJ-1062/"/>
    <url>/2020/02/07/POJ-1062/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1062 昂贵的聘礼</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1062#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1062#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>一个人要买1号物品，而此物品可以通过直接购买或者到别人的手中买别的东西+一些金币来得到。但是需要注意：如果两人地位等级差距超过了delt，就不可以进行间接交易，即该交易圈的人两两之间等级差异不可大于delt。问要得到1号物品至少要花费多少钱？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>建立一个源点，它与所有物品建边，即s–&gt;i（边权为物品原价），因为每个物品除了直接购买，还可以间接购买，设间接购买物品为j，则建边方式为j–&gt;i（边权为额外金币）然后跑最短路，注意最短路的条件不再是dist[edge[i].to]&gt;dist[x]+edge[i].w，因为当价格相等时也需要进入队列来进行松弛，所以应变为dist[edge[i].to]&gt;dist[x]+edge[i].w;然后就是等级限制的判断了。刚开始的s的等级需要从最低到最高都设置一次，意味着跑n次spfa，s就是这次spfa的最低等级，因此a[edge[i].to].l&gt;=limit&amp;&amp;edge[i].to]-limit&lt;=delt||x==0||delt==0；delt==0意味着没有等级限制。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int n,delt,head[maxn],vis[maxn],dist[maxn],k=1,liv[maxn],ans=0x3f3f3f3f;struct Node{    int p,l,x;}a[maxn];struct node{    int next,to,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void spfa(int limit){    queue&lt;int&gt;q;    for(int i=1;i&lt;=n;i++)dist[i]=a[i].p;    memset(vis,0,sizeof(vis));    vis[0]=1;dist[0]=0;    q.push(0);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;=dist[x]+edge[i].w&amp;&amp;(delt==0||(a[edge[i].to].l&gt;=limit&amp;&amp;a[edge[i].to].l-limit&lt;=delt)))            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }        }    ans=min(ans,dist[1]);}int main(){    scanf(&quot;%d%d&quot;,&amp;delt,&amp;n);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d%d%d&quot;,&amp;a[i].p,&amp;a[i].l,&amp;a[i].x);        liv[i]=a[i].l;        add(0,i,a[i].p);        for(int j=1;j&lt;=a[i].x;j++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            add(x,i,y);        }    }    sort(liv+1,liv+1+n);    for(int i=1;i&lt;=n;i++)    spfa(liv[i]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1847</title>
    <link href="/2020/02/07/POJ-1847/"/>
    <url>/2020/02/07/POJ-1847/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1847 Tram</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1847" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1847</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>输入n,a,b三个数，表示有n个点(1-n)，起点是a，终点是b，然后接下来有n行，每一行的第一个数m表示后面将会有m个数，输入结构是这样的，然后我再具体的解释一下。</p><p>3 2 1     3表示共有n个点，接下来有n行，2表示起点，1表示终点<br>2 2 3     第一个数2表示后面有2个数，因为这是第1行，所以后面两个数表示从1到2和从1到3的边<br>2 3 1     表示从2到3和从2到1的边<br>2 1 2     表示从3到1和从3到2的边</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n&lt;=100，可以跑Floyd，dist初始化无穷大，每个结点所连接的第一个结点与它的距离为0，其余相连的为1，然后跑Floyd。dist[s][t]为最终的结果。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100+5;int n,s,t,dist[maxn][maxn];int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;s,&amp;t);    memset(dist,0x3f3f3f3f,sizeof(dist));    for(int i=1;i&lt;=n;i++)    {        int m;        scanf(&quot;%d&quot;,&amp;m);        for(int j=1;j&lt;=m;j++)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            if(j==1)            {                dist[i][x]=0;            }            else             {                dist[i][x]=1;            }        }    }    for(int k=1;k&lt;=n;k++)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);            }        }    }    if(dist[s][t]&lt;0x3f3f3f3f)    printf(&quot;%d\n&quot;,dist[s][t]);    else     printf(&quot;-1\n&quot;);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LightOJ1074</title>
    <link href="/2020/02/07/LightOJ-1074/"/>
    <url>/2020/02/07/LightOJ-1074/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>LightOJ - 1074 Extended Traffic</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/LightOJ-1074#author=bbisnouse" target="_blank" rel="noopener">https://vjudge.net/problem/LightOJ-1074#author=bbisnouse</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在一个堵车的城市中, 每个路口都有一个拥挤程度a[i], 从u驶向v得到一个数量, 值为(a[v]-a[u])^3, 给出Q组查询, 每组给出一个数, 求1到这个数的点的最小数量, 如果不可达输出 ？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始觉得n很小，可以直接跑floyd，但是后来WA了两发，发现可能存在负环，所以需要判断负环，因此选择spfa，一旦判断出了负环就dfs，找到负环可以达到的所有点。对于查询一一输出结果即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200005;int n,T,a[maxn],head[maxn],vis[maxn],dist[maxn],k=1,used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dfs(int x){    if(vis[x])return ;    vis[x]=1;dist[x]=0x3f3f3f3f;    for(int i=head[x];i;i=edge[i].next)    {        dfs(edge[i].to);    }}void spfa(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(used,0,sizeof(used));    dist[1]=0;vis[1]=1;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)                    {                        memset(vis,0,sizeof(vis));                        dfs(edge[i].to);                        return ;                    }                    q.push(edge[i].to);                }            }        }    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=0;    while(T--)    {        opt++;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(a,0,sizeof(a));        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);        int m;        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            int w=(a[y]-a[x])*(a[y]-a[x])*(a[y]-a[x]);            add(x,y,w);        }        spfa();        int p;        scanf(&quot;%d&quot;,&amp;p);        printf(&quot;Case %d:\n&quot;,opt);        for(int i=1;i&lt;=p;i++)        {            int t;            scanf(&quot;%d&quot;,&amp;t);            if(dist[t]==0x3f3f3f3f||dist[t]&lt;3)printf(&quot;?\n&quot;);            else printf(&quot;%d\n&quot;,dist[t]);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4725</title>
    <link href="/2020/02/07/HDU-4725/"/>
    <url>/2020/02/07/HDU-4725/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4725 The Shortest Path in Nya Graph</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4725#author=0" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4725#author=0</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>现在给你n个点 ，这些点的分布是层型分布的，你可以从第i层走到相邻的层（i+1，i-1）中，这样走的花费是c，接着他会给你m（从u-&gt;v）条小路，从小路走的花费 是w，问你从1-&gt;n所走的最小花费是多少。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>看到数据范围就不敢用spfa了，太过玄学，不想TLE，所以选择dijkstra，这题的难点在于建边。当然，很容易想到将层转化成点，比如第i个点的层数为deep[i],则转化为点deep[i]+n.对于给的小道就直接建边a–&gt;b权值为c,b–&gt;a权值为c（建双向边），将deep数组从小到大排列，对于deep[i] 和 deep[i-1] （i∈[2,n]），首先要判断它们是否刚好相差1，只有刚好相差1才可以建边，建边方式为add(deep[i-1]+n,deep[i]+n,c);add(deep[i]+n,deep[i-1]+n,c)，相邻层数可以相互移动，消耗为c。</p><p>如何将点和层联系起来呢？<br>点i与它本来层的关系：add(deep[i]+n,i,0)；<br>点i与它上一层的关系(deep[i]&gt;1)：add(i,deep[i]-1+n,c)<br>点i与它下一层的关系(deep[i]&lt;n)：add(i,deep[i]+1+n,c)</p><p>ps:不可以add(i,deep[i]+n,0)；<br>原因：<br>1<br>3 0 1<br>1 1 1<br>本身1是不可到达3的，如果强行add(i,deep[i]+n,0)就会导致同层所有点相连了！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;int n,m,T,k=1,c,head[maxn],vis[maxn],dist[maxn],deep[maxn];struct node{    int to,next,w;}edge[maxn*8];struct N{    int now,w;    bool operator &lt; (N x)const{return x.w&lt;w;}};void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}void dijkstra(){    priority_queue&lt;N&gt;q;    memset(vis,0,sizeof(vis));    memset(dist,0x3f3f3f3f,sizeof(dist));    dist[1]=0;    N x;x.now=1;x.w=0;    q.push(x);    while(!q.empty())    {        x=q.top();q.pop();        if(vis[x.now])continue;        vis[x.now]=1;        for(int i=head[x.now];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x.now]+edge[i].w)            {                dist[edge[i].to]=dist[x.now]+edge[i].w;                N now;now.now=edge[i].to;now.w=dist[edge[i].to];                q.push(now);            }        }    }}int main(){    int now=0;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        now++;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(deep,0,sizeof(deep));        k=1;        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;c);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;deep[i]);//            add(i,n+deep[i],0);            add(n+deep[i],i,0);            if(deep[i]&gt;1)add(i,n+deep[i]-1,c);            if(deep[i]&lt;n)add(i,n+deep[i]+1,c);        }        sort(deep+1,deep+1+n);        for(int i=2;i&lt;=n;i++)        {            if(deep[i]-deep[i-1]!=1)continue;            add(deep[i-1]+n,deep[i]+n,c);            add(deep[i]+n,deep[i-1]+n,c);        }        for(int i=1;i&lt;=m;i++)        {            int a,b,w;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);            add(a,b,w);add(b,a,w);        }        dijkstra();        printf(&quot;Case #%d: &quot;,now);        if(dist[n]==0x3f3f3f3f)printf(&quot;-1\n&quot;);        else printf(&quot;%d\n&quot;,dist[n]);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3169</title>
    <link href="/2020/02/07/POJ-3169/"/>
    <url>/2020/02/07/POJ-3169/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3169 Layout</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3169#author=634579757" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3169#author=634579757</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有N头牛排队，多头牛可以在同一点。现有几对相互喜好的牛，他们不能超过一定距离，有几对相互厌恶的牛，他们至少隔开一定距离。求1和N最远相距多少。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这很显然是差分约束的题目。为了保证图能够联通，需要固定i，j的大小顺序。 对于前m1个a,b,c表示a和b之间的距离不超过c，不妨设a&gt;b，则应满足d[a]-d[b]&lt;=c，最短路的要求就是如此，所以建边：b–&gt;a 边权为c。对于后m2个a，b，c表示a和b之间的距离不小于c，不妨设a&gt;b，则应满足d[a]-d[b]&gt;=c，即d[b]&lt;=d[a]-c，所以建边：a–&gt;b边权为-c。然后开始跑spfa，期间要判断负环，如果有负环存在则说明无解；如果dist[n]==0x3f3f3f3f,说明n号可以无限远。其余的则dist[n]为答案</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int k=1,head[maxn],dist[maxn],vis[maxn],n,m1,m2,used[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    memset(used,0,sizeof(used));    dist[1]=0;vis[1]=1;used[1]=1;    q.push(1);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].w;                if(!vis[edge[i].to])                {                    used[edge[i].to]++;                    if(used[edge[i].to]&gt;n)return 1;                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return 0;}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m1,&amp;m2);    for(int i=1;i&lt;=m1;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        if(b&gt;a)swap(a,b);        add(b,a,c);    }    for(int i=1;i&lt;=m2;i++)    {        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        if(b&gt;a)swap(a,b);        add(a,b,-c);    }    int x=spfa();    if(x==1)printf(&quot;-1\n&quot;);    else     {        if(dist[n]==0x3f3f3f3f)printf(&quot;-2\n&quot;);        else printf(&quot;%d\n&quot;,dist[n]);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>差分约束</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4370</title>
    <link href="/2020/02/07/HDU-4370/"/>
    <url>/2020/02/07/HDU-4370/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4370 0 or 1</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4370#author=cjyl" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4370#author=cjyl</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给出一个n×n的矩阵，求一个符合题意的n×n的只含有0和1的矩阵，使得两个矩阵位置对应的元素相乘后和最小。</p><p>题意要求01矩阵：</p><ol><li><p>X12+X13+…+X1n=1</p><p>2.X14+X24+…+X(n-1)n=1</p><p>3.∑Xki (1&lt;=k&lt;=n)=∑Xij (1&lt;=j&lt;=n).（1&lt;i&lt;n）</p></li></ol><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>对于条件1，可以说明1结点一定有且仅有一个出度，并且不是指向自己。<br>对于条件2，可以说明n结点一定有且仅有一个入度，并且该入度的发出者不是自己。<br>对于条件3，可以说明每个2-n-1的每一个结点的出度等于入度。<br>而题目要求求ΣCij * X ij最小值，即求最短路。<br>但是要分2种情况：<br>原因：结点1一定会指向结点i(i∈[2,n])，然后结点i一定指向别的结点，注意结点i不可以直接指向它自己，因为这样出度就不等于入读。最终会指向结点n，或者指向结点1形成自环。对于结点n来讲也是一样。</p><p>情况1：结点1最终指向结点n，则dist[n]就是最小值</p><p>情况2：结点1形成自环，那么结点n也必须形成自环。则dist[1]+dist[n]为答案。<br>针对情况2需要跑两次spfa，第一次spfa以1为起点，第二次spfa以n为起点。</p><p>最终答案为min(ans,d1+d2)其中ans=dist[n],d1=dist[1]，d2=dist[n]（这是第二次跑的spfa的结果）</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=30000+5;int n,c[305][305],head[maxn],vis[maxn],dist[maxn];struct node{    int to,next,w;}edge[maxn*2];void spfa(int s){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=n;i++)    {        if(i==s)        continue;        else         {            dist[i]=c[s][i];            q.push(i);            vis[i]=1;        }    }    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=1;i&lt;=n;i++)        {            if(dist[i]&gt;dist[x]+c[x][i])            {                dist[i]=dist[x]+c[x][i];                if(!vis[i])                {                    vis[i]=1;                    q.push(i);                }            }        }    }}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                scanf(&quot;%d&quot;,&amp;c[i][j]);            }        }        spfa(1);        int ans=dist[n];        int d1=dist[1];        spfa(n);        int d2=dist[n];        printf(&quot;%d\n&quot;,min(ans,d1+d2));            }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA-10480</title>
    <link href="/2020/02/07/UVA-10480/"/>
    <url>/2020/02/07/UVA-10480/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>UVA - 10480 Sabotage</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/UVA-10480" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-10480</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个点，m条无向边，权值为wi。问从1到2，要割断的最小代价。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>1–&gt;2要进行割断并且要消耗最小，显然这是最小割问题。建边的时候要注意是双向边，起点s=1，终点t=2，跑dinic，最小割=最大流。<br>然后从s开始dfs，要edge[i].w&gt;0才开始继续，即s可到达的为一个集合，其余则为t可到达的。然后对于所有正向边，看是否u为s集合，v为t集合，<br>如果是就输出。<br>一开始想着这题和HDU - 4289 Control差不多，以为要拆点，结果就WA了。HDU - 4289 Control这道题由于是点权，将点转换成边，<br>所以需要拆点连边，而这道题说明了m条边的边权，所以不必拆点！<br>为什么割边的判断条件不是edge[i].w==0呢？原因是可能流量流过该边，并且最后该边edge[i].w==0但是实际上并没有割去这条边，<br>只是由于前面的流量影响了这条边！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int N=200+5;int k=1,head[maxn],deep[maxn],s,t,ans,n,m,vis[maxn];struct node{    int to,next,w,u;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].u=u;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}void DFS(int x){    if(vis[x])return ;    vis[x]=1;    for(int i=head[x];i;i=edge[i].next)    {        if(edge[i].w)        {            DFS(edge[i].to);            }    }}int main(){    while(1)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(vis,0,sizeof(vis));        ans=0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);add(b,a,0);            add(b,a,c);add(a,b,0);        }                s=1;t=2;        dinic();        DFS(s);        for(int i=2;i&lt;=k;i+=2)        {            if(vis[edge[i].u]==1&amp;&amp;vis[edge[i].to]==0)            {                int u=edge[i].u;int v=edge[i].to;                printf(&quot;%d %d\n&quot;,u,v);            }        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3436</title>
    <link href="/2020/02/07/POJ-3436/"/>
    <url>/2020/02/07/POJ-3436/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3436 ACM Computer Factory</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3436#author=yupengju" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3436#author=yupengju</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有p种零件，n个工厂加工，第i个工厂一小时可以加工Qi个电脑，对于每一个工厂第一个数字表示一小时加工数量Qi，<br>然后有p个数字，若为0则表示不能有这个零件，1则表示必须有这个零件，2表示有没有都无所谓。最后p个数字，表示加工后电脑零件的存在情况，<br>只有p个零件都为1才表示电脑加工完成。问一小时最多生产多少电脑？生产线有几条？如何设计？（special judge）（1 ≤ P ≤ 10, 1 ≤ N ≤ 50, 1 ≤ Qi ≤ 10000）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>如果一开始直接想以零件为个体来建图就相当复杂，感觉无从下手，于是就从略大一点的个体出发，从工厂出发，s为起点，t为终点，如果一开始工厂要求的零件都没有，即p个数字都是0或者2，则s–&gt;i，边权为工厂容量或者无穷大。由于工厂自身一小时生产力有限，因此要对工厂进行拆点，i–&gt;i+N，边权为工厂容量。如果一个工厂生产后电脑的零件情况与另一个工厂生产前对零件的要求情况一致，则可以连边，i+N–&gt;j，边权为无穷大。如果工厂生产后电脑的零件情况均为1，则可以连边，i+N–&gt;t,边权为无穷大或者工厂容量。<br>这样跑dinic就可以求得最大流，但是还要输出生产线的情况。如何记录呢？在建边的时候记录一下工厂最开始的容量，和边的起点。<br>跑完dinic之后，对所有的偶数边（偶数边才是正向边）判断容量是否减少了，并且起点∈[1+N,n+N],终点∈[1,N],然后储存起点，终点，流量。<br>最后依次输出即可</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=10000+5;const int N=52;int head[maxn],deep[maxn],k=1,s,t,p,n,ans,u[maxn],v[maxn],w[maxn];struct node{    int to,next,w,from,tot;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].from=u;edge[k].tot=w;}struct N{    int w,r[12],c[12];}a[maxn];bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;p,&amp;n)!=EOF)    {        k=1;s=0;t=4*N;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(u,0,sizeof(u));        memset(v,0,sizeof(v));        memset(w,0,sizeof(w));        memset(a,0,sizeof(a));        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i].w);            for(int j=1;j&lt;=p;j++)            {                scanf(&quot;%d&quot;,&amp;a[i].r[j]);            }            for(int j=1;j&lt;=p;j++)            {                scanf(&quot;%d&quot;,&amp;a[i].c[j]);            }        }        for(int i=1;i&lt;=n;i++)        {            int sign=0;            for(int k=1;k&lt;=p;k++)            {                if(a[i].r[k]==1)                {                    sign=1;                    break;                }            }            if(sign==0)            {                add(s,i,a[i].w);add(i,s,0);            }            add(i,i+N,a[i].w);add(i+N,i,0);            for(int j=1;j&lt;=n;j++)            {                sign=0;                if(i==j)continue;                for(int k=1;k&lt;=p;k++)                {                    if(a[i].c[k]!=a[j].r[k]&amp;&amp;a[j].r[k]!=2)                    {                        sign=1;                        break;                    }                }                if(sign==0)                {                    add(i+N,j,0x3f3f3f3f);add(j,i+N,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            int sign=0;            for(int k=1;k&lt;=p;k++)            {                if(a[i].c[k]!=1)                {                    sign=1;                    break;                }            }            if(sign==0)            {                add(i+N,t,a[i].w);add(t,i+N,0);            }        }        dinic();        int tot=0;        for(int i=2;i&lt;=k;i+=2)        {            if(edge[i].from&gt;=1+N&amp;&amp;edge[i].from&lt;=n+N&amp;&amp;edge[i].to&gt;=1&amp;&amp;edge[i].to&lt;=n&amp;&amp;edge[i].w&lt;edge[i].tot)            {                u[++tot]=edge[i].from-N;                v[tot]=edge[i].to;                w[tot]=edge[i].tot-edge[i].w;            }        }        printf(&quot;%d %d\n&quot;,ans,tot);        for(int i=1;i&lt;=tot;i++)        {            printf(&quot;%d %d %d\n&quot;,u[i],v[i],w[i]);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-3281</title>
    <link href="/2020/02/07/POJ-3281/"/>
    <url>/2020/02/07/POJ-3281/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 3281 Dining or  P2891 [USACO07OPEN]吃饭Dining</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-3281" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3281</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有F种食物和D种饮料，每种食物或饮料只能供一头牛享用，且每头牛只享用一种食物和一种饮料。<br>现在有n头牛，每头牛都有自己喜欢的食物种类列表和饮料种类列表，问最多能使几头牛同时享用到自己喜欢的食物和饮料。（1 &lt;= f &lt;= 100, 1 &lt;= d &lt;= 100, 1 &lt;= n &lt;= 100）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>我一开始想到的办法稍微有点复杂。首先着很明显是最大流问题，难点就只有建图，<br>最开始我想到的建图是一个超级源点，指向牛，然后牛指向食物，由于食物只有一次使用机会，所以食物–&gt;食物’（流量为1）表示的是，<br>该食物的数量为1，然后食物’指向牛’，牛’指向饮料，饮料–&gt;饮料’（流量为1），然后饮料’指向超级汇点。但是这种方法有问题。<br>至于问题，我现在没找到，之后再想想。</p><p>ps:后面想通了，由于牛–&gt;食物，食物–&gt;食物’，食物’–&gt;牛’；这样单次经过的牛可能不是同一头牛，会导致错乱，当然答案不对。</p><p>正确做法：显然上面的建图有点复杂了，对于牛来讲，它必须满足食物和饮料均有，所以将牛放在中间，超级源点指向牛，而每种牛只有一条，<br>所以牛–&gt;牛’（容量为1），牛’–&gt;饮料，饮料指向超级源点，跑网络流dinic就可以了</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=300000+5;const int N=101;int n,k=1,head[maxn],vis[maxn],deep[maxn],f,d,s,t,ans;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}int bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}int dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }    return ans;}int main(){//    freopen(&quot;P2891_3.in&quot;,&quot;r&quot;,stdin);    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d);    s=0;t=10*N;    for(int i=1;i&lt;=f;i++)    {        add(s,i,1);add(i,s,0);    }    for(int i=1;i&lt;=d;i++)    {        add(i+3*N,t,1);add(t,i+3*N,0);    }    for(int i=1;i&lt;=n;i++)    {        int fi,di;        scanf(&quot;%d%d&quot;,&amp;fi,&amp;di);        for(int j=1;j&lt;=fi;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(x,i+N,1);add(i+N,x,0);        }        add(i+N,i+2*N,1);add(i+2*N,i+N,0);        for(int j=1;j&lt;=di;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+2*N,x+3*N,1);add(x+3*N,i+2*N,0);        }    }    /*for(int i=1;i&lt;=n;i++)    {        add(s,i,1);add(i,s,0);    }    for(int i=1;i&lt;=n;i++)    {        int fi,di;        scanf(&quot;%d%d&quot;,&amp;fi,&amp;di);        for(int j=1;j&lt;=fi;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i,x+N,1);add(x+N,i,0);            add(x+2*N,i+3*N,1);add(i+3*N,x+2*N,0);        }        for(int j=1;j&lt;=di;j++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+3*N,x+4*N,1);add(x+4*N,i+3*N,0);            add(x+5*N,i+6*N,1);add(i+6*N,x+5*N,0);        }    }    for(int i=1;i&lt;=f;i++)    {        add(i+N,i+2*N,1);add(i+2*N,i+N,0);    }    for(int i=1;i&lt;=d;i++)    {        add(i+4*N,i+5*N,1);add(i+5*N,i+4*N,0);    }    for(int i=1;i&lt;=n;i++)    {        add(i+6*N,t,1);add(t,i+6*N,0);    }*/    dinic();    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2516</title>
    <link href="/2020/02/07/POJ-2516/"/>
    <url>/2020/02/07/POJ-2516/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2516 Minimum Cost</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2516" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2516</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有 n 个商店，k种物品和 m 个供货商，让你求进满足商店需求的货物的最小花费？<br>有必要说一下输入数据。<br>首先n ，k ，m。<br>然后是一个n*m的矩阵，n个商店对每种货物的需求，表示第 i 个商店需要第 j 种货物 x个?<br>然后是m * k 的矩阵，m个供货商可以供k种货物的数量，表示第 i 个供货商 提供第 j 中货物 x 个<br>接下来是 k 个 n * m 的矩阵，表示第 i 个货物，由 k 供应商发货给 j 商店的价格x<br>（注意如果供不应求的或输出-1）</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始将商店分成很多，对于商品1有1-n商店，对于商品2有n+1-2<em>n商店，对于商品k有n</em>（k-1）-n<em>k商店。<br>对于供货商也是同理，s为起点，与商店连接，边权为商店对该物品的需求，费用为0，t为终点，供货商与t连接，边权为供货商能提供的量，费用为0，然后有后面k个矩阵可以建图，商店与供货商连接，注意要一一对应，因为商店和供货商相当于拆了点了，边权为无穷大，费用为价格。<br>但是最后跑费用流就凉了，TLE！！！难受！<br>然后看了一下题解，题解的办法是对于每次的商品来跑费用流，就不需要对商店和供货商进行拆点，跑k次费用流。<br>如果maxflow==需求，就输出mincost，否则就输出-1<br>TLE原因：SPFA费用流算法在稠密图上运行比较慢。可以将一个稠密大图拆成多个小图，虽然小图依然是稠密图，但是减少的幅度是非常大的。<br>从2500</em>2500到50*50.这样，只需建K次图，跑K遍SPFA费用流即可。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N=3000+5;const int maxn=40000+5;int k=1,sign,ans,n,m,q,s,t,head[maxn],dist[maxn],vis[maxn],flow[maxn],pre[maxn],last[maxn],maxflow,mincost,rd[52][52],cd[52][52];struct node{    int to,next,w,dis;}edge[maxn*2];void add(int u,int v,int w,int dis){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].dis=dis;}bool spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(flow,0x3f3f3f3f,sizeof(flow));    memset(vis,0,sizeof(vis));    memset(pre,0,sizeof(pre));    memset(last,0,sizeof(last));    vis[s]=1;dist[s]=0;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].dis&amp;&amp;edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].dis;                pre[edge[i].to]=x;                last[edge[i].to]=i;                flow[edge[i].to]=min(flow[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return pre[t];}void MCMF(){    while(spfa())    {        maxflow+=flow[t];        mincost+=flow[t]*dist[t];        int now=t;        while(now!=s)        {            edge[last[now]].w-=flow[t];            edge[last[now]^1].w+=flow[t];            now=pre[now];        }    }}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q)!=EOF)    {        s=0;t=N*5;        k=1;ans=0;sign=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        maxflow=0;mincost=0;        if(n==0&amp;&amp;m==0&amp;&amp;q==0)break;        int tot=0;        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=q;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                tot+=x;                rd[i][j]=x;            }        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=q;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                cd[i][j]=x;            }        }        for(int i=1;i&lt;=q;i++)        {            k=1;            memset(head,0,sizeof(head));            memset(edge,0,sizeof(edge));            maxflow=0;mincost=0;            for(int j=1;j&lt;=n;j++)            {                add(s,j,rd[j][i],0);add(j,s,0,0);            }            for(int j=1;j&lt;=m;j++)            {                add(j+N,t,cd[j][i],0);add(t,j+N,0,0);            }            for(int j=1;j&lt;=n;j++)            {                for(int p=1;p&lt;=m;p++)                {                    int x;scanf(&quot;%d&quot;,&amp;x);                    add(j,p+N,0x3f3f3f3f,x);add(p+N,j,0,-x);                }            }            MCMF();            ans+=mincost;            sign+=maxflow;        }        if(sign==tot)        printf(&quot;%d\n&quot;,ans);        else         printf(&quot;-1\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-2195</title>
    <link href="/2020/02/07/POJ-2195/"/>
    <url>/2020/02/07/POJ-2195/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 2195 Going Home</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-2195#author=hrbustacm" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-2195#author=hrbustacm</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>免费送房子，m表示人，H表示房子，每个房子只能进一个人，房子数等于人数。<br>黄弘毅为了方便起见决定要让所有人到自己的房子的距离和最小，请问这个距离和是多少？</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>距离和，这个问题一看显然就是费用流问题，而此题就是最小费用流的裸题，将人和房子统计出来，然后s与人连边，边权为1，费用dis为0，房子与t连边，边权为0，费用dis为0，人与房子连边，边权为1，费用dis为曼哈顿距离。然后跑MCMF就可以了。</p><p>ps：我麻烦了一点，对房子进行了拆点，其实可以不拆，毕竟与t相连，流量固定了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int n,m,k=1,s,t,head[maxn],flow[maxn],dist[maxn],x1[maxn],x2[maxn],y1[maxn],y2[maxn];int vis[maxn],maxflow,mincost,pre[maxn],last[maxn];struct node{    int to,next,w,dis;}edge[maxn*2];void add(int u,int v,int w,int dis){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;edge[k].dis=dis;}bool spfa(){    queue&lt;int&gt;q;    memset(dist,0x3f3f3f3f,sizeof(dist));    memset(flow,0x3f3f3f3f,sizeof(flow));    memset(vis,0,sizeof(vis));    memset(pre,0,sizeof(pre));    memset(last,0,sizeof(last));    vis[s]=1;dist[s]=0;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();vis[x]=0;        for(int i=head[x];i;i=edge[i].next)        {            if(dist[edge[i].to]&gt;dist[x]+edge[i].dis&amp;&amp;edge[i].w)            {                dist[edge[i].to]=dist[x]+edge[i].dis;                pre[edge[i].to]=x;                last[edge[i].to]=i;                flow[edge[i].to]=min(flow[x],edge[i].w);                if(!vis[edge[i].to])                {                    vis[edge[i].to]=1;                    q.push(edge[i].to);                }            }        }    }    return pre[t];}void MCMF(){    while(spfa())    {        maxflow+=flow[t];        mincost+=flow[t]*dist[t];        int now=t;        while(now!=s)        {            edge[last[now]].w-=flow[t];            edge[last[now]^1].w+=flow[t];            now=pre[now];        }    }}int main(){    while(1)    {        s=0,t=4*N;        int tot1=0,tot2=0;        maxflow=0;mincost=0;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(x1,0,sizeof(x1));        memset(x2,0,sizeof(x2));        memset(y1,0,sizeof(y1));        memset(y2,0,sizeof(y2));        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)break;        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=0;j&lt;x.length();j++)            {                if(x[j]==&#39;m&#39;)                {                    tot1++;x1[tot1]=j+1;y1[tot1]=i;                }                else if(x[j]==&#39;H&#39;)                {                    tot2++;x2[tot2]=j+1;y2[tot2]=i;                }            }        }        for(int i=1;i&lt;=tot1;i++)        {            add(s,i,1,0);add(i,s,0,0);            for(int j=1;j&lt;=tot2;j++)            {                int w=abs(x1[i]-x2[j])+abs(y1[i]-y2[j]);                add(i,j+N,1,w);add(j+N,i,0,-w);            }        }        for(int i=1;i&lt;=tot2;i++)        {            add(i+N,t,1,0);add(t,i+N,0,0);        }        MCMF();        printf(&quot;%d\n&quot;,mincost);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>费用流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1459</title>
    <link href="/2020/02/07/POJ-1459/"/>
    <url>/2020/02/07/POJ-1459/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1459 Power Network</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1459#author=alexandleo" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1459#author=alexandleo</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>每组测试数据给出N，Np，Nc，M。N代表结点数量，M代表边的数量，Np代表结点中电站的数量（只产电，不耗电），<br>Nc代表消费者数量（只耗电，不产电），其他结点代表中转站（不产电，不耗电）。<br>接着M组（u，v）w数据，代表u到v容量为w，接着Np组（u）w，代表结点u产电w，接着Nc组（u）w，代表结点u耗电w。<br>求电网中能消耗的最大电能值。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>求最大电能，显然这是最大流问题，s与所有的电站连接，边权为产电量，t与所有的消费者连接，边权为耗电量，然后根据m条边的信息，<br>如果u，v属于电站，则值不变，如果不是电站，那么需要+N，成为另一个集合，再建边，边权为容量w，然后跑网络流dinic。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=205;int k=1,s,t,head[maxn],deep[maxn],n,m,np,nc,ans,vis[maxn],u[maxn],v[maxn],w[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;np,&amp;nc,&amp;m)!=EOF)    {        ans=0;        k=1;        memset(head,0,sizeof(head));        memset(vis,0,sizeof(vis));        t=N*5;s=t+1;        for(int i=1;i&lt;=m;i++)        {            char x,y,z;            int a,b,c;            cin&gt;&gt;x&gt;&gt;a&gt;&gt;y&gt;&gt;b&gt;&gt;z&gt;&gt;c;            u[i]=a;v[i]=b;w[i]=c;        }        for(int i=1;i&lt;=np;i++)        {            int b,c;char x,y;            cin&gt;&gt;x&gt;&gt;b&gt;&gt;y&gt;&gt;c;            add(s,b,c);add(b,s,0);            vis[b]=1;        }        for(int i=1;i&lt;=m;i++)        {            if(!vis[u[i]])u[i]+=N;            if(!vis[v[i]])v[i]+=N;            add(u[i],v[i],w[i]);add(v[i],u[i],0);        }        for(int i=1;i&lt;=nc;i++)        {            int b,c;char x,y;            cin&gt;&gt;x&gt;&gt;b&gt;&gt;y&gt;&gt;c;            add(b+N,t,c);add(t,b+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1087</title>
    <link href="/2020/02/07/POJ-1087/"/>
    <url>/2020/02/07/POJ-1087/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>POJ - 1087 A Plug for UNIX</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/POJ-1087#author=cjyl" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1087#author=cjyl</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>宾馆里有几种插座，分别有其对应型号，你携带了几种用电器（手机，电脑一类的），也有其对应型号；<br>可是不一定用电器就能和插座匹配上，于是宾馆的商店里提供了一些转换器，这些转换器可以将某一型号电源转换成另一型号的。<br>问，你的用电器最少会有多少种无法充电 。注意插座型号是字符串形式，长度小于24，用电器名称也是字符串。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这是最大流问题。先说一下细节，插座和用电器的数量肯定都只有一个，但是转换器的数量是无限的。<br>建图：设起点为s，终点为t，首先s与所有的用电器相连，边权为1，（一开始还想着拆点，我怕是个哈批啊，对于两边的点，边权就是容量，<br>不需要去拆点！），t与所有的插座相连。如果型号相同，就可以二者之间进行连边。然后对于转换器，转换器之间可以相连，并且转换可以实现A–&gt;B，<br>也可以实现B–&gt;A。所以，对于用电器型号=A||B的都可以连边，对于插座型号=A||B的都可以连边，边权为1，对于转换器之间可以相连的，直接连接，<br>由于容量无穷大，因此不必拆点！</p><p>代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;const int maxn=300000+5;const int N=200+5;int s,t,n,k=1,m,q,ans,head[maxn],deep[maxn];char r[maxn][25],mr[maxn][25],mc[maxn][25];struct node{    int to,next,w;}edge[maxn*2];struct N{    char s[40];char r[25];}a[maxn];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    ans=0;    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        s=0;t=4*N;        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,r[i]);        }        scanf(&quot;%d&quot;,&amp;q);        for(int i=1;i&lt;=q;i++)        {            add(s,i,1);add(i,s,0);            char x;            scanf(&quot;%s%s&quot;,a[i].s,a[i].r);        }        for(int i=1;i&lt;=q;i++)        {            for(int j=1;j&lt;=n;j++)            {                if(strcmp(a[i].r,r[j])==0)                {                    add(i,j+N,1);add(j+N,i,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            add(i+N,t,1);add(t,i+N,0);        }        scanf(&quot;%d&quot;,&amp;m);        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%s%s&quot;,mr[i],mc[i]);            for(int j=1;j&lt;=q;j++)            {                if(strcmp(a[j].r,mr[i])==0||strcmp(a[j].r,mc[i])==0)                {                    add(j,i+2*N,1);add(i+2*N,j,0);                }            }            for(int j=1;j&lt;=n;j++)            {                if(strcmp(r[j],mc[i])==0||strcmp(r[j],mr[i])==0)                {                    add(i+2*N,j+N,1);add(j+N,i+2*N,0);                }            }        }        for(int i=1;i&lt;=m;i++)        {            for(int j=1;j&lt;=m;j++)            {                if(i!=j&amp;&amp;strcmp(mc[i],mr[j])==0)                {                    add(i+2*N,j+2*N,0x3f3f3f3f);add(j+2*N,i+2*N,0);                }            }            for(int j=1;j&lt;=m;j++)            {                if(i!=j&amp;&amp;strcmp(mr[i],mc[j])==0)                {                    add(i+2*N,j+2*N,0x3f3f3f3f);add(j+2*N,i+2*N,0);                }            }        }        dinic();        printf(&quot;%d\n&quot;,q-ans);    }    return 0;}    </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4292</title>
    <link href="/2020/02/07/HDU-4292/"/>
    <url>/2020/02/07/HDU-4292/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4292 Food</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4292#author=yupengju" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4292#author=yupengju</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>昊妈决定只给每个人一种食物和一种饮料，而且每种饮料和食物都只能提供有限次。现在给出每个人喜欢的食物种类和饮料种类，<br>昊妈可以最多让多少人得到满足呢？第一行给出N F D表示人数，食物种类数，饮料种类数第二行给出F个数字表示第i种食物有几个第三行给出D个数字<br>表示第i种饮料有几个接下来N行分别给出第i个人对第j种食物的喜爱情况，Y是喜欢N是不喜欢，再来N行对饮料的</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>这道题是最大流问题，重点自然就是建图，一个人要满足，必须同时拥有食物和饮料。而一个人也最多可以满足一次，<br>而且饮料和食物的容量也是有限的。最简单的自然是食物连向起点，边权为食物的容量；饮料连向中点，边权为饮料的容量；如果某人i喜欢食物j，<br>那么二者就要连边，即j–&gt;i+N，边权为1，并且人位于中间必须拆点，即i+N–&gt;i+2<em>N,边权为1。如果某人i喜欢饮料j，那么i+2</em>N–&gt;j+3*N，边权为1<br>建好后跑dinic。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int k=1,n,f,d,deep[maxn],head[maxn],ans,s,t;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(edge[i].w&amp;&amp;!deep[edge[i].to])            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d)!=EOF)    {        k=1;s=0;t=5*N;ans=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        for(int i=1;i&lt;=f;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(s,i,x);add(i,s,0);        }        for(int i=1;i&lt;=d;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i+3*N,t,x);add(t,i+3*N,0);        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=1;j&lt;=f;j++)            {                if(x[j-1]==&#39;Y&#39;)                {                    add(j,i+N,1);add(i+N,j,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;            for(int j=1;j&lt;=d;j++)            {                if(x[j-1]==&#39;Y&#39;)                {                    add(i+2*N,j+3*N,1);add(j+3*N,i+2*N,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            add(i+N,i+2*N,1);add(i+2*N,i+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4289</title>
    <link href="/2020/02/07/HDU-4289/"/>
    <url>/2020/02/07/HDU-4289/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4289 Control</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4289" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4289</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给一个无向图，有些不法分子要从S点T点，现在要抓住所有的不法分子阻止他们去T，那么就要控制某一些城市等待他们，<br>控制每个城市花费不同，问最少花费是多少。第一行是两个整数N，M（2&lt;=N&lt;=200，1&lt;=M&lt;=20000）,分别表示城市数量和道路数量，<br>城市的编号为1到N。 第二行是两个整数S，T（1&lt;=S,T&lt;=N）,分别表示起点和终点的位置。 接下来以下N行，分别表示控制第每一个城市的成本costi<br>（cost&lt;10^7）。 接下来M行，每行有两个整数A，B表示城市A和B之间存在一条双向道路。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>根据题意，要设法将S，T分割开，求最小花费，显然是求图的最小割，即求最大流。一开始想着单独将S，T隔开，<br>无向边u，v建边：u+N–&gt;v,边权0x3f3f3f3f，v+N-&gt;u，边权0x3f3f3f3f，当然回路也要建立。然后跑dinic，然后将跑出来的最大流和单独隔离s、单独隔离t三者取最小。但是这样跑出来不对。</p><p>错误原因就是：这是双向图，s可以作为起点，也可以作为中间点。</p><p>正确做法是：无向边u，v建边：u+N–&gt;v,边权0x3f3f3f3f，v+N-&gt;u，边权0x3f3f3f3f，当然回路也要建立，然后u–&gt;u+N,边权为cost。<br>然后从s–&gt;t+N，跑dinic，求最大流。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=50000+5;const int N=200+5;int k=1,n,m,s,t,ans,head[maxn],deep[maxn];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(edge[i].w,F-f));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        k=1;ans=0;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);t+=N;        for(int i=1;i&lt;=n;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(i,i+N,x);add(i+N,i,0);        }        for(int i=1;i&lt;=m;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            add(a+N,b,0x3f3f3f3f);add(b,a+N,0);            add(b+N,a,0x3f3f3f3f);add(a,b+N,0);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-4280</title>
    <link href="/2020/02/07/HDU-4280/"/>
    <url>/2020/02/07/HDU-4280/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 4280 Island Transport</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-4280#author=smilestruggler" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4280#author=smilestruggler</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>在n个岛屿中，有m条双向航线，航线有单位时间内的运输上限，现在求从最左侧到最右侧的最大运输</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>题意含明显它是最大流的模板题，直接建边，然后找到起点s和终点t就可以了，然后直接跑dinic。但是n=100000，m=100000，数据规模大，<br>dinic容易超时，但是我们可以做优化。</p><p>优化1：bfs只要跑到t就返回1，开始dfs。</p><p>优化2；dfs内每次min(F-f,edge[i].w），f表示之前已经流过的流量，F-f表示剩余可流的流量，一旦F==f就break，表示满流了！</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;int T,n,m,s,t,head[maxn],deep[maxn],k=1,ans;struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        ans=0;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        int minn=0x3f3f3f3f,maxx=-0x3f3f3f3f;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            if(minn&gt;x)            {                minn=x;                s=i;            }            if(maxx&lt;x)            {                maxx=x;                t=i;            }        }        for(int i=1;i&lt;=m;i++)        {            int a,b,c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c);            add(b,a,c);        }        dinic();        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3605</title>
    <link href="/2020/02/07/HDU-3605/"/>
    <url>/2020/02/07/HDU-3605/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3605 Escape</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3605" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3605</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有n个人，m个星球，前n行，每一行有m个数字，分别表示第i个星球是否适合这个人。最后一行有m个，表示每个星球的最多居住人数。n (1 &lt;= n &lt;= 100000), m (1 &lt;= m &lt;= 10)</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>一开始想多没想就开始建裸图，心里想：别看着图稠密，边多，实际上一跑就出结果了。事实证明自己太天真，n<em>n</em>m的数据量早就TLE！<br>正确做法有点意思：由于m很小，就可以考虑状态压缩。对于第i个人，m个星球的居住情况已知，转换为二进制储存，所有的状态也不过才2^10而已，<br>起点s连向状态，边权为这种状态的总人数，然后10个星球与这种状态匹配，若星球属于这个状态，则状态连向星球，边权为无穷大，<br>然后星球与终点t连接，边权为星球的最大居住人数。然后就可以跑dinic了，若ans==n，就YES，否则就NO。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=5000;int k=1,head[maxn],deep[maxn],n,m,s,t,ans,now[1&lt;&lt;11];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        s=0,t=2*N;        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(now,0,sizeof(now));        ans=0;        for(int i=1;i&lt;=n;i++)        {            int state=0;            for(int j=1;j&lt;=m;j++)            {                int x;scanf(&quot;%d&quot;,&amp;x);                if(x==1)                {                    state=state|(1&lt;&lt;(j-1));                }            }            now[state]++;        }        for(int i=0;i&lt;=(1&lt;&lt;m)-1;i++)        {            if(now[i])            {                add(s,i,now[i]);add(i,s,0);                for(int j=1;j&lt;=m;j++)                {                    if((i&amp;(1&lt;&lt;(j-1)))&gt;0)                    {                        add(i,N+j,0x3f3f3f3f);add(N+j,i,0);                    }                }            }        }        for(int i=1;i&lt;=m;i++)        {            int x;scanf(&quot;%d&quot;,&amp;x);            add(N+i,t,x);add(t,N+i,0);        }        dinic();        if(n==ans)        {            printf(&quot;YES\n&quot;);        }        else         {            printf(&quot;NO\n&quot;);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-3081</title>
    <link href="/2020/02/07/HDU-3081/"/>
    <url>/2020/02/07/HDU-3081/</url>
    
    <content type="html"><![CDATA[<h4 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h4><p>HDU - 3081 Marriage Match II</p><h4 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h4><p><a href="https://vjudge.net/problem/HDU-3081" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-3081</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有N个女孩要与N个男孩玩配对游戏.每个女孩有一个可选男孩的集合(即该女孩可以选自己集合中的任意一个男孩作为该轮的搭档).<br>然后从第一轮开始,每个女孩都要和一个不同的男孩配对.如果第一轮N个女孩都配对成功,那么就开始第二轮配对,女孩依然从自己的备选男孩集合中选择,<br>但是不能选那些已经被该女孩在前几轮选择中选过的男孩了(比如i女孩在第一轮选了j男孩,那么i在第二轮就不能选j男孩了). 问你游戏最多能进行多少轮?</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>女生:1<del>n;男生:(n+1)</del>(n*2)。对于女生u，她可以直接连向不讨厌的男生，边权为1。</p><p>假设我们当前二分尝试的轮数为K(即能够进行K轮匹配):首先如果女孩i可能选择男孩j,那么就有边(i, j+n, 1).且源点到每个女孩i有边(s,i,K),<br>每个男孩j到汇点t有边(j+n,t,K).</p><p>如果最大流==K*n,那么就表示可以进行最少K轮匹配.</p><p>证明：如果满流,那么每个女生肯定选择了K个不同的男孩,每个男孩肯定被K个不同的女孩选择了(因为一个女孩到一个男孩边容量只为1,所以该女孩最多只能选该男孩一次).<br> 那么上面这样就能保证这个游戏可以进行K轮吗?可以的,假设当前图的流量为0,说明任何女孩都没选男孩. 你可以想象假如此时从S到所有女孩有流量1<br>(虽然容量是K,但是目前我们只放出1流量)流出,那么这些流量肯定会汇集到t(因为最大流为K<em>n,而我们此时只不过n流量).<br>这个汇集的过程就是第一轮女孩选择了各自不同男孩的结果. 现在从S到所有女孩又有流量1流出(即第二轮开始了),<br>这些流量肯定又经过了n个男孩汇集到t点了 且 如果上一轮i女孩的流量走到j男孩,这一轮i女孩的流量肯定不走j男孩了(因为i女孩到j男孩的边只有1容量).<br>综上所述,只要最大流==K</em>n,那么就能进行K轮.</p><p>即如果女孩{1,2,3,4,5,6,7,8,9}是朋友的话,且2号女孩能选择男孩3,我们如果标记来使得其他所有女孩都能选择男孩3呢?<br>我选择的是闭包传递，当然也可以用并查集。<br>ps：不要把男孩也算进,比如女孩1与男孩2能选,女孩3与男孩2能选,但是女孩1与女孩3可不是朋友,她们不属于同一个并查集。<br>一开始这里就出了问题。如果我们dist[a][b+N]=1,而dist[b+N][a]不管，就不存在问题了！</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=200000+5;const int N=200+5;int k=1,head[maxn],deep[maxn],s,t,n,m,ans,T,f,dist[N][N];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}bool solve(int mid){        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        ans=0;        for(int i=1;i&lt;=n;i++)        {            add(s,i,mid);add(i,s,0);        }        for(int i=1;i&lt;=n;i++)        {            for(int j=n+1;j&lt;=2*n;j++)            {                if(dist[i][j]==0x3f3f3f3f)continue;                add(i,j,1);add(j,i,0);            }        }        for(int i=1+n;i&lt;=n*2;i++)        {            add(i,t,mid);add(t,i,0);        }        dinic();        if(ans==mid*n)return 1;        return 0;}int main(){    //1-ngirl,(n+1)-(2*n)boy    scanf(&quot;%d&quot;,&amp;T);    while(T--)    {        k=1;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        ans=0;        s=0,t=8*N;        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;f);        memset(dist,0x3f3f3f3f,sizeof(dist));        for(int i=1;i&lt;=m;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b+n]=1;        }        for(int i=1;i&lt;=f;i++)        {            int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            dist[a][b]=dist[b][a]=1;        }        for(int K=1;K&lt;=2*n;K++)        {            for(int i=1;i&lt;=2*n;i++)            {                for(int j=1;j&lt;=2*n;j++)                {                    if(dist[i][K]==1&amp;&amp;dist[K][j]==1)                    {                        dist[i][j]=1;                    }                }            }        }        int l=0,r=n,ANS=0;        while(l&lt;=r)        {            int mid=(l+r)/2;            if(solve(mid))            {                ANS=mid;                l=mid+1;            }            else r=mid-1;        }        printf(&quot;%d\n&quot;,ANS);    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>二分</tag>
      
      <tag>闭包传递</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU-2732</title>
    <link href="/2020/02/07/HDU-2732/"/>
    <url>/2020/02/07/HDU-2732/</url>
    
    <content type="html"><![CDATA[<h3 id="题目名称："><a href="#题目名称：" class="headerlink" title="题目名称："></a>题目名称：</h3><p>HDU - 2732 Leapin’ Lizards</p><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://vjudge.net/problem/HDU-2732" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-2732</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>题目是说一个n*m的迷宫中，有每个格子有柱子。柱子高度为0~3，高度为0的柱子是不能站的（高度为0就是没有柱子）<br>在一些有柱子的格子上有一些蜥蜴，一次最多跳距离d,相邻格子的距离是1，只要跳出迷宫就是安全的。这个距离是曼哈顿距离（好像是的）<br>。蜥蜴一次最多跳距离d,但是起跳的地方的柱子高度会减一，一个柱子同一时间只能有一个蜥蜴要求最少几个不能逃出迷宫。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>最大流问题，求出dinic跑出的最大流，然后总数-ans就是剩余的数。建图方法：</p><p>1.每个柱子有容纳量，超过了就塌了。u–&gt;u’ 边权为容纳量</p><p>2.有蜥蜴的柱子与起点s相连，即s–&gt;u,边权为1</p><p>3.边界上可以跳出界的与终点相连，条件(x1&lt;=p||y1&lt;=p||n-x1+1&lt;=p||len-y1+1&lt;=p)&amp;&amp;h[x1][y1]，u’–&gt;t,边权0x3f3f3f3f</p><p>4.任意两个有容纳量的柱子，且曼哈顿距离&lt;=d，可以相连，即u’–&gt;v,v’-&gt;u，边权为0x3f3f3f3f.</p><p>ps：1.注意输出时候单复数！<br>2.注意是j+(i-1)*len(len 表示一行的列数！！！）一开始写成了n，WA了一片。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100000+5;const int N=500+5;int k=1,head[maxn],deep[maxn],s,t,n,m,T,ans,p,h[30][N*10];struct node{    int to,next,w;}edge[maxn*2];void add(int u,int v,int w){    edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;}bool bfs(){    queue&lt;int&gt;q;    memset(deep,0,sizeof(deep));    deep[s]=1;    q.push(s);    while(!q.empty())    {        int x=q.front();q.pop();        for(int i=head[x];i;i=edge[i].next)        {            if(!deep[edge[i].to]&amp;&amp;edge[i].w)            {                deep[edge[i].to]=deep[x]+1;                q.push(edge[i].to);            }        }    }    return deep[t];}int dfs(int x,int F){    if(x==t)return F;    int f=0;    for(int i=head[x];i;i=edge[i].next)    {        if(deep[edge[i].to]==deep[x]+1&amp;&amp;edge[i].w)        {            int w=dfs(edge[i].to,min(F-f,edge[i].w));            edge[i].w-=w;edge[i^1].w+=w;f+=w;            if(f==F)break;        }    }    if(!f)deep[x]=0;    return f;}void dinic(){    while(bfs())    {        ans+=dfs(s,0x3f3f3f3f);    }}int main(){    scanf(&quot;%d&quot;,&amp;T);    int opt=0;    while(T--)    {        opt++;        k=1;ans=0;s=0;t=5*N;        memset(head,0,sizeof(head));        memset(edge,0,sizeof(edge));        memset(h,0,sizeof(h));        scanf(&quot;%d%d&quot;,&amp;n,&amp;p);        int len=0;int tot=0;        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;len=x.length();            for(int j=1;j&lt;=len;j++)            {                int w=x[j-1]-&#39;0&#39;;h[i][j]=w;                if(w)                {                    add(j+(i-1)*len,j+(i-1)*len+N,w);add(j+(i-1)*len+N,j+(i-1)*len,0);                }            }        }        for(int i=1;i&lt;=n;i++)        {            string x;            cin&gt;&gt;x;len=x.length();            for(int j=1;j&lt;=len;j++)            {                if(x[j-1]==&#39;L&#39;)                {                    tot++;                    add(s,j+(i-1)*len,1);add(j+(i-1)*len,s,0);                }            }        }        for(int x1=1;x1&lt;=n;x1++)        {            for(int y1=1;y1&lt;=len;y1++)            {                for(int x2=1;x2&lt;=n;x2++)                {                    for(int y2=1;y2&lt;=len;y2++)                    {                        if(x1==x2&amp;&amp;y1==y2)continue;                        if(abs(x1-x2)+abs(y1-y2)&gt;p)continue;                        if(!h[x1][y1]||!h[x2][y2])continue;                        add(y1+(x1-1)*len+N,y2+(x2-1)*len,0x3f3f3f3f);add(y2+(x2-1)*len,y1+(x1-1)*len+N,0);                        add(y2+(x2-1)*len+N,y1+(x1-1)*len,0x3f3f3f3f);add(y1+(x1-1)*len,y2+(x2-1)*len+N,0);                    }                }            }        }        for(int x1=1;x1&lt;=n;x1++)        {            for(int y1=1;y1&lt;=len;y1++)            {                if((x1&lt;=p||y1&lt;=p||n-x1+1&lt;=p||len-y1+1&lt;=p)&amp;&amp;h[x1][y1])                {                    add(y1+(x1-1)*len+N,t,0x3f3f3f3f);add(t,y1+(x1-1)*len+N,0);                }            }        }        dinic();        printf(&quot;Case #%d: &quot;,opt);        if(ans==tot)        {            printf(&quot;no lizard was left behind.\n&quot;);            continue;        }        else if(tot-ans==1)        {            printf(&quot;1 lizard was left behind.\n&quot;);        }        else         {            printf(&quot;%d lizards were left behind.\n&quot;,tot-ans);        }    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
